<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（2）：ES6带来的重大特性]]></title>
    <url>%2F2019%2F03%2F10%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%EF%BC%9AES6%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%87%8D%E5%A4%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[ECMAScript 2015，即ES6， 是 ECMAScript 标准的基础版本，该版本距离上个版本 ECMAScript 5.1 发布有四年之久，也是从这个版本开始将版本改为以年命名。所以它不应该叫做 ES6（尽管每个人都这么叫），而是 ES2015。 ES5 从 1999 年到2009年花费了十年时间完善，尽管对于这个语言来讲，它也是一个重要版本，但是太长时间过去了，已经不值得我们讨论 ES5 之前的代码是如何工作的。 从 ES5.1 到 ES6，JavaScript 语言有了重要的新特性以及在更好的实践中的关键更新。要了解 ES2015 的基本功能，请参阅规范文档的250页到600页。 ES2015 中的重要更新包括： 箭头函数 Promises 生成器函数(Generators) let 和 const 类(Classes) 模块 多行字符串 模板字面量 默认参数 扩展运算符 解构赋值 增强的对象字面量 for..of 循环 Map 和 Set 在这篇指南中，我将在每个章节中专门介绍它们。让我们开始吧！ 箭头函数箭头函数改变了大多数 JavaScript 代码的书写习惯和工作方式。 从视觉上来讲，它更简单了，因此也很受欢迎，比如： 123const foo = function foo() &#123; // ...&#125; 变成： 123const foo = () =&gt; &#123; // ...&#125; 如果这个函数体只有一行，可以是这样： 1const foo = () =&gt; doSomething() 如果只有一个参数，可以这样写： 1const foo = param =&gt; doSomething(param) 这不是一个破坏性的改变，因为常规函数可以继续像以前一样正常工作。 新的 this 作用域箭头函数的 this 作用域继承自执行上下文(the context)。 常规函数中，this 总是指最近的函数。然而在箭头函数中这个问题不存在了，你不再需要重写一遍 var that = this。 PromisesPromises 帮我们解决了著名的“回调地狱”问题，虽然它引入了更复杂的问题（已经可以在 ES2017 中通过更高级的构造函数 asnyc 解决 ）。 在 ES2015 之前，JavaScript 开发者就可以通过使用不同的库（jQuery，q，deferred.js，vow…）实现类似 Promises 的功能。该标准制定了更通用的方法。 通过使用 promises，你可以重构以下代码： 123456setTimeout(function() &#123; console.log('I promised to run after 1s') setTimeout(function() &#123; console.log('I promised to run after 2s') &#125;, 1000)&#125;, 1000) 等同于： 12345678const wait = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000)&#125;)wait().then(() =&gt; &#123; console.log('I promised to run after 1s') return wait()&#125;).then(() =&gt; console.log('I promised to run after 2s')) 生成器函数(Generators)生成器是一种特殊的函数，能够暂停输出，稍后恢复，而且允许其它代码在此期间运行。 代码本身决定了它必须等待，以便让其它代码“按照队列”顺序运行，并保持 “当它正在等待的东西” 完成时恢复其操作的权利。所有的这些都通过一个简单的关键字 yield 来完成。当一个生成器包含该关键字，代码将暂停执行。生成器可以包含很多个 yield 关键字，因此可以暂停很多次，并且通过 *function 关键字标识，不要与 C 语言，C++ 或者 Go 等底层语言的指针反向引用操作符混淆。 生成器在JavaScript中开启了全新的编程范例，比如： 生成器运行中双向通信 持久的 while 循环，不会冻结程序 这里有个例子可以解释生成器是如何工作的： 12345function *calculator(input) &#123; var doubleThat = 2 * (yield (input / 2)) var another = yield (doubleThat) return (input * doubleThat * another)&#125; 我们用下面的代码初始化这个 Generator(生成器)函数： 1const calc = calculator(10) 然后我们在生成器上启动迭代器： 1calc.next() 第一次迭代，代码返回了 this 对象： 1234&#123; done: false value: 5&#125; 发生了什么呢？函数开始运行时，input = 10 作为参数传入了生成器的构造函数中，直到遇到 yield，返回了 yeild 的内容：input / 2 = 5。所以我们得到了一个值为 5，并且告诉我们迭代没有完成（仅仅是函数暂停了）。 在第二次迭代中，我们传入 7： 1calc.next(7) 然后我们会得到： 1234&#123; done: false value: 14&#125; 第二个 next 方法带有参数 7，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 doubleThat 所在的表达式接收。 注意：你可能会认为 input / 2 是这个参数，但是它仅仅是第一次迭代的返回值，这次我们跳过了这一步，使用新的输入值 7 和 2 相乘。 我们继续第二次迭代，它返回了 doubleThat，值为 14。 下一个，最后一次迭代，我们传入100： 1calc.next(100) 返回： 1234&#123; done: true value: 14000&#125; 整个迭代结束（没有 yeild 关键字了），我们得到了 (input * doubleThat * another) 的值：10 * 14 * 100。 let 和 constvar 是传统的函数作用域。 let 是新的声明变量的方法，拥有块级作用域。这意味着在 for 循环中，if 语句内或者普通块中使用 let 声明的变量不会“逃出”所在的块，而 var变量则会被提升。 const 和 let 相似，但是不可更改。 展望 JavaScript 的发展，var 声明会逐渐消失，只剩下 let 和 const。 更特别的是，由于不可变的特性，const 在今天已经出人意料的被广泛使用。 类(Classes)传统上，JavaScript 是唯一一个基于原型继承的主流语言。从基于类的语言转向使用 JavaScript 的程序员会觉得困惑，但是 ES2015 引入了 classes，作为 JavaScript 内部运行的语法糖，它改变了我们编写 JavaScript 程序的方式。 现在，继承变得非常简单，和其他面向对象的编程语言类似： 123456789101112131415class Person &#123; constructor(name) &#123; this.name = name &#125; hello() &#123; return 'Hello, I am ' + this.name + '.' &#125;&#125;class Actor extends Person &#123; hello() &#123; return super.hello() + ' I am an actor.' &#125;&#125;var tomCruise = new Actor('Tom Cruise')tomCruise.hello() 上面的代码会打印出：“Hello, I am Tom Cruise. I am an actor.” Classes 没有显式声明类变量，你必须在构造函数（constructor）中初始化所有变量。 ConstructorClasses 拥有一个特殊的方法 constructor，在使用 new 实例化类时被调用。 Super可以使用 super() 引用父类。 Getters 和 Setters可以像这样声明一个 getter 属性： 12345class Person &#123; get fullName() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;` &#125;&#125; 用同样的方式声明 setter 属性： 12345class Person &#123; set age(years) &#123; this.theAge = years &#125;&#125; 模块化ES2015 之前，至少有三个主要的模块化标准，这分裂了整个社区： AMD RequireJS CommonJS ES2015 制定了统一的模块化标准。 导入模块通过 import ... from ... 导入模块： 1234import * from 'mymodule'import React from 'react'import &#123; React, Component &#125; from 'react'import React as MyLibrary from 'react' 导出模块你可以使用关键字 export 将编写的模块内容导出到其它模块里： 12export var foo = 2export function bar() &#123; /* ... */ &#125; 模板字符串模板字符串是创建字符串的新方法： 1const aString = `A string` 使用 ${a_variable} 语法可以方便地将表达式的值插到字符串里： 12const var = 'test'const string = `something $&#123;var&#125;` //something test 你还可以执行更复杂的表达式，像这样： 12const string = `something $&#123;1 + 2 + 3&#125;`const string2 = `something $&#123;foo() ? 'x' : 'y' &#125;` 字符串可以是多行的： 1234const string3 = `Heythisstringis awesome!` 对比一下 ES2015 之前的多行字符串的写法： 123var str = 'One\n' +'Two\n' +'Three' 默认参数函数现在支持使用默认参数值： 12const foo = function(index = 0, testing = true) &#123; /* ... */ &#125;foo() 扩展运算符你可以通过扩展运算符 ... 扩展数组，对象或者是字符串。 让我们用数组举个例子： 1const a = [1, 2, 3] 你可以这样创建一个新数组： 1const b = [...a, 4, 5, 6] 你可以复制一个数组： 1const c = [...a] 这对对象同样奏效，这样复制一个对象： 1const newObj = &#123; ...oldObj &#125; 对于字符串，扩展运算符会生成一个对应每个字符的数组： 12const hey = 'hey'const arrayized = [...hey] // ['h', 'e', 'y'] 这个运算符非常有用。最重要的就是可以以一种十分简单的方式为一个函数传递数组形式的参数： 123const f = (foo, bar) =&gt; &#123;&#125;const a = [1, 2]f(...a) 以前你可以使用 f.apply(null, a) 达到同样的效果，但是它可读性不太好。 解构赋值给定一个对象，你可以提取一些值并将赋值给别的变量： 1234567const person = &#123; firstName: 'Tom', lastName: 'Cruise', actor: true, age: 54, //made up&#125;const &#123;firstName: name, age&#125; = person name 和 age 包含这些值。 这个语法也可以用在数组中： 12const a = [1,2,3,4,5][first, second, , , fifth] = a 加强的对象字面量ES2015 中对象字面量更加强大。 声明变量的简单语法以前： 1234const something = 'y'const x = &#123; something: something&#125; 现在你可以： 1234const something = 'y'const x = &#123; something&#125; 原型可以像这样为变量指定原型： 1234const anObject = &#123; y: 'y' &#125;const x = &#123; __proto__: anObject&#125; super()12345678const anObject = &#123; y: 'y', test: () =&gt; 'zoo' &#125;const x = &#123; __proto__: anObject, test() &#123; return super.test() + 'x' &#125;&#125;x.test() //zoox 动态属性1234const x = &#123; ['a' + '_' + 'b']: 'z'&#125;x.a_b //z for-of 循环2009年的 ES5 引入了 forEach() 循环。虽然很好，但是不能像 for 那样中途跳出循环(比如使用 break 语句或使用 return 语句)。 ES2015 引入了 for-of 循环，结合了 forEach 的简洁和跳出循环的能力。 12345678//iterate over the valuefor (const v of ['a', 'b', 'c']) &#123; console.log(v);&#125;//get the index as well, using `entries()`for (const [i, v] of ['a', 'b', 'c'].entries()) &#123; console.log(i, v);&#125; Map 和 SetMap 和 Set（以及各自的弱引用类型 WeakMap 和 WeakSet）是官方实现的两种非常流行的数据结构（稍后介绍）。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（1）：ECMASCRIPT的发展史与现状]]></title>
    <url>%2F2019%2F03%2F10%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9AECMASCRIPT%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E4%B8%8E%E7%8E%B0%E7%8A%B6%2F</url>
    <content type="text"><![CDATA[每当你阅读有关JavaScript的内容时，你都会不可避免地看到以下这些术语： ES3 ES5 ES6 ES7 ES8 ES2015 ES2016 ES2017 ECMA2017 ECMA2016 ECMA2015 它们是什么意思？它们都是指一个名为ECMAScript的JavaScript标准。ECMAScript是JavaScript实现所基于的标准，通常被简称为ES。除了JavaScript，其他实现了ECMA标准的语言还包括： ActionScript（Flash 脚本语言），自从官方决定从 2020 年起不再维护 Flash 便不再流行。 JScript（微软实现的脚本语言），一开始只有 Netscape 支持 JavaScript，随着浏览器大战愈演愈烈，微软便实现了仅 IE 浏览器支持的版本。 但是毫无疑问，JavaScript是最为流行和使用最为广泛的ES实现。 为什么是这么一个奇怪的名字？Ecma International是瑞士标准协会，负责制定国际标准。 JavaScript 被创建后，它被 Netscape 和 Sun Microsystems 提交到 Ecma，Ecma将之命名为 ECMA-262，又叫做 ECMAScript。根据维基百科的解释，Netscapte 和 Sun Microsystems（Java 制造商）联合发布的新闻稿可能会帮助我们了解如此命名的原因，其中可能涉及到微软在该委员会中的法律和品牌问题。 IE9之后，微软停止在浏览器中将ES实现称为JScript，并开始将其称为JavaScript（至少，我再也找不到对JScript的引用了）。 所以，从201x年起，唯一一个支持 ECMAScript 标准的流行语言就只有 JavaScript 了。 ECMAScript最新版本ECMAScript最新版本是ES2018，即ES9，发布于2018年6月。 何时发布下一个版本？通常，JavaScript 会在每年夏天发布标准版本，所以我们可以在 2019 年夏天见到 ECMAScript 2019（即 ES2019 或者 ES10），但这一切只是推测。 何为TC39?TC39 是 JavaScript 发展委员会。 TC39 成员涉及 JavaScript 和浏览器供应商，包括火狐，谷歌，Facebook，Apple，微软，英特尔，PayPal，SalesForce 等等。 每一个标准版本的发布都必须通过不同阶段的提案。 ES版本我发现 ES 版本有时候通过版本号指代，有时候通过年份指代，这让人困惑。 在 ES2015 之前，ECMAScript 标准通常按照版本号命名，所以 ES5 是2009年更新的 ECMAScript 标准官方命名。 为什么会这样？在 ES2015 发布时，名字从 ES6 变成了 ES2015，但是为时已晚，人们仍然习惯性地称之为 ES6，社区也没有抛弃这个名字 - 大家仍然按照版本号的方式指代 ES 版本。 这个表格可以帮助理清思路： 版本 官方名称 发布日期 ES9 ES2018 2018年6月 ES8 ES2017 2017年6月 ES7 ES2016 2016年6月 ES6 ES2015 2015年6月 ES5.1 ES5.1 2011年6月 ES5 ES5 2009年12月 ES4 ES4 废弃 ES3 ES3 1999年12月 ES2 ES2 1998年6月 ES1 ES1 1997年6月 ES.Next 始终指 JavaScript 未来版本。在撰写本文时，ES9 已经发布，ES.Next 是 ES10。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vendor.js和app.js文件过大问题处理方案]]></title>
    <url>%2F2019%2F03%2F09%2Fvendor-js%E5%92%8Capp-js%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[背景webpack的出现，极大地简化了前端开发的复杂度：作为一种模块化的解决方案，它可以将项目当做一个整体，通过一个给定的主文件（如index.js）,进而从这个主文件中找到项目的所有依赖文件，使用loaders来处理它们，最后打包成浏览器可识别的JavaScript文件。 但是在实际的开发中，我们经常发现由于npm run build命令默认把dependencies中的依赖统一打包，导致打包后的vendor.js文件过大，出现首屏加载过于缓慢的问题，严重影响到了上线后的项目性能。如何处理它们呢？ 分析要解决这个问题，需要前后端一齐发力：后端做缓存，前端则需要做如下几项工作： A.去除不必要的插件，删除不必要的代码 B.分离业务代码和第三方库 C.按需加载 具体实施去除不必要的插件，删除不必要的代码比如babel-polyfill、vuex、less等（当然，我指的是当前还没有必要使用的情况。如果需要使用，自然不能删除），还有一些开发过程中用于测试的代码等等，这种是釜底抽薪式的解决方案——减少依赖，自然打包文件就变小了；删除无用代码，可以减少解析引擎的工作量。 开启gzip压缩开启gzip压缩，对打包优化有很大帮助。方法步骤如下： a.安装插件 compression-webpack-plugin 1npm install --save-dev compression-webpack-plugin b.设置config/index.js中productionGzip: true 1productionGzip: true 注意，此时如果compression-webpack-plugin版本过高，可能会压缩失败。解决方法是，安装1.1.12版本，同时将webpack.prod.conf.js中的asset字段名改为filename。 npm run build执行后会发现每个js和css文件会压缩一个gz后缀的文件夹，浏览器如果支持g-zip 会自动查找有没有gz文件，找到了就加载gz然后本地解压执行。 12345678910111213141516if (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; filename: '[path].gz[query]', // 将asset改为filename algorithm: 'gzip', test: new RegExp( '\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 &#125;) )&#125; 打包的时候不生成map文件webpack最终打包的文件中会出现一些map文件，map文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。有了map文件，就可以准确地输出错误信息。为了减小打包体积，我们可以设置不生成map文件： 设置config/index.js中productionSourceMap: false 分离vendorapp.js 包含了我们的第三方库 vue 和 axios ，以及业务代码 src ，我们可以将之分离开。 最简单方法就是：加一个 entry： 1234567// webpack.config.jsmodule.exports = &#123; entry: &#123; app: './src/main.js', vendor: ['vue', 'axios'], &#125;,&#125; 路由懒加载vue-router官网原文：当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 具体的方案如下： 原来的路由配置文件index.js 1import index from '@/components/home/index' 更改后的路由配置文件index.js 1const index = () =&gt; import('@/components/home/index') 做了路由懒加载后，我们可以看到app.js这个文件明显减小的同时多出了几个js文件，那是我们的另外几个路由页面的js文件。这些文件会在我们需要的时候，通过异步的方式加载进来，因此它们不会为首屏的加载增加负担。 组件懒加载组件懒加载的套路和路由懒加载是一样的，代码如下： 原来的组件引入方法 1import myHeader from '../header/myHeader' 更改后的组件引入方法 1const myheader = () =&gt; import('../header/myHeader') 此时，工程打包后我们可以看到app.js又变小了，同时又多出了几个js，这些js是自定义组件的js，我们可以用异步加载的方式加载进来的。 当然，组件懒加载有提升加载速度的一面，也有不总是“真香”的一面：如果网络慢，那么就有可能会出现白屏问题。这个时候就要做出判断了：哪些组件适合做懒加载，哪些不适合做懒加载。通常的建议如下： 对于路由页面，最好进行懒加载; 对于路由页面中的各个组件实行按需进行懒加载; 如果组件不大并且使用不多，可直接在路由页面中导入，若组件较大或者使用比较频繁，建议使用组件懒加载 使用CDN导入CDN的工作原理不多做介绍，个人认为使用CDN导入工具和库可以作为一种选项，但并不能保证100%的安全：谁知道这些服务会在什么时候突然挂掉呢，即使是那些号称最为稳定的服务？ 使用CDN导入的基本方法如下： a.在项目根目录index.html使用cdn节点导入 123456789&lt;div id="app"&gt;&lt;/div&gt;&lt;!-- 先引入 Vue --&gt;&lt;!--开发环境--&gt;&lt;script src="https://cdn.bootcss.com/vue/2.5.3/vue.js"&gt;&lt;/script&gt;&lt;!--生产环境--&gt;&lt;!--&lt;script src="https://cdn.bootcss.com/vue/2.5.3/vue.min.js"&gt;&lt;/script&gt;--&gt;&lt;!-- 引入组件库 --&gt;&lt;script src="https://cdn.bootcss.com/axios/0.17.1/axios.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/element-ui/1.4.10/index.js"&gt;&lt;/script&gt; b.项目根目录下build/webpack.base.config.js中添加externals 12345678// externals中的key是后面需要require的名字，value是第三方库暴露出来的方法名module.exports = &#123; externals: &#123; 'vue': 'Vue', 'axios': 'axios', 'element-ui': 'Element' &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目IE浏览器兼容性问题]]></title>
    <url>%2F2019%2F03%2F09%2Fvue%E9%A1%B9%E7%9B%AEIE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景介绍vue框架的核心思想——数据的双向绑定，是建立在从ES5才支持的对象方法Object.defineProperty()之上的，由此决定了vue天生不支持IE9以下浏览器，即针对IE浏览器版本，至少需要IE9浏览器才能正常运行vue项目。 通常来说，项目都需要对IE浏览器进行一定程度上的兼容，但同时即便是版本最高的IE11，也无法完全兼容ES6语法，更遑论IE9浏览器。在具体的项目实践中，笔者又发现，虽然vue核心组件都能正常支持IE9，但围绕vue生态圈打造的某些开发工具仍然无法100%支持IE9，再加上vue在IE9上低概率出现的诡异的组件变形问题，使得笔者最终决定将IE浏览器最低兼容到IE10。 技术选用幸运的是，JavaScript社区也在蓬勃发展，针对IE浏览器兼容这个开发痛点，不断地有人给出解决方案。接下来，笔者将列出解决IE浏览器兼容性问题需要使用到的相关技术。 A.babel-polyfill作用：将 es6 的代码翻译成低版本浏览器可以识别的 es5 代码； 安装：npm install –save babel-polyfill 使用： 在main.js最前面引入： 1import 'babel-polyfill'; 在webpack.base.conf.js中修改如下： 123entry: &#123; app:['babel-polyfill','./src/main.js'] &#125; 在 babel 配置文件.babelrc中修改如下： 作用是根据浏览器版本的支持，将 polyfill 需求拆分引入，仅引入有浏览器不支持的polyfill 1"useBuiltIns": "entry" B.header标签设置（非必须）作用： 强制ie浏览器以最新的edge引擎渲染页面，或自动激活双核浏览器的Chrome极速模式 使用： 在index.html的header标签中引入 1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; C.es6-promise作用：如果你用到了 axios对 promise进行兼容，可以只用 es6-promise 安装：npm install es6-promise –save 使用： 在main.js中加入如下内容： 12import promise from 'es6-promise'promise.polyfill() 具体实现 在index.vue中加入浏览器判断逻辑并执行该逻辑 123456789101112131415161718mounted () &#123; this.ieVersion()&#125;,methods: &#123; var userAgent = navigator.userAgent var isOpera = userAgent.indexOf('Opera') &gt; -1 var isIE = userAgent.indexOf('compatible') &gt; -1 &amp;&amp; userAgent.indexOf('MSIE') &gt; -1 &amp;&amp; !isOpera if (isIE) &#123; var reIE = new RegExp('MSIE (\\d+\\.\\d+);') reIE.test(userAgent) var fIEVersion = parseFloat(RegExp['$1']) if (fIEVersion &lt; 10) &#123; this.$alert('系统检测到您的IE浏览器版本过低，部分功能无法正常使用，推荐使用&lt;a style="color:#647eef" target="_blank" href="https://www.baidu.com/s?ie=UTF-8&amp;wd=Chrome"&gt;Chrome浏览器&lt;/a&gt;、&lt;a style="color:#647eef" target="_blank" href="https://www.baidu.com/s?ie=UTF-8&amp;wd=Firefox"&gt;Firefox浏览器&lt;/a&gt;或IE10及以上版本以获取最佳体验！', '温馨提示', &#123; dangerouslyUseHTMLString: true &#125;) &#125; &#125; &#125; 提升系统性能（关于性能问题，可另开一文详解）项目上线后，发现打包后的vendor.js和app.js体积过大，严重影响了系统的运行速度，为了解决这个问题，决定删除对babel-polyfill的依赖，使用MDN提供的poly-fill。 在index.html中引入对String对象的includes方法的es5版本实现(具体添加什么可视实际情况而定) 12345678910111213if (!String.prototype.includes) &#123; String.prototype.includes = function(search, start) &#123; 'use strict'; if (typeof start !== 'number') &#123; start = 0; &#125; if (start + search.length &gt; this.length) &#123; return false; &#125; else &#123; return this.indexOf(search, start) !== -1; &#125; &#125;; &#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用try...catch处理代码中的错误]]></title>
    <url>%2F2019%2F03%2F03%2F%E4%BD%BF%E7%94%A8try-catch%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[try…catch 语句是什么？try…catch 可以测试代码中的错误。try 部分包含需要运行的代码，而 catch 部分包含错误发生时运行的代码。 try…catch语法123456try &#123; //在此运行代码&#125;catch(err)&#123; //在此处理错误&#125; 运行流程：try{…}包含块中的代码有错误，则运行catch(err){…}内的代码，否则不运行catch(err){…}内的代码。 try…catch案例1234567var array = null;try &#123; document.write(array[0]);&#125; catch(err) &#123; document.writeln("Error name: " + err.name + ""); document.writeln("Error message: " + err.message);&#125; try…catch…finally 语句提供了一种方法来处理可能发生在给定代码块中的某些或全部错误，同时仍保持代码的运行。如果发生了程序员没有处理的错误，JS只给用户提供它的普通错误信息，就好象没有错误处理一样。 try…catch…finally语法123456789try &#123; tryStatements&#125; catch(exception)&#123; catchStatements&#125; finally &#123; finallyStatements&#125; 参数 tryStatement 必选项，可能发生错误的语句。 exception 必选项，任何变量名。exception的初始化值是扔出的错误的值。 catchStatement 可选项。处理在相关联的tryStatement中发生的错误的语句。 finallyStatements 可选项。在所有其他过程发生之后无条件执行的语句。 try…catch…finally案例12345678910var array = null;try &#123; document.write(array[0]);&#125; catch(err) &#123; document.writeln("Error name: " + err.name + ""); document.writeln("Error message: " + err.message);&#125;finally&#123; alert("object is null");&#125; 程序执行过程 array[0]的时候由于没有创建array数组,array是个空对象，程序中调用array[0]就会产生object is null的异常 catch(err)语句捕获到这个异常通过err.name打印了错误类型,err.message打印了错误的详细信息. finally类似于java的finally,无论有无异常都会执行. 现总结Error.name的六种值对应的信息 EvalError：eval()的使用与定义不一致 RangeError：数值越界 ReferenceError：非法或不能识别的引用数值 SyntaxError：发生语法解析错误 TypeError：操作数类型错误 URIError：URI处理函数使用不当 转自 https://www.jianshu.com/p/5874036e6710]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将vue-resource改为axios]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%B0%86vue-resource%E6%94%B9%E4%B8%BAaxios%2F</url>
    <content type="text"><![CDATA[背景接手的项目之前的http请求库用的是vue-resource,在一般使用过程中没有什么问题，但想要做ie浏览器兼容的时候却出现了很多意想不到的问题。其实vue-resource官方早已经停止维护，所以就想花点时间，改为使用官方推荐的axios库。 实施步骤安装axiosnpm安装就不多说了，需要注意的是在main.js里面需要添加一些配置： 123import axios from 'axios'axios.defaults.withCredentials = trueVue.prototype.$http = axios 使用axios完成axios的安装和配置之后，就可以在各组件内使用了。 因为我在vue-resource中使用了Vue.http.options.emulateJSON = true;，这种请求在发送头信息时会将Content-Type改为application/x-www-form-urlencoded。为了在使用axios时达到相同的效果，需要在组件内先引入qs 1234567import qs from 'qs'login () &#123; this.$http.post(process.env.BASE_URL + '/user/login', qs.stringify(this.login_data)).then(res =&gt; &#123; console.log(response.data) //这个打印出来的就是返回的结果 &#125;)&#125; post请求必须将发送的请求参数使用qs.stringify进行包裹，用以解决axios发送x-www-form-urlencoded的需求 qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接 同时需要注意，在vue-resource中正文是response.body，而在axios中正文则是response.data]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何获取访问者的ip地址并写入header]]></title>
    <url>%2F2019%2F01%2F20%2F%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%AE%BF%E9%97%AE%E8%80%85%E7%9A%84ip%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%86%99%E5%85%A5header%2F</url>
    <content type="text"><![CDATA[背景最近的一个项目，新增了一项需求：获取访问者的ip地址，并将ip地址写到header中，后端获取ip地址后写入日志进行记录。 由于js本身不具备获取访问者ip地址的能力，所以必须借助于第三方服务才能达到这个目的。网上查找了相关资料，最终确定使用搜狐的ip接口服务（http://pv.sohu.com/cityjson?ie=utf-8）。 解决方案使用该服务，首先遇到的就是跨域问题，vue项目中解决跨域问题的方法如下： config/index.js 123456789proxyTable: &#123; '/api': &#123; target: 'http://pv.sohu.com/', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125;&#125; 解决了跨域问题之后，就可以进行http拦截了： main.js 访问接口，获取ip地址后，进行拦截并写入header中 123456789101112131415161718Vue.http.get('/api/cityjson?ie=utf-8').then((res) =&gt; &#123; if (res) &#123; console.log(res.data) // 获取需要的ip地址 let ip = JSON.parse(res.data.replace('var returnCitySN = ', '').replace(';', '')).cip Vue.http.interceptors.push((request, next) =&gt; &#123; request.credentials = true // 将ip地址写入header中 request.headers.set('ip', ip) next((response) =&gt; &#123; if (response.body.code === '403') &#123; // delCookie('account') // router.push('/') &#125; &#125;) &#125;) &#125;&#125;) 后续：本地环境测试没有问题，但是部署上线的时候，该功能出现了问题：返回的数据变成了一个HTML文档（具体原因未知），所以也就无法再解析出IP地址。最后，还是通过后端埋点监控，拿到IP实现了功能。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发中遇到的杂七杂八问题记录]]></title>
    <url>%2F2019%2F01%2F13%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[html跳转，js不执行问题单页面复杂应用做多了，突然遇到简单的切图问题反而懵逼了，O(∩_∩)O。123456789&lt;header&gt; &lt;div class="clearfix fixwidth"&gt; &lt;div class="logo left"&gt; &lt;a href=""&gt; &lt;img src="img/logo.png" id="logoImg"/&gt; &lt;/a&gt; &lt;/div&gt; &lt;ul class="right nav-top"&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/header&gt; 总共有三个类似的页面，通过a链接跳转，js是这样的： 12345678910111213141516171819202122232425262728293031323334var obj = [ &#123; title: "首页", url: "index.html" &#125;, &#123; title: "新闻中心", url: "./news.html" &#125;, &#123; title: "联系我们", url: "./aboutUs.html" &#125;];var _html = "";for (var i = 0; i &lt; obj.length; i++) &#123; var aaa = '&lt;li class="item"&gt;&lt;a href="' + obj[i].url +'"&gt;' +obj[i].title + "&lt;/a&gt; &lt;span&gt;&lt;/span&gt;&lt;/li&gt;"; &#125; _html = _html + aaa; &#125;; $("header .nav-top").append(_html); $("header .nav-top").on("click",".item",function() &#123; var _index = $(this).index(); console.log(_index); //打印_index一闪而过 $(this) .addClass("active") .siblings(".item") .removeClass("active"); &#125;); 问题来了：想点击各个导航的时候添加样式，却无法添加（样式一闪而过），问题出在哪呢？ 原来是点击a标签跳转的时候，因为一瞬间已经跳转到另一个页面，所以跳转之前的那个页面的js就起不了想要的作用了。 最简单的处理方式，就是把导航写死，在对应的页面添加active类获取样式。 123456789101112&lt;header&gt; &lt;div class="clearfix fixwidth"&gt; &lt;div class="logo left"&gt; &lt;a href=""&gt; &lt;img src="img/logo.png" id="logoImg"/&gt; &lt;/a&gt; &lt;/div&gt; &lt;ul class="right nav-top"&gt; &lt;li class="item active"&gt;&lt;a href="index.html"&gt;首页&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li class="item"&gt;&lt;a href="./news.html"&gt;新闻中心&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li class="item"&gt;&lt;a href="./aboutUs.html"&gt;联系我们&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/header&gt; 新闻中心、联系我们与首页一样，在对应页面添加active类即可。 SSO单点登录从a系统通过点击链接进入b系统，b系统本身是需要通过登录系统进入的，但是a系统的请求URL中带的参数保证了a系统能够自动登录b系统。同时，a系统的用户在进入b系统后有权限控制，无法查看b系统的某些内容，此即单点登录（SSO）。 12345678910111213141516171819202122232425export default &#123; created() &#123; // 请求的URL中带有唯一的标识sign，故拿这个做判断 if (this.$route.fullPath.indexOf('sign') !== -1) &#123; this.$http.get(process.env.BASE_URL + '/user/userLogin?app_id=' + this.$route.query.app_id + '&amp;nonce_string=' + this.$route.query.nonce_string + '&amp;timestamp=' + this.$route.query.timestamp + '&amp;userCode=' + this.$route.query.userCode + '&amp;sign=' + this.$route.query.sign).then((response) =&gt; &#123; console.log(response) if (response.body.code === '200') &#123; // 成功返回 this.userAccount = response.body.data[0].account // 设置cookie值account用以登录，设置cookie值roleId用以判断角色 setCookie('account', this.userAccount) setCookie('roleId', response.body.data[0].roleId) this.isLoginShow = false this.$message(&#123; message: '您已进入某某系统，我们将记录您在本系统内的所有操作！', type: 'warning' &#125;) &#125; else &#123; // alert(response.body.message) this.$message.error(response.body.message) &#125; &#125;) &#125; &#125;&#125; 免密SSH，拉取代码有时候拿到代码仓库地址，无法拉取代码，即使是管理员添加了权限也不行。 解决方法：打开C盘的.ssh文件夹里的id_rsa.pub文件，将其中的公钥复制到gitlab里的ssh keys里面，点击add key。然后关闭sourcetree，重新打开即可获取。 sourcetree撤销推送有时候提交代码后又不想提交了，可以右键点击自己想要退回的最新版本，选择“重置当前分支到此次提交”，使用模式选择软合并或者混合合并都是安全的。此时，推送通知自动取消。 cookie的妙用背景接手的项目，使用vue+element做企业库系统。该系统遗留了一个bug:数据列表翻页的时候丢失查询参数。 123456789101112131415161718api (path, status) &#123; sessionStorage.setItem('pageName', path) this.changeLable(path) // 如果切换了路径修改成第一页开始 if (path !== this.path) &#123; this.pageNum = 1 &#125; this.path = path this.$http.get(process.env.BASE_URL + '/interfaces/interfaceLimit?pageNum=' + this.pageNum + '&amp;pageSize=' + this.pageSize + '&amp;status=' + status).then((response) =&gt; &#123; this.totalNum = response.body.dataCount this.dataList = response.body.dataList &#125;)&#125;,handleCurrentChange (val) &#123; this.pageNum = val this.api(this.path) sessionStorage.setItem('pageNum', val)&#125; 分析问题出在：在handleCurrent方法里的api方法没有传入对应的status参数。查阅了element文档，发现handleCurrentChange函数只能传一个val参数（不知道当时为啥没传）。那么api函数如何才能拿到status参数呢。思来想去，解决的方法就是在获取数据后，将status存到cookie中，然后再去拿。 12345678910111213141516171819202122api (path, status) &#123; sessionStorage.setItem('pageName', path) this.changeLable(path) // 如果切换了路径修改成第一页开始 if (path !== this.path) &#123; this.pageNum = 1 &#125; this.path = path this.$http.get(process.env.BASE_URL + '/interfaces/interfaceLimit?pageNum=' + this.pageNum + '&amp;pageSize=' + this.pageSize + '&amp;status=' + status).then((response) =&gt; &#123; this.totalNum = response.body.dataCount this.dataList = response.body.dataList // 将status存入cookie，方便后面handleCurrentChange方法里面的api函数去拿。 setCookie('status', response.body.status) &#125;)&#125;,handleCurrentChange (val) &#123; this.pageNum = val // 获取status，并当做参数传入api方法。 let status = getCookie('status') this.api(this.path, status) sessionStorage.setItem('pageNum', val)&#125;, 双波浪号JavaScript字符的使用~是二进制的按位取反,~~可以理解为是取整的简写 1234567891011~~null; // =&gt; 0~~undefined; // =&gt; 0~~0; // =&gt; 0~~&#123;&#125;; // =&gt; 0~~[]; // =&gt; 0~~(1/0); // =&gt; 0~~false; // =&gt; 0~~true; // =&gt; 1~~1.2543; // =&gt; 1~~4.9; // =&gt; 4~~(-2.999); // =&gt; -2 对于非数字（包括0）, ~ ~的结果为0,布尔的true是1；对于大于0的数, ~ ~相当于是Math.floor；对于小于0的数,~~相当于是Math.ceil ~~在性能上来说更快. IE浏览器低版本添加console对象1234567/* 防止低版本ie或者国产浏览器兼容模式在没有删除console调试代码时报错的问题。如果在打包前确保删除所有console调试代码，可删除本段代码。 */window.console = window.console || (function () &#123; const c = &#123;&#125; c.log = c.warn = c.debug = c.info = c.error = c.time = c.dir = c.profile = c.clear = c.exception = c.trace = c.assert = function () &#123;&#125; return c&#125;()) 回到浏览器顶部功能12345&lt;div id="extraTools"&gt; &lt;div id="back"&gt; &lt;a href="javascript:;" id="btn" class="el-icon-arrow-up"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819#extraTools &#123; position: fixed; width: 60px; height: 60px; right: 2%; bottom: 10%; z-index: 99; border-radius: 5px; background: rgba(184,186,188,0.5)&#125;#back a &#123; display: block; width: 60px; height: 60px; color:#fff; font-size: 28px; line-height: 60px; text-align: center;&#125; 12345678910111213141516171819202122232425window.onload = function()&#123; var btn = document.getElementById("btn") var timer = null var isTop = true window.onscroll = function()&#123; if(!isTop)&#123; clearInterval(timer) &#125; isTop = false &#125; //回到顶部按钮点击事件 btn.onclick = function()&#123; timer = setInterval( function()&#123; //获取滚动条的滚动高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop //用于设置速度差，产生缓动的效果 var speed = Math.floor(-scrollTop / 6) document.documentElement.scrollTop = document.body.scrollTop = scrollTop + speed isTop =true; if(scrollTop === 0)&#123; clearInterval(timer) &#125; &#125;,50 ) &#125;&#125; 循环添加节点12345var html = "";for(var i = 0;i&lt;data.data.length;i++) &#123; html += '&lt;div class="swiper-slide"&gt;&lt;img style="" src="'+data.data[i].picUrl+'" /&gt;&lt;/div&gt;'&#125;$('.swiper-wrapper').append(html) 通过变量控制追加节点的次数123456789101112var a = 0;var html = "";for(var i = 0 ;i&lt;data.data.length;i++) &#123; html = '&lt;div class="col-md-6 col-xs-6"&gt;' + '&lt;div class="caseDiv"&gt;' + '&lt;p class="casePi"&gt;'+data.data[i].summary+'&lt;/p&gt;'+ '&lt;a class="btn btn-default caseBtn" href="javascript:;" role="button" onclick="toDetail(\''+ id +'\')"&gt;查看更多&lt;/a&gt;' +'&lt;div class="mask img-rounded"&gt;&lt;/div&gt;' +'&lt;a href=""&gt;&lt;img src="'+data.data[i].picUrl+'" class="img-responsive img-rounded caseList-imgRounded"/&gt;&lt;/a&gt;' +'&lt;/div&gt;' +'&lt;h5&gt;&lt;a href="javascript:;" class="caseList-five"&gt;'+data.data[i].title+'&lt;/a&gt;&lt;/h5&gt;' +'&lt;/div&gt;' if (a&lt;3) &#123; //右侧 $('.newRow .rightnews').append(html) // 只显示3项内容 a++; &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>开发实践</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map和forEach的区别]]></title>
    <url>%2F2019%2F01%2F04%2Fmap%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[定义forEach(): 针对每一个元素执行提供的函数； map(): 创建一个新的数组，其中每一个元素由调用数组中的每一个元素执行提供的函数得来 到底有什么区别呢？forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。 示例下方提供了一个数组，如果我们想将其中的每一个元素翻倍，我们可以使用map和forEach来达到目的。 1let arr = [1, 2, 3, 4, 5]; forEach()注意，forEach是不会返回有意义的值的。我们在回调函数中直接修改arr的值。 123arr.forEach((num, index) =&gt; &#123; return arr[index] = num * 2;&#125;); // arr = [2, 4, 6, 8, 10] map123let doubled = arr.map(num =&gt; &#123; return num * 2;&#125;); // doubled = [2, 4, 6, 8, 10] 执行速度经测试，forEach()的执行速度比map()慢。 函数式角度的理解如果你习惯使用函数是编程，那么肯定喜欢使用map()。因为forEach()会改变原始的数组的值，而map()会返回一个全新的数组，原本的数组不受到影响。 哪个更好呢？取决于你想要做什么。 forEach适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。 12345678let arr = ['a', 'b', 'c', 'd'];arr.forEach((letter) =&gt; &#123; console.log(letter);&#125;);// a// b// c// d map()适用于你要改变数据值的时候。不仅仅在于它更快，而且返回一个新的数组。这样的优点在于你可以使用复合(map(), filter(), reduce()等组合使用)来玩出更多的花样。 12let arr = [1, 2, 3, 4, 5];let arr2 = arr.map(num =&gt; num * 2).filter(num =&gt; num &gt; 5); // arr2 = [6, 8, 10] 我们首先使用map将每一个元素乘以2，然后紧接着筛选出那些大于5的元素。最终结果赋值给arr2。 核心要点 能用forEach()做到的，map()同样可以。反过来也是如此。 map()会分配内存空间存储新数组并返回，forEach()不会返回数据。 forEach()允许callback更改原始数组的元素。map()返回新的数组。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call、apply、bind函数的用法]]></title>
    <url>%2F2018%2F12%2F05%2Fcall%E3%80%81apply%E3%80%81bind%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[call(),apply(),bind() 函数大家可能都有所了解，但是在平时搬砖过程中很可能或者基本没用过，学过但都淡忘了。 但是在大量第三方的框架(库)，甚至js自己都在源码中大量使用call,apply 函数。所以今天和大家仔细讨论下它们在开发中的应用场景。 它们是啥意思作用 他们的作用都是改变函数内部的this。 这三个函数都是函数对象的方法，也就是说只有函数才可以直接调用这些方法。 ps：call,apply,bind属于this显式绑定，还有好几种其他的this绑定方式，感兴趣的可以点这里。 三者区别参数：三个函数的第一个参数都是需要绑定的 this。call： 可以有n个参数，从第二个参数开始的所有参数都是原函数的参数。apply：只有两个参数，并且第二个参数必须为数组，数组中的所有元素一一对应原函数的参数。bind： 只有一个参数，即要绑定的this。 call 语法： foo.call(this, arg1,arg2, … ,argn );apply 语法： foo.apply(this, [ arg1,arg2, … ,argn ] );bind 语法： foo.bind(this); 调用call,apply： 调用后立即执行原函数。bind： 调用后返回已经绑定好this的函数。 小例子一枚： 1234567function foo(a,b)&#123; console.log(a+b);&#125;foo.call(null,&apos;海洋&apos;,&apos;饼干&apos;); // 海洋饼干 这里this指向不重要就写null了foo.apply(null, [&apos;海洋&apos;,&apos;饼干&apos;] ); // 海洋饼干var fun = foo.bind(null);fun(&apos;海洋&apos;,&apos;饼干&apos;); // 海洋饼干 它们能干啥事这是我们今天讨论的主题，这三个函数如何应用？什么情况下使用？能改变this指向又能咋滴？ 处理伪数组 (最常用)先考虑一个问题，如果你使用var arr = document.getElementsByTagName(&#39;li&#39;)获取了5个li元素，你现在需要获取其中的第2,3,4三个元素，你会怎么做？ 这样arr.slice(1,4);？ 啊哦，TypeError -- arr.slice is not a function(slice不是函数)，数组操作在日常搬砖中非常常见，我见过最傻的解决这个问题的方式是使用循环，将需要的元素一个个添加到一个新数组里，下面我介绍的方法完全可以在实战中使用，可以给你的代码加分哦,非常方便简洁(中高级前端程序员中，算是基本操作了)。 先要介绍一个概念( 伪数组 )，这也是为什么我们刚刚slice切割数组时出错的原因： (对新手来说算是干货了，知道的可以跳过) 什么是伪数组？ 有length属性 能按索引存储数据 能像遍历数组一样来遍历 不能使用数组的push()、slice()等方法 简单来说就是可以像数组一样操作的对象，但是没有数组的方法。 js中存在大量伪数组，如 ： function的arguments对象;getElementsByName(),getElementsByTagName(),childNodes/children 等方法的返回值;还有比较常见的jquery,使用它获取的元素也是伪数组 回到原来的问题，如何截取伪数组中的元素：伪数组没有这些方法，我们’借用’Array的slice不就行了 1[].slice.call(arr,1,4); // 推荐写法 不想借用你可以直接给伪数组添加一个slice函数，如 12arr.slice = [].slice;arr.slice(1,4); 当然，’借用’ 更方便，直接添加会导致伪数组对象’污染’。 如果可以随意改变原对象，可以 直接将其转成真正的数组对象。 1[].slice.call(arr); 继承继承方式多种多样,我们现在讨论的这种是其中很重要的一种实现方式，用call实现 js 构造函数继承 。 单继承12345678910function person(name)&#123; this.name = name&#125;function man(name)&#123; this.age = &apos;男&apos;; person.call(this,name); // 继承 man&#125;var me = new man(&apos;海洋饼干&apos;);console.log(me.name,me.age); // &apos;海洋饼干&apos; &apos;男&apos; 多继承1234567891011121314function person(name)&#123; this.name = name&#125;function man(name)&#123; this.age = &apos;男&apos;;&#125;function manProgrammer(name)&#123; this.girlfriend = null; person.call(this,name); // 继承 person man.call(this,name); // 继承 man&#125;var me = new manProgrammer(&apos;海洋饼干&apos;);console.log(me.name,me.age,me.girlfriend); // &apos;海洋饼干&apos; &apos;男&apos; null this硬绑定 —bind将一个对象强制且永久性绑定到函数的this上，使用call,apply或者其他的绑定方式都无法改变(除了new绑定，当然，可以手动撸一个new都无法改变的硬绑定) 直接看例子： 1234567891011121314151617var fun ;var obj = &#123; a : 1, foo : function()&#123; var _this = this; //平时有没有过这种写法？ 为了防止this指向问题 //将this赋值给一个变量,间接维持了this的安全性 fun = function()&#123; console.log(_this.a); &#125; &#125;&#125;obj.foo();fun(); // 1var obj1 = &#123; a : 2&#125;obj.foo.call(obj1); // 直接修改_this所绑定的值,boom了fun(); // 2 但是这种方法感觉上是在逃避问题，直接不使用this了 ? 这真的不是什么好的解决问题的态度。下面使用我们的bind来优化一下： 1234567891011121314var fun ;var obj = &#123; a : 1, foo : function()&#123; // 不使用 _this， 避免无谓的变量声明 fun = function()&#123; console.log(this.a); &#125;.bind(this); // 代码很简洁,很漂亮（b格） &#125;&#125;var obj1 = &#123; a : 2&#125;obj.foo();fun(); // 1fun.call(obj1); // 1 call ,apply等绑定 无法修改 // 这里和上面call的位置不同是因为this所处于不同的位置 这样替代 _this 很规(zhuang)范(b)呢 ps：call,apply,bing属于this显示绑定，还有好几种其他的this绑定方式，感兴趣的可以点这里。 取数组最大最小值Math.max和min方法，接收多个参数，比较出极值，这里用到apply的一个默认功能：展开数组，传入一个数组参数就可以默认将这个数组转成一个个参数的形式赋给原函数 123var num = [6,9,-3,-5];console.log(Math.max.apply(Math,num)); // 9 等价 console.log(Math.max(6,9,-3,-5));console.log(Math.min.apply(Math,num)); // -5 等价 console.log(Math.min(6,9,-3,-5)); 合并数组合并数组常见有三种方式，1.循环 2.Array的concat() 3. 使用apply()合并 这里是使用最简便的apply: 1234var a = [1,2,3];var b = [4,5,6];[].push.apply(a,b); // 借用数组的push方法 等价 a.push(4,5,6);console.log(a); // [1, 2, 3, 4, 5, 6] 转自https://segmentfault.com/a/1190000011389726]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册]]></title>
    <url>%2F2018%2F12%2F03%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[注：本文为译文。其实网上关于该篇文章已经有了不少翻译版本，但大多都让人不太满意（有不少词不达意和不够精炼、通俗易懂的地方），所以试着自己翻译一遍，算是用来巩固和提高自己的JavaScript水平吧！ 文章会根据目录，形成一个JavaScript系列。 原文地址：freeCodeCamp（可能需要梯子） JavaScript 完整手册JavaScript 是世界上最流行的编程语言之一，现在也广泛用于浏览器之外的其他地方。近几年，Node.js 的崛起打破了长期以来被 Java, Ruby, Python, PHP 等传统服务端语言统治的后端开发领域。 这本 JavaScript 完整手册遵循二八定律（the 80/20 rule）：在 20% 的时间里学习80% 的 JavaScript 知识。 快来学习你需要知道的有关JavaScript的所有知识吧！ 目录 ECMASCRIPT的发展史与现状 ES6带来的重大特性 ES2016(ES7)新增特性 ES2017(ES8)新增特性 ES2018(ES9)新增特性 编码风格 词法结构 变量 数据类型 表达式 原型继承 JavaScript中的Classes(类) 异常处理 在JavaScript中使用分号(;) 在JavaScript中使用引号(“”) ES6模板字面量 函数 ES6箭头函数 闭包 数组 循环 事件(Events) 事件循环(The Event Loop) 异步编程与回调 Promises Async和Await 循环和作用域(Loops and Scope) 定时器(Timers) JavaScript中的This 严格模式(Strict Mode) 立即执行的函数表达式(IIFE) 数学运算符 Math对象 ES模块 CommonJs介绍 JavaScript术语表 JavaScript介绍JavaScript是世界上最流行的编程语言之一，自20年前诞生以来，已经走过了很长的一段路。JavaScript被限定为第一个而且是唯一一个由web浏览器原生支持的脚本语言。 一开始，JavaScript并没有现在那么强大的功能，它主要用来制作花哨的动画和当时被广泛称奇的动态HTML(DHTML)。 随着web平台需求的不断增长，为了满足这个世界上使用最为广泛的生态系统之一的需求，JavaScript也在不断地发展。 web平台引入了很多东西，包括浏览器API,但JavaScript语言本身也得到了长足的发展。 现在，JavaScript也广泛应用于浏览器之外的场景。过去几年，Node.js 的崛起解锁了长期以来被 Java, Ruby, Python, PHP 等传统服务端语言统治的后端开发领域。 现代JavaScript也可以操作数据库和开发应用程序，甚至可以开发嵌入式程序、移动APP、电视应用程序等等。曾经只局限于web开发的小语言，现在已经成长为世界上最为流行的开发语言了。 JavaScript基本定义JavaScript是这样一种编程语言： 高级语言：它提供的抽象方法允许你忽略当前运行它的机器的详细信息。JavaScript 通过垃圾回收器自动管理内存，让你可以更专注代码而不是管理内存，它也提供了很多构造函数让你更好地处理变量和对象。 动态语言：和静态语言在编译后执行相反，动态语言在运行时就会执行。这有利有弊，JavaScript 给我们提供了强大的功能，比如：动态类型，延迟绑定，反射，函数式编程，对象运行时变更（object runtime alteration），闭包等等。 动态类型：变量不用定义类型。你可以为变量重新绑定任何类型，比如给一个已声明过的字符串变量绑定一个整型值。 弱类型：与强类型相反，弱(或松散)类型语言不强制要求设定对象的类型。这使得操作更加灵活的同时，也使得我们无法进行类型检查以确保类型安全（这也是TypeScript 和 Flow 旨在改善的问题）。 解释型：JavaScript 通常被认为是一种解释型语言，这意味着在程序运行前不需要先编译，这恰恰与 C 语言，Java 或者 Go 语言相反。事实上，出于性能考虑浏览器会在执行 JavaScript 之前进行编译，但是这一切都是自然而然发生的，不需要我们进行额外的操作。 多范型：JavaScript 不强制使用任何固定的编程范式，不像 Java 强制面向对象编程或者是 C 语言强制命令式编程。在 JavaScript 中，你可以使用原型和 ES6 中提供的 classes 语法面向对象编程，你也可以通过它的头等函数（first-class functions）编写函数式编程风格的代码，甚至可以像C语言那样进行命令式编程。 多说一句，JavaScript 和 Java的关系，正如雷锋和雷峰塔的关系，两者没有任何关系。这是一个不幸的命名选择，但是我们不得不接受这个现实。 JavaScript版本让我介绍一下 ECMAScript这个术语。我们有一个专门介绍 ECMAScript 的完整指南，你可以在那里深入了解它，但现在，你只需要知道 ECMAScript（也被称作 ES）是 JavaScript 标准的名字。JavaScript 是对 ECMAScript 标准的一种实现，这也是为什么你会听到 ES6, ES2015, ES2016, ES2017, ES2018 等等。 很长一段时间内，所有浏览器中运行的 JavaScript 版本都是ECMAScipt 3。版本 4 因为语言特征实现周期太长被取消了（他们试图一次性添加很多特性）。虽然 ES5 是 JavaScript 的一个巨大的改进版本，但是 ES2015（也被称作 ES6）同样也是 JavaScript 的重要更新。 从那时起，标准制定委员会决定每年更新一个版本，避免版本迭代间隔太久，同时也能加快反馈速度。 现在，最新批准的 JavaScript 版本是 ES2017（译注：最新版本已经是ES2019）。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中for...in循环与for...of循环的执行效率和使用]]></title>
    <url>%2F2018%2F11%2F30%2Fjavascript%E4%B8%ADfor-in%E5%BE%AA%E7%8E%AF%E4%B8%8Efor-of%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[for…in性能这么慢,因为它要遍历自身的属性和原型链上的属性,这无疑就增加了所有不必要的额外开销. 对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名。 1234567891011121314151617let es6 = &#123; edition: 6, committee: "TC39", standard: "ECMA-262"&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// TypeError: es6[Symbol.iterator] is not a function 上面代码表示，对于普通的对象，for…in循环可以遍历键名，for…of循环会报错。 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125; 经验就是：鉴于for of 循环比for in循环要快，在有性能需要的情况下，可以考虑将for in 循环更改成for of 循环，前提是使用Object.keys()将对象循环转为对数组进行循环。 参考：http://es6.ruanyifeng.com/#docs/iterator]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改hosts文件的作用与方法]]></title>
    <url>%2F2018%2F11%2F30%2F%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是hosts文件？hosts是一个没有扩展名的系统文件，其基本作用就是将一些常用的网址域名与其对应的 IP 地址建立一个关联“ 数据库 ”。当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从hosts文件中寻找对应的 IP 地址，一旦找到，系统就会立即打开对应网页，如果没有找到，则系统会将网址提交 DNS 域名解析服务器进行 IP 地址的解析。 hosts文件的作用加快域名解析对于经常访问的网站，咱们可以通过在hosts文件中配置域名和 IP 的映射关系，提高域名的解析速度。由于有了映射关系，当咱们输入域名后，计算机就能够快速解析出 IP 地址，而不用请求网络上的 DNS 服务器。 构建映射关系在很多单位中，都会有自己局域网，而且还会有不同的服务器提供给公司的成员使用。但由于局域网中一般很少架设 DNS 服务器，因此在访问这些服务器时，就需要输入难记的 IP 地址，这对大家来说相当麻烦。因此，咱们可以分别给这些服务器取个容易记住的名字，然后在hosts文件中建立 IP 映射，这样在以后访问的时候，只要输入这个服务器的名字就 OK 啦！ 屏蔽垃圾网站现在有很多网站，在不经过咱们同意的时候，就将各种各样的插件安装到咱们的计算机中，其中不乏病毒和木马。对于这些网站，咱们就可以利用hosts文件把这些网站的域名映射到一个错误的 IP 或本地计算机的 IP 地址上，这样就可以达到禁止访问的目的啦！ 修改hosts文件的方法由于 hosts 文件属性系统文件，因此需要管理员权限才能对其进行修改。 第一种方法：先将权限修改成管理员权限，然后在对其进行修改。第二种方法：先将hosts文件复制到桌面，这时就不需要管理员权限了，因此可以对其进行修改了，等修改之后，在将其拖回原目录，替换就可以啦！在 iOS 系统中中，hosts文件的位置为：~/private/etc 在 Windows 系统中，hosts文件的位置为：C:\Windows\System32\drivers\etc hosts文件修改示例： 202.108.22.5 www.baidu.com 如上所示，咱们在本地的hosts文件中，将百度的 IP 地址与百度的域名建立了映射关系，也就起到了“加快域名解析”的作用，因为不需要再去请求 DNS 服务器啦！此外，如果咱们想要对其进行注释的话，直接在前面加#符号就可以，例如： #202.108.22.5 www.baidu.com]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>开发实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue开发小知识点整理]]></title>
    <url>%2F2018%2F11%2F30%2Fvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇用于总结vue日常开发中会用到，但是经常踩坑或闹不太清楚的知识点，持续更新。 vue中template标签嵌套的作用123456789&lt;template&gt; &lt;div class=&quot;mainedit&quot;&gt; &lt;template v-if=&quot;renderStatus&gt;=0 &amp;&amp; renderStatus&lt;8&quot;&gt; &lt;em&gt;&#123;&#123;renderMsg&#125;&#125;&lt;strong class=&quot;dotting&quot;&gt;&lt;/strong&gt;&lt;/em&gt; &lt;span&gt;&lt;ins :style=&quot;&#123;width:percent&#125;&quot;&gt;&lt;/ins&gt;&lt;/span&gt; &lt;b v-html=&quot;percent&quot;&gt;&lt;/b&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt; template不会渲染成元素，用div的话会被渲染成元素。把if,show,for等语句抽取出来放在template上面，把绑定的事件放在temlpate里面的元素上，可以使html结构更加清晰，还可以改善一个标签过长的情况。 一个具体的跨组件tab切换功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;rightpart&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a @click=&quot;changeTab(1)&quot; :class=&quot;tabIndex==1?&apos;on&apos;:&apos;&apos;&quot;&gt; &lt;i class=&quot;fa fa-picture-o&quot;&gt;&lt;/i&gt; &lt;span&gt;图片&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a @click=&quot;changeTab(2)&quot; :class=&quot;tabIndex==2?&apos;on&apos;:&apos;&apos;&quot;&gt; &lt;i class=&quot;fa fa-music&quot;&gt;&lt;/i&gt; &lt;span&gt;音乐&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;keep-alive&gt; &lt;div class=&quot;funcwrap&quot; :class=&quot;&#123;&apos;closed&apos;:!isShow&#125;&quot;&gt; &lt;picfunc v-if=&quot;tabIndex == 1&quot;&gt;&lt;/picfunc&gt; &lt;musicfunc v-if=&quot;tabIndex == 2&quot;&gt;&lt;/musicfunc&gt; &lt;/div&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import picfunc from &quot;./right/PicFunc&quot;; import musicfunc from &quot;./right/MusicFunc&quot;; import &#123;mapState&#125; from &quot;vuex&quot;; export default &#123; computed: &#123; ...mapState([&quot;tabIndex&quot;]) &#125;, components: &#123; picfunc, musicfunc &#125;, methods:&#123; //更新打开窗口 changeTab(tab) &#123; var params = &#123;&#125;; params.index = tab; this.$store.dispatch(&quot;changeTab&quot;, params); &#125;, &#125; &#125;&lt;/script&gt; vuex相关 1234567891011121314151617181920212223//index.jsconst state = &#123; tabIndex: -1&#125;//mutation-types.jsexport const CHANGETAB= 'CHANGETAB'//mutations.jsimport &#123;CHANGETAB&#125; from './mutation-types.js'export default &#123; [CHANGETAB](state, params) &#123; state.tabIndex = params.index; &#125;&#125;//actions.jsimport &#123;CHANGETAB&#125; from './mutation-types.js'export default &#123; changeTab(&#123;commit&#125;, params) &#123; commit(CHANGETAB, params) &#125;&#125; 如何在vue项目中刷新当前页面背景在最近接手的一个项目中，遗留了一个bug：系统登录后，在首页登录名无法渲染出来，但是跳转到其他页面的时候，登录名就能渲染出来了。查看代码之后，觉得应该是子组件传值不成功导致的。但是因为任务比较紧急，所以决定先采用刷新当前页面的方式来解决这个问题。 那么问题来了，vue项目如何刷新当前页面呢？ 通过provide/inject组合注入reload方法实现刷新通过查询资料，找到了一种比较靠谱的方式：通过provide / inject 组合，注入reload方法。 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view v-wechat-title=&quot;$route.meta.title&quot; v-if = &quot;isRouterAlive&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;App&apos;, provide () &#123; return &#123; reload: this.reload &#125; &#125;, data () &#123; return &#123; isRouterAlive: true &#125; &#125;, methods: &#123; reload () &#123; this.isRouterAlive = false this.$nextTick(function () &#123; this.isRouterAlive = true &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在app.vue中通过声明reload方法，控制router-view的显示与隐藏，从而控制页面的再次加载。 这里定义了一个isRouterAlive来控制显示与隐藏。 然后，在当前需要刷新的页面中注入app.vue中提供的reload依赖，然后直接调用this.reload就行。 123456789export default &#123; name: 'login', inject: ['reload'], methods: &#123; login () &#123; this.reload() &#125; &#125;&#125; 通过限制v-for循环次数，来达到只渲染一部分数据的目的背景用vue结合element做项目的时候，有一项需求是这样的：只显示表格的第一项，其余项加上第一项通过点击“更多”按钮，以弹窗的形式展示。 限制v-for循环次数那么，该如何初始化页面的时候只显示第一行数据呢。方法就是限制v-for循环的次数，只显示第一项数据。 限制v-for循环次数的两种方法： 1.截取循环的数据 123&gt; v-for="(item,index) in changeInfo.slice(0, 2)"&gt; //用这样的方法可以截取循环的数据长度，从而控制循环的次数&gt; 2.通过v-if来控制 123&gt; v-for="(item,index) in changeInfo" v-if="index&lt;3"&gt; //在标签下紧跟v-if来进行控制，这里是用索引来进行控制的，所以循环的时候记得把index这个参数加到v-for循环中。&gt; 1234567891011121314151617181920212223242526272829303132&lt;table class=&quot;table1&quot; v-if=&quot;!isQueryRegistChange&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;日期&lt;/td&gt; &lt;td&gt;变更项&lt;/td&gt; &lt;td&gt;变更前&lt;/td&gt; &lt;td&gt;变更后&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(item,index,key) in changeInfo&quot; :key=&quot;key&quot; v-if=&quot;index&lt;1&quot;&gt; &lt;td style=&quot;width:30px&quot;&gt;&#123;&#123;index+1&#125;&#125;&lt;/td&gt; &lt;td style=&quot;width:80px&quot;&gt;&#123;&#123;item.time&#125;&#125;&lt;/td&gt; &lt;td style=&quot;width:80px&quot;&gt;&#123;&#123;item.changeScope&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.beforeContent&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.afterContent&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;el-row style=&quot;position:absolute;right:50px&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogTableVisible = true&quot; &gt;更多&lt;/el-button&gt; &lt;/el-row&gt;&lt;/table&gt; &lt;el-dialog title=&quot;变更信息&quot; :visible.sync=&quot;dialogTableVisible&quot;&gt; &lt;el-table :data=&quot;changeInfo&quot;&gt; &lt;el-table-column type=&quot;index&quot; label=&quot;序号&quot; width=&quot;60&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column property=&quot;time&quot; label=&quot;日期&quot; width=&quot;100&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column property=&quot;changeScope&quot; label=&quot;变更项&quot; width=&quot;100&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column property=&quot;beforeContent&quot; label=&quot;变更前&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column property=&quot;afterContent&quot; label=&quot;变更后&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-dialog&gt; v-if=”index&lt;1” 只循环一次，此时页面只会显示第一条数据 index+1：用来从1开始显示表格序号 label=”序号”：用来将element的表格的序号表头由#变成汉字 vue相同路由跳转强制刷新该路由组件背景在开发过程中可能会遇到这种情况：在vue路由不改变的情况下，再次发请求刷新对应组件会失败，原因正是vue-router不支持这样做。那么，如何解决这个问题呢？ 解决方案第一步，在该路由跳转上绑定一个随机的query参数，例如时间戳或者随机数： 1this.$router.replace(&#123;name: 'customIndex', params: &#123;searchParam: this.searchParam&#125;, query: &#123;t: Date.now()&#125;&#125;) 该操作可以触发路由的改变，但是组件内的状态没有被初始化，因为组件并没有被创建 第二步，在路由容器上绑定key值： 1&lt;router-view :key="$route.query.t"/&gt; 通过key值的变化即可强制刷新该组件 vue键盘事件直接绑定失效背景最近项目里添加一个新功能：给登录按钮绑定键盘enter事件。本以为这是个非常容易的功能，但真正做的时候还是稍微花了点时间。 将@keyup.enter.native直接绑定在button上不行，因为必须先点击一次获取焦点后按enter才能触发键盘事件，但问题是此时已经登录成功了，再触发键盘事件已没有意义： 123&lt;el-input placeholder=&quot;请输入企业名称、人名，产品名等&quot;&gt; &lt;el-button slot=&quot;append&quot; type=&quot;primary&quot; @click=&quot;search()&quot; @keyup.enter.native=&quot;search&quot; icon=&quot;el-icon-search&quot; &gt;&lt;/el-button&gt;&lt;/el-input&gt; 解决方案1234567891011created () &#123; var that = this document.onkeydown = function () &#123; var key = window.event.keyCode if (key === 13) &#123; if (!getCookie('account')) &#123; that.login() &#125; &#125; &#125;&#125; 不能直接将事件添加写在button上，因为这样必须焦点在button上才能触发，所以可以直接绑定在document上即可。 对象嵌套过深，导致undefined问题代码如下： 1234567891011&lt;el-row :gutter=&quot;20&quot; v-if=&quot;basicInfo.tags.length === 0&quot;&gt; &lt;el-col :span=&quot;2&quot;&gt;标签：无&lt;/el-col&gt;&lt;/el-row&gt;&lt;el-row :gutter=&quot;20&quot; v-else&gt; &lt;el-col :span=&quot;2&quot;&gt;标签：&lt;/el-col&gt; &lt;el-col :span=&quot;18&quot;&gt; &lt;span :title=&quot;item.tagName&quot; v-for=&quot;(item,index,key) in basicInfo.tags&quot; :key=&quot;key&quot;&gt; &#123;&#123;item.tagName | filterTags&#125;&#125; &lt;/span&gt; &lt;/el-col&gt; &lt;/el-row&gt; 1234567891011121314151617181920 data () &#123; return &#123; basicInfo: &#123;&#125; &#125;, methods: &#123;fullBasicInfo: function () &#123; this.$http .post( process.env.BASE_URL + '/company/companySearchDetail', qs.stringify(&#123;key: localStorage.getItem('creditCode')&#125;) ) .then(response =&gt; &#123; if (response.data.data == null) &#123; this.isCompanySearchDetail = true &#125; else &#123; this.basicInfo = response.data.data &#125; &#125;)&#125; &#125; 显示标签功能本身没有问题，但是会报错： Cannot read property ‘length’ of undefined. 经过检查，发现像tagsLength.length这样的只有两层的属性可以正常渲染而不报错，也就是说，因为basicInfo对象没有定义tags属性，所以找不到length。 故修改如下： 1234567891011&lt;el-row :gutter=&quot;20&quot; v-if=&quot;tagsLength.length === 0&quot;&gt; &lt;el-col :span=&quot;2&quot;&gt;标签：无&lt;/el-col&gt;&lt;/el-row&gt;&lt;el-row :gutter=&quot;20&quot; v-else&gt; &lt;el-col :span=&quot;2&quot;&gt;标签：&lt;/el-col&gt; &lt;el-col :span=&quot;18&quot;&gt; &lt;span :title=&quot;item.tagName&quot; v-for=&quot;(item,index,key) in basicInfo.tags&quot; :key=&quot;key&quot;&gt; &#123;&#123;item.tagName | filterTags&#125;&#125; &lt;/span&gt; &lt;/el-col&gt; &lt;/el-row&gt; 12345678910111213141516171819202122 data () &#123; return &#123; basicInfo: &#123;&#125;， tagsLength: 0 &#125;, methods: &#123;fullBasicInfo: function () &#123; this.$http .post( process.env.BASE_URL + '/company/companySearchDetail', qs.stringify(&#123;key: localStorage.getItem('creditCode')&#125;) ) .then(response =&gt; &#123; if (response.data.data == null) &#123; this.isCompanySearchDetail = true &#125; else &#123; this.basicInfo = response.data.data this.tagsLength = this.basicInfo.tags &#125; &#125;)&#125; &#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview组件库实现自定义modal]]></title>
    <url>%2F2018%2F11%2F24%2Fiview%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89modal%2F</url>
    <content type="text"><![CDATA[最近业务中有这样一项需求：使用iview组件库实现一个自定义的modal。查了下iview官方文档，并没有这方面的详细说明，举的例子也不能够满足需要，于是就开始自己试着去实现。 实现效果 Modal.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;Row&gt; &lt;Form :rules=&quot;ruleValidate&quot; :model=&quot;formValidate&quot;&gt; &lt;FormItem label=&quot;标题：&quot; prop=&quot;tit&quot;&gt; &lt;Input v-model=&quot;formValidate.tit&quot; placeholder=&quot;请输入标题&quot; @on-change=&quot;titChange&quot;&gt;&lt;/Input&gt; &lt;/FormItem&gt; &lt;FormItem label=&quot;描述：&quot; prop=&quot;des&quot;&gt; &lt;Input v-model=&quot;formValidate.des&quot; placeholder=&quot;请输入描述&quot; type=&quot;textarea&quot; :autosize=&quot;&#123;minRows: 2,maxRows: 5&#125;&quot; @on-change=&quot;desChange&quot;&gt;&lt;/Input&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;/Row&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;Modal&apos;, data() &#123; return &#123; formValidate:&#123; tit:&apos;&apos;, des:&apos;&apos; &#125;, ruleValidate:&#123; tit:[ &#123;required: true, message: &apos;标题不能为空&apos;, trigger: &apos;blur&apos;&#125;, &#123;type: &apos;string&apos;, max: 3, message: &apos;最多可填三个字&apos;,trigger: &apos;blur&apos;&#125; ], des:[ &#123; required: true, message: &apos;描述不能为空&apos;, trigger: &apos;blur&apos; &#125;, &#123; type: &apos;string&apos;, min: 10, message: &apos;请填入至少十个字&apos;, trigger: &apos;blur&apos; &#125; ] &#125; &#125; &#125;, methods:&#123; // 将表单填入的数据传给RightPart.vue titChange:function() &#123; this.$emit(&apos;tit&apos;, this.formValidate.tit) &#125;, desChange:function() &#123; this.$emit(&apos;des&apos;, this.formValidate.des) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; RightPart.vue 点击a标签，弹出modal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;template&gt; &lt;div class=&quot;rightpart&quot;&gt; &lt;div class=&quot;temp&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in storyList&quot;&gt; &lt;p&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;a class=&quot;deleteitem&quot;&gt; &lt;Icon type=&quot;ios-close-circle-outline&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a @click=&quot;addStory()&quot;&gt;+&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import modal from &apos;./Modal&apos;; export default &#123; name: &quot;rightpart&quot;, components: &#123; modal &#125;, data() &#123; return &#123; title:&apos;&apos;, description:&apos;&apos;, storyList:[] &#125;; &#125;, methods: &#123; addStory() &#123; this.$Modal.confirm(&#123; title:&apos;创建故事&apos;, render: (h) =&gt; &#123; return h(modal, &#123; props: &#123; //若父组件有需要传递给内容组件的参数，需要在props中填入 &#125;, on: &#123; tit: (tit) =&gt; &#123; this.title = tit &#125;, des: (des) =&gt; &#123; this.description = des &#125; &#125; &#125;) &#125;, onOk: () =&gt; &#123; // 获取组件Modal传过来的值 var modalInfo = &#123; title: this.title, description:this.description &#125; this.storyList.push(modalInfo); &#125; &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>iview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuejs数据绑定更新视图与传统dom操作比较]]></title>
    <url>%2F2018%2F11%2F24%2Fvuejs%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%BC%A0%E7%BB%9Fdom%E6%93%8D%E4%BD%9C%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[前几天写代码的时候突发奇想，想试试同一个功能先用vue来实现一次，再使用传统dom操作来实现一次。功能很简单，但实际操作一次，也能让我对MVVM思想和传统dom操作思想有一个感官的比较和认识。 SubComp.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div @click=&quot;transforData(subtemplate)&quot;&gt; &lt;img :src=&quot;ALIOSS_DOMAIN + &apos;template/&apos; + subtemplate.path + &apos;/&apos; + subtemplate.thumb&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &quot;../bus/eventBus.js&quot;;export default &#123; methods: &#123; transforData(obj) &#123; eventBus.$emit(&apos;transforData&apos;,&#123; title:obj.title, path:obj.path, thumb:obj.thumb &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Story.vue 传统dom操作 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;tabcont&quot;&gt; &lt;ul ref=&quot;storyItem&quot;&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &quot;../bus/eventBus.js&quot;;export default &#123; created() &#123; //获取subcomp传过来的数据并进行处理 eventBus.$on(&quot;transforData&quot;,function(obj)&#123; var li = document.createElement(&quot;li&quot;); li.innerHtml = &quot;&lt;img src=&quot;ALIOSS_DOMAIN + &apos;template/&apos; + obj.path + &apos;/&apos; + obj.thumb+&quot;&gt;&quot;+&quot;&lt;span&gt;&quot; + obj.title+&quot;&lt;span&gt;&quot;+&quot;&lt;a class=&apos;deletepic&apos;&gt;&lt;/a&gt;&quot;; this.$refs.storyItem.appendChid(li); //追加的节点绑定事件是无效的 &#125;) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Story.vue vue操作 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;ul class=&quot;tabcont&quot;&gt; &lt;li v-for=&quot;item in myMaterial&quot;&gt; &lt;img :src=&quot;ALIOSS_DOMAIN + &apos;template/&apos; + item.path + &apos;/&apos; + item.thumb&quot;&gt; &lt;span&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;a class=&quot;deletepic&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &quot;../bus/eventBus.js&quot;;export default &#123; data() &#123; return &#123; myMaterial:[] &#125; &#125;, created() &#123; //获取subcomp传过来的数据并进行处理 eventBus.$on(&apos;transforData&apos;,function (obj) &#123; this.myMaterial.push(obj) &#125;.bind(this)) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 可以看得出来，即使撇开性能不论，传统dom操作的写法也是让人抓狂的，拼接字符串既增加了写代码的难度也增加了读代码的难度，Vue操作中虽然模板增加了不少内容，但摒弃了拼接字符串的弊端，简单清晰许多。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2018%2F11%2F24%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件通信是vue项目中几乎必须做的事情，vue中实现组件通信的场景，包括父子组件通信，非父子组件通信两种；而通信手段，则包括： （1）props down,events up(父子组件通信) （2）bus事件总线 （3）vuex通信 下面根据本人项目中的实践，具体来说说如何进行组件通信。 props down,events up（一）父组件向子组件传值 1.创建子组件，在src/components/文件夹下新建一个子组件2.在子组件中创建props，然后创建一个名为message的属性 Child.vue 1234567891011121314&lt;template&gt;&lt;div&gt;&lt;h2&gt;Child子组件&lt;/h2&gt;&lt;!--此时message即显示为“我是要传给子组件的数据”--&gt;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; props:[&quot;message&quot;]&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3、创建父组件，在src/components/文件夹下再创建一个父组件 4、在父组件中注册子组件，并在template中加入child标签，标签中添加message属性并赋值 Parent.vue 12345678910111213141516&lt;template&gt;&lt;div&gt;&lt;child message=&quot;我是要传给子组件的数据&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &apos;./Child&apos;;export default&#123; name:&quot;parent&quot;, components:&#123; child &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 父组件向子组件传值总结： 子组件在props中创建一个属性，用以接收父组件传过来的值； 父组件中注册子组件； 在子组件标签中添加子组件props中创建的属性； 把需要传给子组件的值赋给该属性； (二)子组件向父组件传值 1.在子组件中创建一个按钮，给按钮绑定一个点击事件 2.在响应该点击事件的函数中使用$emit来触发一个自定义事件，并传递一个参数 Child.vue 12345678910111213141516171819&lt;template&gt;&lt;div&gt;&lt;h2&gt;Child子组件&lt;/h2&gt;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;button @click=&quot;sendMessageToParent()&quot;&gt;&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; props:[&quot;message&quot;], methods:&#123; sendMessageToParent()&#123; this.$emit(&quot;listenToChildEvent&quot;,&quot;我是子组件传过来的数据&quot;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.在父组件中的子标签中监听该自定义事件并添加一个响应该事件的处理方法 Parent.vue 123456789101112131415161718192021&lt;template&gt;&lt;div&gt;&lt;child message=&quot;我是要传给子组件的数据&quot; @listenToChildEvent=&quot;showMessageFromChild()&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &quot;./Child&quot;;export default&#123; name:&quot;parent&quot;, components:&#123; child &#125;, methods:&#123; showMessageFromChild(data)&#123; console.log(data); // data即为子组件传过来的数据 &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件向父组件传值总结： 子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件； 将需要传的值作为$emit的第二个参数，该值将作为实参传给响应自定义事件的方法； 在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听； bus事件总线(非父子组件通信)如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，之后通过分别调用Bus事件触发和监听来实现组件之间的通信和参数传递。 1.添加一个bus.js 123456789├── node_modules├── src ├── assets ├── components ├── data ├── bus ├── bus.js └── store ├── actions.js bus.js 12import Vue from "vue"export default new Vue; 2.在需要通信的组件都引入bus.js compoment1.vue 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;bus()&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;import Bus from &apos;./bus/bus.js&apos; ;export default &#123; data() &#123; return &#123; message: &quot;&quot; &#125; &#125;, methods: &#123; bus () &#123; Bus.$emit(&apos;msg&apos;, &apos;我是要传给你的信息&apos;); //$emit函数的第二个参数即为要传递的数据 &#125; &#125;&#125;&lt;/script&gt; component2.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;!--此时message即显示为“我是要传给你的信息”--&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bus from &quot;./bus/bus.js&quot;;export default &#123; data() &#123; return &#123; message: &quot;&quot; &#125; &#125;, mounted() &#123; let self = this; Bus.$on(&apos;msg&apos;, (e) =&gt; &#123; self.message = e console.log(`传来的数据是：$&#123;e&#125;`) //$on事件的回调函数的参数即为接收到的数据； &#125;) &#125; &#125;&lt;/script&gt; 非父子组件数据传递总结： 创建一个事件总线，用它作为通信桥梁; 在需要传值的组件中用bus.$emit触发一个自定义事件，并传递参数; 在需要接收数据的组件中用bus.$on监听自定义事件，并在回调函数中处理传递过来的参数; Vuex传值如果说bus事件总线是为了处理简单场景下的数据传递，那么vuex则是为了复杂场景下的数据传递而设计。 关于Vuex，建议参阅https://www.jianshu.com/p/054486340a9b 以后有时间的话，我会单开一篇来说说vuex。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以一个实例入门nodejs]]></title>
    <url>%2F2018%2F11%2F20%2F%E4%BB%A5%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%85%A5%E9%97%A8nodejs%2F</url>
    <content type="text"><![CDATA[构建一个基础的http服务器 server.js 在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。 123456789101112131415161718var http = require("http");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); //发送一个HTTP状态和HTTP头的内容类型 response.write("Hello World"); //在HTTP相应主体中发送文本 response.end(); //调用 response.end() 完成响应&#125;).listen(8888);//orvar http = require("http");function onRequest(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end();&#125;//我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行回调 。http.createServer(onRequest).listen(8888); 创建及使用属于自己的模块 server.js 把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 导出 到请求这个模块的脚本 123456789101112131415var http = require("http");function start() &#123; function onRequest(request, response) &#123; console.log("Request received."); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log("Server has started.");&#125;exports.start = start; index.js 我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。 123var server = require("./server");server.start(); 请求路由 start.js 1234567891011121314151617var http = require("http");var url = require("url");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; //使用url模块解析请求的url console.log("Request for " + pathname + " received."); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log("Server has started.");&#125;exports.start = start; router.js 编写路由 12345function route(pathname) &#123; console.log("About to route a request for " + pathname);&#125;exports.route = route; 扩展start函数，将路由函数作为参数传递进去 1234567891011121314151617181920var http = require("http");var url = require("url");function start(route) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log("Request for " + pathname + " received."); route(pathname); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log("Server has started.");&#125;exports.start = start; 扩展index.js，使得路由函数可以被注入到服务器中 1234var server = require("./server");var router = require("./router");server.start(router.route); 启动应用（node index.js），随后请求一个URL，将会看到应用输出相应的信息，这表明HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由。 123bash$ node index.jsRequest for /foo received.About to route a request for /foo]]></content>
      <categories>
        <category>web前端</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[querySelector*和getElementBy*方法的区别]]></title>
    <url>%2F2018%2F11%2F19%2FquerySelector%E5%92%8CgetElementById%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[区别（1）querySelector属于 W3C 中的 Selectors API 规范，而getElementsBy 系列则属于 W3C 的 DOM 规范。 （2）querySelector*方法接收的参数是一个 CSS 选择符,其中querySelector()是用于接收一个CSS选择符，返回与该模式匹配的第一个元素；querySelectorAll()用于选择匹配到的所有元素；而 getElementsBy 系列接收的参数只能是单一的className、tagName 和 name等。 （3）querySelector选择符选出来的元素及元素数组是静态的，而getElementsBy 方法选出的元素是动态的。 说明querySelector list 是一个静态的 Node List，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。 12345678910111213141516&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var ul=document.querySelector('ul');var list=ul.querySelectorAll('li');for(var i=0;i&lt;list.length;i++)&#123; ul.appendChild(document.createElement('li'));&#125;//这个时候就创建了3个新的li，添加在ul列表上。console.log(list.length);// 输出的结果仍然是3，不是此时li的数量6&lt;/script&gt; getElementById list 是一个动态的 Node List， 每一次调用 lis 都会重新对文档进行查询，导致无限循环的问题。 12345678910111213&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var ul=document.getElementsByTagName('ul')[0];var list=ul.getElementsByTagName('li');for(var i=0;i&lt;5;i++)&#123; ul.appendChild(document.createElement('li'));&#125;console.log(list.length)//此时输出的结果就是3+5=8&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将异步请求callback转换为同步请求promise]]></title>
    <url>%2F2018%2F11%2F16%2F%E5%A6%82%E4%BD%95%E5%B0%86%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82callback%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82promise%2F</url>
    <content type="text"><![CDATA[promise的出现，解决了回调函数因为层层嵌套导致的可读性差问题。那么，对于老项目大量存在的异步回调，如何使用promise进行改造呢？ 每个promise都有三个状态。pending、Fulfilled、Rejected。最初为pending，状态一但改变为Fulfilled、Rejected中的一种，即成永远，不再改变。 pending: 等待状态。 Fulfilled: 表示成功完成。 Rejected: 表示被拒绝，失败。 原生ajax请求及promise改造12345678910111213141516171819202122232425262728293031323334353637// 原生ajax请求function nativeRequest(url) &#123;var xhr = new XMLHttpRequest()// 这里我建议的书写顺序是： onreadystatechange -&gt; open -&gt; send// 这样，onreadystatechange 可以获取 readyState 的状态 1 2 3 4xhr.onreadystatechange = function () &#123;if (xhr.readyState === 4) &#123; // 请求已完成，且响应已就绪if (xhr.status === 200) &#123;// TODO: 处理返回正常的数据 xhr.responseText&#125; else &#123;// TODO: 处理返回非正常的数据&#125;&#125;&#125;xhr.open('GET', url, true)xhr.send(null)&#125;// promise请求function promiseRequest(url) &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; resolve(xhr.responseText) &#125; else &#123; reject(xhr.responseText) &#125; &#125; &#125; xhr.open('GET', xhr, true) xhr.send(null) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125; jquery中的ajax请求及promise改造1234567891011121314151617181920212223242526272829//jQuery的ajax请求function ajaxResponse(url) &#123;$.ajax(&#123;url: url,type: 'GET',success: res =&gt; &#123;console.log(res)&#125;,error: err =&gt; &#123;console.log(err)&#125;&#125;)&#125;//promise改造function promiseAjaxResponse(url, &#123;type = 'GET',&#125; = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url, type, success: res =&gt; &#123; resolve(res) &#125;, error: err =&gt; &#123; reject(err) &#125; &#125;) &#125;)&#125; node风格的callback请求及promise改造1234567891011nodeGet(param, function (err, data) &#123; &#125;)//promise改造function nodeGetAysnc(param) &#123; return new Promise((resolve, reject) =&gt; &#123; nodeGet(param, function (err, data) &#123; if (err !== null) return reject(err) resolve(data) &#125;) &#125;)&#125; DOM load事件或者其他一次性事件请求及promise改造12345678910111213function load() &#123;console.log('onload - end')&#125;window.onload = load// promise改造function promiseLoad() &#123; return new Promise(function (resolve, reject) &#123; window.onload = resolve &#125;)&#125;promiseLoad().then(load) 转自https://www.cnblogs.com/weiqinl/p/9651515.html]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hasOwnProperty方法的使用]]></title>
    <url>%2F2018%2F11%2F16%2FhasOwnProperty%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。 判断自身属性是否存在123456789var o = new Object();o.prop = 'exists';function changeO() &#123;o.newprop = o.prop;delete o.prop;&#125;o.hasOwnProperty('prop'); // truechangeO();o.hasOwnProperty('prop'); // false 判断自身属性与继承属性1234567891011121314151617function foo() &#123;this.name = 'foo'this.sayHi = function () &#123;console.log('Say Hi') &#125;&#125;foo.prototype.sayGoodBy = function () &#123;console.log('Say Good By')&#125;let myPro = new foo()console.log(myPro.name) // fooconsole.log(myPro.hasOwnProperty('name')) // trueconsole.log(myPro.hasOwnProperty('toString')) // falseconsole.log(myPro.hasOwnProperty('hasOwnProperty')) // fasleconsole.log(myPro.hasOwnProperty('sayHi')) // trueconsole.log(myPro.hasOwnProperty('sayGoodBy')) // falseconsole.log('sayGoodBy' in myPro) // true 遍历一个对象的所有自身属性使用for…in循环对象的所有枚举属性，然后再使用hasOwnProperty()方法来忽略继承属性。 12345678910var buz = &#123;fog: 'stack'&#125;;for (var name in buz) &#123;if (buz.hasOwnProperty(name)) &#123; alert("this is fog (" + name + ") for sure. Value: " + buz[name]); &#125; else &#123; alert(name); // toString or something else &#125;&#125; 使用 hasOwnProperty 作为属性名JavaScript 并没有保护 hasOwnProperty 属性名，因此某个对象是有可能存在使用这个属性名的属性的。 1234567891011121314var foo = &#123; hasOwnProperty: function() &#123; return false; &#125;, bar: 'Here be dragons'&#125;;foo.hasOwnProperty('bar'); // 始终返回 false// 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法(&#123;&#125;).hasOwnProperty.call(foo, 'bar'); // true// 也可以使用 Object 原型上的 hasOwnProperty 属性Object.prototype.hasOwnProperty.call(foo, 'bar'); // true]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JavaScript中的this]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[ES6中新增了箭头函数这种语法,箭头函数以其简洁性和方便获取this的特性,俘获了大批粉丝儿。 它也可能是面试中的宠儿, 我们关键要搞清楚箭头函数和普通函数中的this。 普通函数中的this 1.this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj。 2.在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成)。 3.在严格模式下,没有直接调用者的函数中的this是 undefined。 4.使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象。 箭头函数中的this 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中使用this。 下面通过一些例子来研究一下 this的一些使用场景。 要整明白这些, 我们需要首先了解一下作用域链: 当在函数中使用一个变量的时候,首先在本函数内部查找该变量,如果找不到则找其父级函数,最后直到window,全局变量默认挂载在window对象下。 全局变量默认挂载在window对象下123456var aa = 2;console.log(window.aa); //2(function () &#123; aa = 3;&#125;)();console.log(window.aa); //3 我们仅仅声明了一个全局变量aa,但是打印出window.aa却和aa保持一致,为什么呢? 我们可以看到在window属性中,看到 aa 属性了;此外,函数也适用于此情况,全局函数也会挂在window对象下 我们常见的window的属性和方法有: alert, location,document,parseInt,setTimeout,setInterval等,window的属性默认可以省略window前缀! 普通函数中的this普通函数中的this指向它的直接调用者;如果找不到直接调用者,则是window。 我们来看一些例子。 示例1: 1234function test() &#123; console.log(this);&#125;test(); 结果是: window 。 原因: test()是一个全局函数,也就是说是挂在window对象下的,所以test()等价于 window.test() ,所以此时的this是window。 示例2: 12345678var obj = &#123; say: function () &#123; setTimeout(function () &#123; console.log(this) &#125;); &#125;&#125;obj.say(); 结果是: window。 匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window。 问题: 如果想要在setTimeout/setInterval中使用这个对象的this引用呢? 用一个变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针! 1234567891011var obj = &#123; func: function() &#123;&#125;, say: function () &#123; var that = this; //此时的this就是obj对象 setTimeout(function () &#123; console.log(this) that.func() &#125;); &#125;&#125;obj.say(); 我们也可以使用 func.bind(this) 给回调函数直接绑定宿主对象, bind绑定宿主对象后依然返回这个函数, 这是更优雅的做法： 1234567891011var obj = &#123; func: function() &#123;&#125;, say: function () &#123; // 此时的this就是obj对象 setTimeout(function () &#123; console.log(this) this.func() &#125;.bind(this)); &#125; &#125; obj.say(); // obj 示例3： 1234567891011121314window.val = 1;var obj = &#123; val: 2, dbl: function () &#123; this.val *= 2; val *= 2; console.log(val); console.log(this.val); &#125;&#125;;// 说出下面的输出结果obj.dbl();var func = obj.dbl;func(); 结果是: 2 4 8 8 val变量在没有指定对象前缀,默认从函数中找,找不到则从window中找全局变量。 即 val =2 就是 window.val = 2。this.val默认指的是 obj.val ;因为 dbl()第一次被obj直接调用func() 没有任何前缀,类似于全局函数,即 window.func调用,所以第二次调用的时候, this指的是window, val指的是window.val，第二次的结果受第一次的影响。 在严格模式下的this12345function test() &#123; 'use strict'; console.log(this);&#125;test(); 结果是: undefined。 箭头函数中的 this12345678var obj = &#123; say: function () &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;); &#125;&#125;obj.say(); // obj 此时的 this继承自obj, 指的是定义它的对象obj, 而不是 window! 示例(多层嵌套的箭头函数): 123456789101112var obj = &#123;say: function () &#123; var f1 = () =&gt; &#123; console.log(this); // obj setTimeout(() =&gt; &#123; console.log(this); // obj &#125;) &#125; f1(); &#125;&#125;obj.say() 因为f1定义时所处的函数中的this是指的obj, setTimeout中的箭头函数this继承自f1, 所以不管有多层嵌套,都是 obj。 示例(复杂情况: 普通函数和箭头函数混杂嵌套) 123456789101112var obj = &#123;say: function () &#123; var f1 = function () &#123; console.log(this); // window, f1调用时,没有宿主对象,默认是window setTimeout(() =&gt; &#123; console.log(this); // window &#125;) &#125;; f1(); &#125;&#125;obj.say() 结果: 都是 window,因为箭头函数在定义的时候它所处的环境相当于是window, 所以在箭头函数内部的this函数window。 示例(严格模式下的混杂嵌套) 12345678910111213var obj = &#123;say: function () &#123; 'use strict'; var f1 = function () &#123; console.log(this); // undefined setTimeout(() =&gt; &#123; console.log(this); // undefined &#125;) &#125;; f1(); &#125;&#125;obj.say() 结果都是undefined。 说明: 严格模式下,没有宿主调用的函数中的this是undefined!!!所以箭头函数中的也是undefined! 总结使用箭头函数,可以让我们解决一些在匿名函数中 this指向不正确的问题; 但是要注意在和普通函数混合的时候,this的指向可能是window !]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解闭包]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包，是 Javascript 比较重要的一个概念，对于初学者来讲，闭包是一个特别抽象的概念，特别是ECMAScript 规范给的定义，如果没有实战经验，很难从定义去理解它。因此，本文不会对闭包的概念进行大篇幅描述，直接上干货，让你分分钟理解闭包！ 闭包，一睹为快在接触一个新技术的时候，我首先会做的一件事就是找它的 demo。对于我们来说，看代码比自然语言更能理解一个事物的本质。其实，闭包无处不在，比如：jQuery、zepto的核心代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包，以便让你在大脑里产生闭包的画面： 12345678function A()&#123; function B()&#123; console.log("Hello Closure!"); &#125; return B;&#125;var C = A();C();//Hello Closure! 这是最简单的闭包。 有了初步认识后，我们简单分析一下它和普通函数有什么不同，上面代码翻译成自然语言如下： （1）定义普通函数 A （2）在 A 中定义普通函数 B （3）在 A 中返回 B （4）执行 A, 并把 A 的返回结果赋值给变量 C （5）执行 C 把这5步操作总结成一句话就是： 函数A的内部函数B被函数A外的一个变量 c 引用。 把这句话再加工一下就变成了闭包的定义： 当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 因此，当你执行上述5步操作时，就已经定义了一个闭包！ 这就是闭包。 闭包的用途在了解闭包的作用之前，我们先了解一下 Javascript 中的GC机制: 在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收，否则这个对象一直会保存在内存中。 在上述例子中，B 定义在 A 中，因此 B 依赖于 A ,而外部变量 C 又引用了 B , 所以A间接的被 C 引用。 也就是说，A 不会被 GC 回收，会一直保存在内存中。为了证明我们的推理，上面的例子稍作改进： 123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;&#125;var C = A();C();// 1C();// 2C();// 3 count 是函数A 中的一个变量，它的值在函数B 中被改变，函数B 每执行一次，count 的值就在原来的基础上累加 1 。因此，函数A中的 count 变量会一直保存在内存中。 count 是函数A 中的一个变量，它的值在函数B 中被改变，函数B 每执行一次，count 的值就在原来的基础上累加 1 。因此，函数A中的 count 变量会一直保存在内存中。 当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会“污染”全局的变量时，就可以用闭包来定义这个模块。 闭包的高级写法上面的写法其实是最原始的写法，而在实际应用中，会将闭包和匿名函数联系在一起使用。下面就是一个闭包常用的写法： 123456789101112131415(function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector("#"+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;)(document); 这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。 功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行，需要重点理解的是这种写法是如何实现闭包功能的。 可以将上面的代码拆分成两部分：(function(){}) 和 () , 第1个() 是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加 () 就表示执行这个匿名函数。 因此这段代码执行执行过程可以分解如下： 12345678910111213141516var f = function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector("#"+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;;f(document); 在这段代码中似乎看到了闭包的影子，但 f 中没有任何返回值，似乎不具备闭包的条件，注意这句代码： 1window.jView = obj; obj 是在函数 f 中定义的一个对象，这个对象中定义了一系列方法， 执行window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj . 而 obj 对象中的函数又引用了函数 f 中的变量 viewport ,因此函数 f 中的 viewport 不会被 GC 回收，viewport 会一直保存到内存中，所以这种写法满足了闭包的条件。 总结这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解JS的执行环境(execution context)、活动对象(activation object)以及作用域(scope)和作用域链(scope chain)的运行机制。但作为初学者，暂时不必了解这些，有了简单的理解之后，一定要在实际项目中用起来，等你用的多了，对于闭包，你自然会有更深层次的理解！ 转自https://www.cnblogs.com/onepixel/p/5062456.html]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流与函数防抖]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，onmousemove,resize,onscroll等等，有些时候，我们并不能或者不想频繁触发事件，咋办呢？这时候就该用到函数防抖和函数节流了！ 函数防抖防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行。 12345678910111213141516171819/** * 防抖函数 * @param method 事件触发的操作 * @param delay 多少毫秒内连续触发事件，不会执行 * @returns &#123;Function&#125; */ function debounce(method, delay) &#123; let timer = null return function () &#123; let self = this let args = arguments timer &amp;&amp; clearTimeout(timer) timer = setTimeout(function () &#123; method.apply(self, args) &#125;, delay) &#125;&#125;,// 触发onmouseover事件xcd.onmousemove = debounce(method,1000); 函数节流什么是节流？节流是如果你持续触发事件，每隔一段时间，只执行一次事件。 1234567891011121314151617181920212223242526272829303132333435363738 /** * 节流函数 * @param method 事件触发的操作 * @param mustRunDelay 间隔多少毫秒需要触发一次事件 * @returns &#123;Function&#125; *///节流时间戳版 function throttle(method,mustRunDelay)&#123; var self,args,initTime = 0; return function()&#123; var now = +new Date();//将new date()转化为时间戳 self = this; args = arguments; if(now - initTime&gt;mustRunDelay)&#123; method.apply(self,args); initTime = now; &#125; &#125; &#125; //触发onmousemove事件 xcd.onmousemove = throttle(method,1000); //节流定时器版 function throttle(method,mustRunDelay)&#123; var timeout; return function()&#123; var self = this;args = arguments; if(!timeout)&#123; timeout = setTimeout(function()&#123; timeout = null; method.apply(self,args); &#125;,mustRunDelay); &#125;; &#125; &#125; //触发onmousemove事件 xcd.onmousemove = throttle(method,1000);]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript去重与排序方法总结]]></title>
    <url>%2F2018%2F11%2F15%2FJavaScript%E5%8E%BB%E9%87%8D%E4%B8%8E%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[去重还排序是程序设计中最为基本的算法以及面试中的基本考点，本文对去重和排序方法进行总结。 去重 123456789101112131415161718192021222324252627282930313233// 方法一var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0]function test()&#123; for (var i = 0; i &lt; arr.length; i++)&#123; for(var j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] === arr[j]) arr.splice(j,1);//如果前一个值与后一个值相等，那么就去掉后一个值，splice()可以修改原数组 &#125; &#125; return arr;&#125;test();// 方法二var arr = [1, 1, 4, 50, 50, 6, 2, 2];function test()&#123; return arr.filter(function(item,index,array)&#123; return array.indexOf(item) === index; //或者这样写return array.indexOf(item, index+1) === -1; 如果没有重复项，返回true //用filter方法，返回ietm对应的indexOf索引值与本身index索引值相等的值，也就是去掉重复的值，filter本身不修改数组，只是会自动遍历数组， // 去掉重复值后，那么arr就剩下不重复的了 &#125;);&#125;test();//输出Array [ 1, 4, 50, 6, 2 ]// 方法三（es6）var arr = [1, 1, 4, 50, 50, 6, 2, 2];function unique(arr)&#123; return Array.from(new Set(arr));&#125;unique(arr); 排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//冒泡排序 从数组中随便拿一个数与后一位比较，如果前者比后者大，那么两者交换位置，从而遍历数组可以得到排序的效果var arr = [1, 9, 4, 50, 49, 6, 3, 2];function test(arr)&#123; for (var i = 0; i &lt; arr.length - 1; i++)&#123; for (var j = i + 1; j &lt; arr.length; j++)&#123; var tempi = arr[i]; //获取第一个值，并与后一个值比较 var tempj = arr[j]; if (tempi &gt; tempj)&#123; arr[i] = tempj; arr[j] = tempi;//如果前一个值比后一个值大，那么相互交换 &#125; &#125; &#125; console.log(arr); //return arr；&#125;test(arr);// 快速排序 在数组中间那一个值，然后用这个值跟数组里面的值相比较，大于此值的放在一边，小于的也放在一边，然后用concat()合并，// 再进行比较，如此反复var arr = [1, 9, 4, 50, 49, 6, 3, 2];function test(arr)&#123; if (arr.length &lt;= 1) return arr;//如果数组只有一位，就没有必要比较了 var index = Math.floor(arr.length / 2);//获取中间值的索引 var cur = arr.splice(index, 1);//截取中间值，如果此处使用cur=arr[index]; 那么将会出现无限递归的错误 var left = [], right = [];//小于中间值的放在left数组里，大于的放在right数组 for (var i = 0; i &lt; arr.length; i++)&#123; if (cur &gt; arr[i])&#123; left.push(arr[i]); &#125; else&#123; right.push(arr[i]); &#125; &#125; return test(left).concat(cur, test(right));//通过递归，上一轮比较好的数组合并，并且再次进行比较&#125;test(arr);// sort方法var arr = [1, 9, 4, 50, 49, 6, 3, 2];function test(arr)&#123; return arr.sort(sortNumber);&#125;function sortNumber(a, b)&#123; return a - b;&#125;test(arr);]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常用工具函数]]></title>
    <url>%2F2018%2F11%2F15%2FJavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[平时在工作中都会积累一些常用方法，持续更新。 判断数据类型1234567function getType(params)&#123; return Object.prototype.toString.call(params);&#125;//examplegetType([]) //"[object Array]"getType(function()&#123;&#125;) //"[object Function]"getType(&#123;&#125;) //"[object Object]" 1234567function toType(obj) &#123; return &#123;&#125;.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();&#125;//exampletoType([]) //"array"toType(function()&#123;&#125;) //"function"toType(&#123;&#125;) //"object" 参数过滤123456789101112131415161718192021//结合类型判断函数，对传入的对象参数进行过滤function filterNull (o) &#123; for (var key in o) &#123; if (o[key] === null) &#123; delete o[key] &#125; if (toType(o[key]) === 'string') &#123; o[key] = o[key].trim() &#125; else if (toType(o[key]) === 'object') &#123; o[key] = filterNull(o[key]) &#125; else if (toType(o[key]) === 'array') &#123; o[key] = filterNull(o[key]) &#125; &#125; return o&#125;function foo (params) &#123; if(params) &#123; params = filterNull(params) &#125;&#125; 将arguments对象转成数组123var argArray = Array.prototype.slice.call(arguments);//或者ES6：var argArray = Array.from(arguments) 评分方法12345function getRate(rate)&#123; return '★★★★★☆☆☆☆☆'.slice(5 - rate, 10 - rate);&#125;//examplegetRate(2) //★★☆☆☆ 范围内生成随机数12345function randNum(min, max) &#123; return Math.floor(min + Math.random() * ((max+1) - min));&#125;//examplerandNum(0 ,100) //生成0-100的随机数 生成随机字符串12345678//生成一个指定位数的随机字符串function randomAlphaNum(len) &#123; var rdmString = ''; for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len).toUpperCase();&#125;//examplerandomAlphaNum(16) //"017W8K1EQ63IW0T4" 对象深拷贝 深度拷贝通用函数。 深拷贝就是指创建一个数据内容和结构一模一样的新对象，新对象内的所有值的指针地址都是新的地址，即复制出一个全新的对象实例，新对象跟原对象不共享内存，两者操作互不影响。 12345678910111213141516171819202122232425262728function deepClone(values) &#123; var copy; if (null == values || "object" != typeof values) return values; if (values instanceof Date) &#123; copy = new Date(); copy.setTime(values.getTime()); return copy; &#125; if (values instanceof Array) &#123; copy = []; for (var i = 0, len = values.length; i &lt; len; i++) &#123; copy[i] = deepClone(values[i]); &#125; return copy; &#125; if (values instanceof Object) &#123; copy = &#123;&#125;; for (var attr in values) &#123; if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]); &#125; return copy; &#125; throw new Error("Unable to copy values! Its type isn't supported.");&#125; json对象的parse和stringify。 JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。该方法的不足之处是能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深拷贝。 123var source = &#123; name:"source", child:&#123; name:"child" &#125; &#125; var target = JSON.parse(JSON.stringify(source));console.log(target) 对象浅拷贝 浅拷贝ShallowCopy，是一个对象的逐位副本。创建一个新对象，该对象具有原始对象中的精确副本。如果对象的任何字段是对其他对象的引用，则只复制引用地址，即只复制内存地址，而不复制对象本身，新旧对象还是共享同一块堆内存。改变其中一个对象，另一个也会受影响。如果有修改，会失去原始数据。 简单的引用复制。 1234567891011121314function shallowClone(copyObj) &#123; var obj = &#123;&#125;; for ( var i in copyObj) &#123; obj[i] = copyObj[i]; &#125; return obj;&#125;var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = shallowClone(x);console.log(y.b.f === x.b.f); // true Object.assign()方法。 Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 1234567var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = Object.assign(&#123;&#125;, x);console.log(y.b.f === x.b.f); // true 求数组的最大值、最小值、和、平均数1234567891011121314151617var arr = [23,45,23,890]取最大值：max = Math.max.apply(null, arr)取最小值：min = Math.min.apply(null,arr)取和：function arrAdd() &#123; var sum = 0for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; return sum &#125;add = arrAdd() //取和average = arrAdd()/arr.length //取平均数 获取数组某个元素的下标123456789101112131415/** * 获取数组某个元素下标 * @param arrays 传入的数组 * @param item 需要获取下标的元素 */function contains(arrays, item) &#123; var i = arrays.length; while (i--) &#123; if (arrays[i] === item) &#123; return i; &#125; &#125;&#125;//结合数组的splice方法，用来删除数组的当前项myArray.splice(contains(myArray,item),1) 存储localStorage12345678910/** * 存储localStorage */function setStore(name, content) &#123; if (!name) return; if (typeof content !== 'string') &#123; content = JSON.stringify(content); &#125; window.localStorage.setItem(name, content);&#125; 获取localStorage1234567/** * 获取localStorage */function getStore(name) &#123; if (!name) return; return window.localStorage.getItem(name);&#125; 删除localStorage1234567/** * 删除localStorage */function removeStore（name）&#123; if (!name) return; window.localStorage.removeItem(name);&#125; 获取cookie12345678910111213141516171819202122232425/** * 将document.cookie属性的值解析出来 */function getCookie(key)&#123; var arr1 = document.cookie.split("; "); for(var i = 0; i &lt; arr1.length; i++)&#123; var arr2 = arr1[i].split("="); if(arr2[0] == key)&#123; return decodeURIComponent(arr2[1]); &#125; &#125;&#125;// orfunction getCookie (cName) &#123; if (document.cookie.length &gt; 0) &#123; let cStart = document.cookie.indexOf(cName + '=') if (cStart !== -1) &#123; cStart = cStart + cName.length + 1 let cEnd = document.cookie.indexOf(';', cStart) if (cEnd === -1) cEnd = document.cookie.length return unescape(document.cookie.substring(cStart, cEnd)) &#125; &#125; return ''&#125; 设置cookie1234567891011121314151617181920212223242526272829303132333435363738/** * 设置一个cookie的值，同时提供一个可选的max-age属性 * @param key 要设置的属性 * @param value 要设置的属性的值 * @param d 设置的max-age */function setCookie(key,value,d)&#123; if(d === undefined)&#123; document.cookie = encodeURIComponent(key) + "=" + encodeURIComponent(value); &#125;else&#123; document.cookie = encodeURIComponent(key) + "=" + encodeURIComponent(value) + ";max-age=" + (d*60*60*24); &#125;&#125;// 另一个版本的setCookie/** * 设置一个cookie的值，同时提供一个可选的max-age属性 * @param cName 要设置的属性 * @param value 要设置的属性的值 * @param expire 设置的expire */function setCookie (cName, value, expire) &#123; var date = new Date() date.setSeconds(date.getSeconds() + expire) document.cookie = cName + '=' + encodeURI(value) + '; expires=' + date.toGMTString()&#125;//要改变cookie的值，需要使用相同的名字、路径和域，但是新的值重新设置cookie的值。同样地，设置新max-age属性就可以改变原来的cookie的有效期setCookie('name','金赫思');console.log(getCookie('name'));//'金赫思'setCookie('name','康健');console.log(getCookie('name'));//'康健'//要删除一个cookie，需要使用相同的名字、路径和域，然后指定一个任意(非空)的值，并且将max-age属性指定为0，再次设置cookiesetCookie('name','金赫思');console.log(getCookie('name'));//'金赫思'setCookie('name','金赫思',0);console.log(getCookie('name'));//undefined 删除cookie1234567/** * 删除cookie * @param cName 要删除的cookie属性 */function delCookie (cName) &#123; setCookie(cName, '', -1)&#125; 获取URL参数123456789101112131415161718 /** * 获取URL请求参数 */function getQueryStrings () &#123; var url = request.url console.log(url) var theRequest = &#123;&#125; if (url.indexOf('') !== -1) &#123; var str = url.substr(1) var strs = str.split('&amp;') for (var i = 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split('=')[0]] = unescape(strs[i].split('=')[1]) &#125; &#125; return theRequest &#125; var params = getQueryStrings() var app_id = params['app_id'] // 获取app_id IE浏览器版本检测12345678910111213141516// 判断浏览器类型，如果浏览器是ie且版本低于ie10，提示更换浏览器function ieVersion () &#123; var userAgent = navigator.userAgent var isOpera = userAgent.indexOf('Opera') &gt; -1 var isIE = userAgent.indexOf('compatible') &gt; -1 &amp;&amp; userAgent.indexOf('MSIE') &gt; -1 &amp;&amp; !isOpera if (isIE) &#123; var reIE = new RegExp('MSIE (\\d+\\.\\d+);') reIE.test(userAgent) var fIEVersion = parseFloat(RegExp['$1']) if (fIEVersion &lt; 10) &#123; this.$alert('系统检测到您的IE浏览器版本过低，部分功能无法正常使用，推荐您升级浏览器或更换其他浏览器以获取最佳体验！', '温馨提示', &#123; dangerouslyUseHTMLString: true &#125;) &#125; &#125;&#125;, 将时间戳转换为时间格式12345678910/** * @param t 时间戳 */function formatDate(t) &#123; var date = new Date(t); var Y = date.getFullYear() + '-'; var M = (date.getMonth()+1 &lt; 10 ? '0'+(date.getMonth()+1) : date.getMonth()+1) + '-'; var D = date.getDate()&lt;10 ? '0'+date.getDate() : date.getDate(); return Y + M + D;&#125; 获取URL中”?”符后的字符串123456789101112function GetRequest() &#123; var url = location.search; //获取url中"?"符后的字串 var theRequest = new Object(); if (url.indexOf("?") != -1) &#123; var str = url.substr(1); strs = str.split("&amp;"); for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split("=")[0]]=unescape(strs[i].split("=")[1]); &#125; &#125; return theRequest; &#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目的过滤器配置]]></title>
    <url>%2F2018%2F11%2F12%2Fvue%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一个项目中，可能要用到很多过滤器来处理数据，多个组件公用的，可以注册全局过滤器。单个组件使用的，就挂载到实例filters中。项目做的多了以后，可以整理一套常用的filters，不用反复的写。比如：时间等各种操作，数据格式转化，单位换算，部分数据的md5加密等… 创建一个filters文件夹，专门放过滤器 123456789├── node_modules├── src ├── assets ├── components ├── data ├── filters ├── filters.js └── store ├── actions.js filter.js 1234567891011121314151617181920212223//将秒转换为时分秒export function formatSeconds(value) &#123; var secondTime = parseInt(value);// 秒 var minuteTime = 0;// 分 var hourTime = 0;// 小时 if(secondTime &gt; 60) &#123; minuteTime = parseInt(secondTime / 60); secondTime = parseInt(secondTime % 60); if(minuteTime &gt; 60) &#123; hourTime = parseInt(minuteTime / 60); minuteTime = parseInt(minuteTime % 60); &#125; &#125; var result = "" + parseInt(secondTime) + "秒"; if(minuteTime &gt; 0) &#123; result = "" + parseInt(minuteTime) + "分" + result; &#125; if(hourTime &gt; 0) &#123; result = "" + parseInt(hourTime) + "小时" + result; &#125; return result; &#125; main.js 123456789101112import Vue from 'vue'import App from './App'import router from './router'import Vuex from 'vuex'import store from './store/index'import axios from 'axios'import * as filters from './filters/filter.js' //引入过滤器Vue.prototype.$http = axios//使用过滤器Object.keys(filters).forEach(key=&gt;&#123; Vue.filter(key,filters[key])&#125;) 页面中直接使用过滤器即可 1&lt;div class="videolength fl"&gt;视频总时长：&lt;em&gt;&#123;&#123;worksInfo.duration|formatSeconds&#125;&#125;&lt;/em&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vue中使用websocket]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8websocket%2F</url>
    <content type="text"><![CDATA[之前在一个大数据治理项目中，因为需要页面主动更新数据，就用到了websocket，现将核心代码贴出，以备查阅。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859data()&#123; return &#123; logCountTotalDataSocket:&#123;&#125; websock:null &#125;&#125;,methods:&#123; threadPoxi() &#123; //与后端约定要发送的数据 const agentString = '&#123;"event": "subscribe", "topic": "logStatistic", "serviceId": "all"&#125;' // 若是ws开启状态 if (this.websock.readyState === this.websock.OPEN) &#123; this.websocketsend(agentString) &#125; else if (this.websock.readyState === this.websock.CONNECTING) &#123; const that = this setTimeout(function() &#123; that.websocketsend(agentString) &#125;, 300) &#125; else &#123; this.initWebSocket() const that = this setTimeout(function() &#123; that.websocketsend(agentString) &#125;, 500) &#125; &#125;, initWebSocket() &#123; // 服务器地址必须是ws地址，创建websocket对象 const wsuri = 'ws://121.40.165.18:8800' this.websock = new WebSocket(wsuri) this.websock.onmessage = this.websocketonmessage this.websock.onerror = this.websocketerror this.websock.onclose = this.websocketclose &#125;, // 数据接收 websocketonmessage(e) &#123; console.log(e) console.log('websocketonmessage', typeof e.data) this.logCountTotalDataSocket = JSON.parse(e.data) || &#123;&#125; &#125;, // 数据发送 websocketsend(data) &#123; console.log('websocketsend', data) this.websock.send(data) console.log(data) &#125;, // 连接发送错误 websocketerror(e) &#123; console.log(e.code) &#125;, // 关闭 websocketclose(e) &#123; console.log(e.code) &#125; &#125;,mounted()&#123; this.initWebSocket() this.threadPoxi()&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue调试工具Devtools不出现的解决方式]]></title>
    <url>%2F2018%2F10%2F25%2Fvue%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7Devtools%E4%B8%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在使用vuex时，想直观的查看数据state的变动，用Devtools可实现，但是在Google浏览器中开发调试的时候，右上角出现vue的图标，但是在开发者工具中没有出现vue调试（已在扩展程序中安装 Vue Devtools） 没显示调试工具的原因是用了生产环境的版本或是压缩的vue版本，或是扩展程序没有勾选：允许访问文件网址。 如果勾选了还是没有显示，说明采用了压缩版/生产版的Vuejs，则继续采用如下方案： 在main.js中添加代码： 123456// 若是没有开启Devtools工具，在开发环境中开启，在生产环境中关闭if (process.env.NODE_ENV == 'development') &#123; Vue.config.devtools = true;&#125; else &#123; Vue.config.devtools = false;&#125;]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用webstorm时提示please specify eslint package的解决方法]]></title>
    <url>%2F2018%2F10%2F25%2F%E4%BD%BF%E7%94%A8webstorm%E6%97%B6%E6%8F%90%E7%A4%BAplease-specify-eslint-package%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[webstorm的file –&gt; settings –&gt; Language &amp; Frameworrks –&gt; Javascript –&gt; Code Quality Tools –&gt; 打开ESLint，把他们的 Enable 属性都取消，点击右下角‘Apply’，‘OK’ 即可。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个loading模板]]></title>
    <url>%2F2018%2F10%2F25%2F%E4%B8%80%E4%B8%AAloading%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[12345678910111213var _LoadingTitle="努力加载中...";var _LoadingHtml = '&lt;div id="loadingDiv" style="position:absolute;left:0;width:100%;height:100%;top:0;opacity:1;filter:alpha(opacity=80);z-index:10000;"&gt;&lt;div style="position: absolute; cursor1: wait; left: 50%; top:50%; width: 448px; height: 118px; line-height: 118px; border: 2px solid #4dd3c5; color: #4dd3c5; margin-left:-225px;margin-top: -60px;font-size:24px;text-align: center;"&gt;'+_LoadingTitle+'&lt;/div&gt;&lt;/div&gt;';document.write(_LoadingHtml);//监听加载状态改变document.onreadystatechange = completeLoading;//加载状态为complete时移除loading效果function completeLoading() &#123; if (document.readyState == "complete") &#123; var loadingMask = document.getElementById('loadingDiv'); loadingMask.parentNode.removeChild(loadingMask);&#125;&#125; //在index.html中引入该文件]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css用border设置hover是出现div抖动和走位问题解决]]></title>
    <url>%2F2018%2F10%2F24%2FCss%E7%94%A8border%E8%AE%BE%E7%BD%AEhover%E6%98%AF%E5%87%BA%E7%8E%B0div%E6%8A%96%E5%8A%A8%E5%92%8C%E8%B5%B0%E4%BD%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[样式设置 ：div:hover { border:1px solid red;} 当鼠标移动到div时，产生抖动和偏移。 产生的原因：是因为设置border时设置了1px边框，多出的这1px，与其它元素产生了挤压， 导致div偏移。 解决方法：第一种方法：先将这个div设置一个跟背景颜色一样的边框，比如背景颜色为#aaa；那么你先设置这个div的样式：div {border:1px solid #aaa;}，然后再设置hover动作，div:hover { border:1px solid red;} 。 第二种方法：将这个div的border颜色设置为透明 ，div {border:1px solid transparent;},然后再引入hover动作div:hover { border:1px solid red;} 。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目实现图片的横向滚动]]></title>
    <url>%2F2018%2F10%2F23%2Fvue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[源起最近公司的AE编辑器项目有一项需求，就是滚动鼠标滚轮的时候实现图片列表的横向滚动。那么，如何在vue中实现这个功能呢？话不多说，上代码。 创建Firefox全局变量创建Firefox全局变量是为了达到浏览器兼容的效果。 创建global文件夹，并新建index.js。 index.js 12const Firefox = navigator.userAgent.indexOf('Firefox') != -1;export default &#123; Firefox &#125; vue文件引入global变量，并使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;div class=&quot;scenelist&quot;&gt; &lt;div class=&quot;listwrap&quot; id=&quot;listwrap&quot;&gt; &lt;draggable :options=&quot;&#123;chosenClass:&apos;chosen&apos;, animation: 500&#125;&quot; element=&quot;ul&quot; v-model=&quot;list&quot; :move=&quot;allow&quot;&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot; @click=&quot;cur_index = index&quot; :class=&quot;&#123;active: cur_index === index&#125;&quot;&gt; &lt;img :src=&quot;item.src&quot;&gt; &lt;div class=&quot;btns&quot;&gt; &lt;Tooltip content=&quot;复制场景&quot; placement=&quot;top&quot; class=&quot;btnitem&quot;&gt; &lt;a class=&quot;copybtn&quot; @click=&quot;copyPage(index)&quot;&gt; &lt;i class=&quot;iconfont icon-fuzhi&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/Tooltip&gt; &lt;Tooltip content=&quot;删除场景&quot; placement=&quot;top&quot; class=&quot;btnitem&quot;&gt; &lt;a class=&quot;deletebtn&quot; @click=&quot;showDelMessage(index)&quot;&gt; &lt;i class=&quot;iconfont icon-shanchu&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/Tooltip&gt; &lt;/div&gt; &lt;div class=&quot;itemcount pa&quot;&gt;&#123;&#123;index+1&#125;&#125;&lt;/div&gt; &lt;div class=&quot;checkall&quot;&gt;&lt;/div&gt; &lt;/li&gt; &lt;/draggable&gt; &lt;/div&gt; &lt;a class=&quot;addscene&quot; @click=&quot;addScene()&quot;&gt; &lt;Icon type=&quot;md-add&quot; /&gt; &lt;/a&gt; &lt;Modal v-model=&quot;showModal&quot; title=&quot;提示&quot; @on-ok=&quot;delPage&quot; width=&quot;300&quot;&gt; &lt;p&gt;删除后不可恢复, 是否继续?&lt;/p&gt; &lt;/Modal&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import global_ from &apos;../../global/index&apos; export default &#123; methods:&#123; MouseWheel(e) &#123; e = e || window.event; if (e.stopPropagation) &#123; e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; &#125; if (e.preventDefault) &#123; e.preventDefault(); &#125; else &#123; e.returnValue = false; &#125; if (global_.Firefox) &#123; if (e.detail &gt; 0) &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() + 60); &#125; else &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() - 60); &#125; &#125; else &#123; if (e.wheelDelta &lt; 0) &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() + 60); &#125; else &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() - 60); &#125; &#125; &#125; &#125;, mounted() &#123; let scrollDiv = document.getElementById(&quot;listwrap&quot;); global_.Firefox ? scrollDiv.addEventListener(&apos;DOMMouseScroll&apos;, this.MouseWheel, false) : (scrollDiv.onmousewheel = this.MouseWheel); &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
