<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[this、apply、call和bind的使用]]></title>
    <url>%2F2018%2F12%2F03%2Fthis%E3%80%81apply%E3%80%81call%E5%92%8Cbind%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这又是一个面试经典问题~/(ㄒoㄒ)/~~也是 ES5中众多坑中的一个，在 ES6 中可能会极大避免 this 产生的错误，但是为了一些老代码的维护，最好还是了解一下 this 的指向和 call、apply、bind 三者的区别。 this 的指向在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象，来，跟着我朗读三遍：this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。记住这句话，this 你已经了解一半了。 下面我们来看一个最简单的例子：例 1： 12345678910var name = "windowsName";function a() &#123; var name = "Cherry"; console.log(this.name); // windowsName console.log("inner:" + this); // inner: Window&#125;a();console.log("outer:" + this) // outer: Window 这个相信大家都知道为什么 log 的是 windowsName，因为根据刚刚的那句话“this 永远指向最后调用它的那个对象”，我们看最后调用 a 的地方 a();，前面没有调用的对象那么就是全局对象 window，这就相当于是 window.a()；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property &#39;name&#39; of undefined。 再看下这个例子：例 2： 12345678var name = "windowsName";var a = &#123; name: "Cherry", fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn(); 在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。是不是有一点清晰了呢~ 我们做一个小小的改动：例 3： 12345678var name = "windowsName"; var a = &#123; name: "Cherry", fn : function () &#123; console.log(this.name); // Cherry &#125; &#125; window.a.fn(); 这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 a。 我们再来看一下这个例子：例 4： 12345678var name = "windowsName";var a = &#123; // name: "Cherry", fn : function () &#123; console.log(this.name); // undefined &#125;&#125;window.a.fn(); 这里为什么会打印 undefined 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 this.name 的值是 undefined。 这个例子还是说明了：this 永远指向最后调用它的那个对象，因为最后调用 fn 的对象是 a，所以就算 a 中没有 name 这个属性，也不会继续向上一个对象寻找 this.name，而是直接输出 undefined。 再来看一个比较坑的例子：例 5： 1234567891011var name = "windowsName";var a = &#123; name : null, // name: "Cherry", fn : function () &#123; console.log(this.name); // windowsName &#125;&#125;var f = a.fn;f(); 这里你可能会有疑问，为什么不是 Cherry，这是因为虽然将 a 对象的 fn 方法赋值给变量 f 了，但是没有调用，再接着跟我念这一句话：“this 永远指向最后调用它的那个对象”，由于刚刚的 f 并没有调用，所以 fn() 最后仍然是被 window 调用的。所以 this 指向的也就是 window。 由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，永远是this 永远指向最后调用它的那个对象。 再来看一个例子：例 6： 1234567891011var name = "windowsName";function fn() &#123; var name = 'Cherry'; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn() 读到现在了应该能够理解这是为什么了吧(oﾟ▽ﾟ)o。 怎么改变 this 的指向改变 this 的指向我总结有以下几种方法： 使用 ES6 的箭头函数 在函数内部使用 _this = this 使用 apply、call、bind new 实例化一个对象 例 7： 123456789101112131415161718var name = "windowsName";var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function 在不使用箭头函数的情况下，是会报错的，因为最后调用 setTimeout 的对象是 window，但是在 window 中并没有 func1 函数。 我们在改变 this 指向这一节将把这个例子作为 demo 进行改造。 箭头函数众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。箭头函数的 this 始终指向函数定义时的 this，而非执行时。，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。 例 8 ： 123456789101112131415161718var name = "windowsName";var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry 在函数内部使用 _this = this如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。例 9： 1234567891011121314151617181920var name = "windowsName";var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; var _this = this; setTimeout( function() &#123; _this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry 这个例子中，在 func2 中，首先设置 var _this = this;，这里的 this 是调用 func2 的对象 a，为了防止在 func2 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 this(指向变量 a) 赋值给一个变量 _this，这样，在 func2 中我们使用 _this 就是指向对象 a 了。 使用 apply、call、bind使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的： 使用 apply例 10： 12345678910111213141516var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.apply(a),100); &#125;&#125;;a.func2() // Cherry 使用 call例 11： 12345678910111213141516var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.call(a),100); &#125;&#125;;a.func2() // Cherry 使用 bind例 12： 12345678910111213141516var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.bind(a)(),100); &#125;&#125;;a.func2() // Cherry apply、call、bind 区别刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。 在 MDN 中定义 apply 如下； apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 语法： fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 apply 和 call 的区别其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。 call 的语法为： 1fun.call(thisArg[, arg1[, arg2[, ...]]]) 所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 例 13： 123456789var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.apply(a,[1,2]) // 3 例 14： 123456789var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.call(a,1,2) // 3 bind 和 apply、call 区别我们先来将刚刚的例子使用 bind 试一下 123456789var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2) 我们会发现并没有输出，这是为什么呢，我们来看一下 MDN 上的文档说明： bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用： 123456789var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)() // 3 ==================================== 更新============================== JS 中的函数调用看到留言说，很多童靴不理解为什么 例 6 的 innerFunction 和 例 7 的 this 是指向 window 的，所以我就来补充一下 JS 中的函数调用。例 6： 1234567891011var name = "windowsName";function fn() &#123; var name = 'Cherry'; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn() 例 7： 123456789101112131415161718var name = "windowsName";var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function 函数调用的方法一共有 4 种 作为一个函数调用 函数作为方法调用 使用构造函数调用函数 作为函数方法调用函数（call、apply） 作为一个函数调用比如上面的 例 1：例 1： 12345678910var name = "windowsName";function a() &#123; var name = "Cherry"; console.log(this.name); // windowsName console.log("inner:" + this); // inner: Window&#125;a();console.log("outer:" + this) // outer: Window 这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined。 但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用。 函数作为方法调用所以说更多的情况是将函数作为对象的方法使用。比如例 2：例 2： 12345678var name = "windowsName";var a = &#123; name: "Cherry", fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn(); 这里定义一个对象 a，对象 a 有一个属性（name）和一个方法（fn）。 然后对象 a 通过 . 方法调用了其中的 fn 方法。 然后我们一直记住的那句话“this 永远指向最后调用它的那个对象”，所以在 fn 中的 this 就是指向 a 的。 使用构造函数调用函数 如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象： 123456789// 构造函数:function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125; // This creates a new objectvar a = new myFunction("Li","Cherry");a.lastName; // 返回 "Cherry" 这就有要说另一个面试经典问题：new 的过程了，(ಥ_ಥ)这里就简单的来看一下 new 的过程吧：伪代码表示： 12345678var a = new myFunction("Li","Cherry");new myFunction&#123; var obj = &#123;&#125;; obj.__proto__ = myFunction.prototype; var result = myFunction.call(obj,"Li","Cherry"); return typeof result === 'obj'? result : obj;&#125; 创建一个空对象 obj; 将新创建的空对象的隐式原型指向其构造函数的显示原型。 使用 call 改变 this 的指向 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。 所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。 作为函数方法调用函数 在 JavaScript 中, 函数是对象。 JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身 在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。 这个时候我们再来看例 6：例 6： 1234567891011var name = "windowsName";function fn() &#123; var name = 'Cherry'; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn() 这里的 innerFunction() 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下就是 window 调用的） 然后再看一下 例 7：例 7： 123456789101112131415161718var name = "windowsName";var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100 ); &#125;&#125;;a.func2() // this.func1 is not a function 这个简单一点的理解可以理解为“匿名函数的 this 永远指向 window”，你可以这样想，还是那句话this 永远指向最后调用它的那个对象，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数名字啊，笑哭，所以我们是没有办法被其他对象调用匿名函数的。所以说 匿名函数的 this 永远指向 window。 如果这个时候你要问，那匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊，比如例 7 中的 setTimeout。 转自https://juejin.im/post/59bfe84351882531b730bac2]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册]]></title>
    <url>%2F2018%2F12%2F03%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[原文地址：freeCodeCamp（需梯子） JavaScript 完整手册JavaScript 是世界上最流行的编程语言之一，现在也广泛用于浏览器之外的场景中。近几年，Node.js 的崛起解锁了长期以来被 Java, Ruby, Python, PHP 等传统服务端语言统治的后端开发领域。 这本 JavaScript 完整手册遵循二八定律（the 80/20 rule）：在 20% 的时间里了解 80% 的 JavaScript 知识。 快来了解所有你需要知道的 JavaScript 吧！ 注意：你可以获取这篇 JavaScript 指南的 PDF, ePub, Mobi 版本以便在 Kindle 或平板上阅读。 介绍JavaScript 是世界上最流行的编程语言之一。自从 20 年前诞生以来，已经走过很长的一段路。作为第一个而且是唯一一个被网页浏览器原生支持的脚本语言，它被下了死命令。 一开始，它并不像今天这样强大，主要被用于各种花哨的动画 😆 和当时被广泛称奇的动态 HTML（DHTML）中。伴随着网页平台发展的需要，JavaScript 也有责任变得更好，以满足世界上最广泛使用的生态系统之一的需求。平台本身引入了很多东西，包括浏览器 API，同时语言特性也成长了许多。 现在 JavaScript 也可以操作数据库和开发应用程序，甚至可以开发嵌入式程序，移动 APP，电视应用程序等等。曾经只是在浏览器中的小语言，现在也是世界上最流行的语言了~ JavaScript 基本定义JavaScript 是这样的编程语言： 高级：它允许你更加注重本身的逻辑，忽略当前运行它的机器的详细信息。JavaScript 通过垃圾回收器自动管理内存，让你可以更专注代码而不是管理内存，它也提供了很多构造函数让你能够处理强大的变量和对象。 动态：和静态语言在编译时执行相反，动态语言在运行时才会执行。这有利有弊，JavaScript 给我们提供了强大的功能，比如：动态类型，延迟绑定，反射，函数式编程，对象运行时变更（object runtime alteration），闭包等等。 动态类型：变量不用定义类型。你可以为变量重新绑定任何类型，比如给一个已声明过的字符串变量绑定一个整型值。 弱类型：与强类型相反，弱类型语言不强制对象的类型。这使得操作更加灵活，但是我们也无法进行类型检查确保类型安全（TypeScript 和 Flow 旨在改善这个问题）。 解释型：JavaScript 通常被认为是一种解释型语言，这意味着在程序运行前不需要先编译，这恰恰与 C 语言，Java 或者是 Go 语言相反。事实上，出于性能考虑浏览器会在执行 JavaScript 之前进行编译，但是这一切都是自然而然发生的，不需要我们进行额外的操作。 多范型：JavaScript 不强制使用任何固定的编程范式，不像 Java 强制面向对象编程或者是 C 语言强制命令式编程。在 JavaScript 中，你可以使用原型和 ES6 中提供的 classes 语法面向对象编程，你也可以通过它的头等函数（first-class functions）编写函数式编程风格的代码，甚至以命令式编写程序（C-like）。 说明一下，JavaScript 和 Java 无关，这是一个不幸的命名选择，但是我们不得不接受现实。 JavaScript 版本让我介绍一下 ECMAScript。我们有一个专门介绍 ECMAScript 的完整指南，你可以在那里深入了解它，但现在，你只需要知道 ECMAScript（也被称作 ES）是 JavaScript 标准的名字。JavaScript 是对 ECMAScript 标准的一种实现，这也是为什么你会听到 ES6, ES2015, ES2016, ES2017, ES2018 等等。 很久以前，所有浏览器中运行的 JavaScript 版本基于 ECMAScipt 3。版本 4 因为特征蠕动（feature creep）被取消了（他们试图一次性添加很多特性）。虽然 ES5 是 JavaScript 的一个巨大版本，但是 ES2015（也被称作 ES6）也是 JavaScript 的重要更新。 从那时起，标准制定委员会决定每年更新一个版本，避免版本迭代间隔太久，也可以加快反馈速度。 现在，最新批准的 JavaScript 版本是 ES2017（译注：2018/11/10，最新版本是 ES2018）。 ECMASCRIPT无论何时你阅读关于 JavaScript 的内容时都无可避免的看到下面这些术语： ES3 ES5 ES6 ES7 ES8 ES2015 ES2016 ES2017 ECMAScript 2017 ECMAScript 2016 ECMAScript 2015 这些都是什么？他们都指 JavaScript 标准，被称作 ECMAScript。 ECMAScript 是 JavaScript 所基于的标准，经常被简称为 ES。 除了 JavaScript，实现了 ECMAScript 标准的还包括： ActionScript（Flash 脚本语言），自从官方决定从 2020 年起不再维护 Flash 便不再流行。 JScript（微软），一开始只有 Netscape 支持 JavaScript，浏览器大战愈演愈烈，微软便实现了仅 IE 浏览器支持的版本。 但是毫无疑问，JavaScript 仍是最普遍的 ES 实现。 为什么是这个奇怪的名字？Ecma International是瑞士标准协会，负责制定国际标准。 当 JavaScript 被创建时，它被 Netscape 和 Sun Microsystems 提交到 Ecma，命名为 ECMA-262，也叫做 ECMAScript。根据维基百科上的内容，Netscapte 和 Sun Microsystems（Java 制造商）联合发布的新闻稿可能会帮助了解如此命名的原因，其中可能包括微软在委员会里的法律和品牌问题。 IE9 之后，微软停止在浏览器中将 ES 实现称为 JScript，开始叫作 JavaScript（至少我不能任何引用）。 所以，从201x年起，唯一一个支持 ECMAScript 标准的流行语言就只有 JavaScript 了。 ECMAScript 最新版本目前 ECMAScript 版本是 ES2018，即 ES9，2018年六月发布。 下个版本什么时候发布？通常，JavaScript 会在每年夏天发布标准版本，所以我们可以在 2019 年夏天见到 ECMAScript 2019（即 ES2019 或者 ES10），但这一切只是猜测。 TC39 是什么TC39 是 JavaScript 发展委员会。 TC39 成员涉及 JavaScript 和浏览器供应商，包括火狐，谷歌，Facebook，Apple，微软，英特尔，PayPal，SalesForce 等等。 每一个标准版本的发布都必须通过不同阶段的提案。 ES 版本我发现 ES 版本有时候通过版本号指代，有时候通过年份，这会让人困惑。 在 ES2015 之前，ECMAScript 标准通常按照版本号命名，所以 ES5 是2009年更新的 ECMAScript 标准官方命名。 为什么会这样？在 ES2015 发布时，名字从 ES6 变成了 ES2015，但是为时已晚，人们仍然习惯性地称为 ES6，社区也没有抛弃这个名字 - 世界人民仍然按照版本号的方式指代 ES 版本。 这个表格可以帮助理清思路： 版本 官方名称 发布日期 ES9 ES2018 2018年6月 ES8 ES2017 2017年6月 ES7 ES2016 2016年6月 ES6 ES2015 2015年6月 ES5.1 ES5.1 2011年6月 ES5 ES5 2009年12月 ES4 ES4 废弃 ES3 ES3 1999年12月 ES2 ES2 1998年6月 ES1 ES1 1997年6月 ES.Next 始终指 JavaScript 未来版本。在撰写本文时，ES9 已经发布，ES.Next 是 ES10。 ES6 改进ECMAScript 2015，也即熟知的 ES6， 是 ECMAScript 标准的基础版本，距离上个版本 ECMAScript 5.1 发布有四年之久，也是从这个版本开始将版本改为以年命名。所以它不应该叫做 ES6（尽管每个人都这么叫），而是 ES2015。 ES5 从 1999 年到2009年花费了十年时间完善，尽管对于这个语言来讲，它也是一个重要版本，但是太长时间过去了，已经不值得我们讨论 ES5 之前的代码是如何工作的。 从 ES5.1 到 ES6，JavaScript 语言有了重要的新特性以及在更好的实践中的关键更新。要了解 ES2015 的基本功能，请参阅规范文档的250页到600页。 ES2015 中的重要更新包括： 箭头函数 Promises Generators let 和 const Classes Modules 多行字符串 模板字符串 参数默认值 扩展运算符 解构赋值 增强的对象字面量 for..of 循环 Map 和 Set 在这篇指南中，我将在每个章节中专门介绍它们。让我们开始吧！ 箭头函数箭头函数改变了大多数 JavaScript 代码的书写习惯和工作方式。 从视觉上来讲，它更简单了，也是受欢迎的改变，比如： 123const foo = function foo() &#123; // ...&#125; 变成： 123const foo = () =&gt; &#123; // ...&#125; 如果这个函数体只有一行，可以是这样： 1const foo = () =&gt; doSomething() 如果只有一个参数，可以是这样： 1const foo = param =&gt; doSomething(param) 和常规函数相比它没有带来任何不兼容变化，和以前一样工作。 新的 this 作用域箭头函数中的 this 从执行上下文继承。 在以前的常规函数中，this 通常指最近的函数。然而在箭头函数中这个问题没有了，你不再需要重写一遍 var that = this。 PromisesPromises 帮我们解决了著名的“回调地狱”问题，虽然它引入了更复杂的问题（在 ES2017 中可以通过更高级的构造函数 asnyc 解决 ）。 在 ES2015 之前，JavaScript 开发者就可以通过使用不同的库（jQuery，q，deferred.js，vow…）实现类似 Promises 的功能。该标准制定了更通用的方法。 通过使用 promises，你可以重构这个代码： 123456setTimeout(function() &#123; console.log('I promised to run after 1s') setTimeout(function() &#123; console.log('I promised to run after 2s') &#125;, 1000)&#125;, 1000) 等同于： 12345678const wait = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000)&#125;)wait().then(() =&gt; &#123; console.log('I promised to run after 1s') return wait()&#125;).then(() =&gt; console.log('I promised to run after 2s')) Generators生成器是一种特殊的函数，能够暂停输出，稍后恢复，而且允许其它代码在此期间运行。 代码本身决定了它必须等待，以便让其它代码“按照队列”顺序运行，而且保留了“当等待”完成时恢复操作的权利。所有的这些都通过一个简单的关键字 yield 来完成。当一个生成器包含该关键字，代码将暂停执行。生成器可以包含很多个 yield 关键字，因此可以暂停很多次，并且通过 *function 关键字标识，不要与 C 语言，C++ 或者 Go 等底层语言的指针反向引用操作符混淆。 在 JavaScript 中，生成器启用全新的编程范例，比如： 生成器运行中双向通信 持久的 while 循环，不会冻结程序 这里有个例子可以解释生成器是如何工作的： 12345function *calculator(input) &#123; var doubleThat = 2 * (yield (input / 2)) var another = yield (doubleThat) return (input * doubleThat * another)&#125; 初始化： 1const calc = calculator(10) 然后开始迭代生成器： 1calc.next() 第一次迭代，代码返回了 this 对象： 1234&#123; done: false value: 5&#125; 发生了什么：函数开始运行时，input = 10 作为参数传入了生成器的构造函数中，直到遇到 yield，返回了 yeild 的内容：input / 2 = 5。所以我们得到了一个值为 5，并且告诉我们迭代没有完成（仅仅是函数暂停了）。 在第二次迭代中，我们传入 7： 1calc.next(7) 然后我们会得到： 1234&#123; done: false value: 14&#125; 7 是 doubleThat 的值。 注意：你可能会认为 input / 2 是这个参数，但是它仅仅是第一次迭代的返回值，这次我们跳过了这一步，使用新的输入值 7 和 2 相乘。 我们继续第二次迭代，它返回了 doubleThat，值为 14。 下一个，最后一次迭代，我们传入100： 1calc.next(100) 返回： 1234&#123; done: true value: 14000&#125; 整个迭代结束（没有 yeild 关键字了），我们得到了 (input * doubleThat * another) 的值：10 * 14 * 100。 let 和 constvar 是传统的函数作用域。 let 是新的声明变量的方法，拥有块级作用域。这意味着在 for 循环中，if 语句内或者 plain 块中使用 let 声明的变量不会“逃出”所在的块，而 var变量则会被提升到函数定义。 const 和let相似，但是不可更改。 展望 JavaScript 的发展，var 声明会逐渐消失，只剩下 let 和 const。 更特别的是，由于不可变的特性，const 在今天已经出人意料的被广泛使用。 Classes传统上，JavaScript 是唯一基于原型继承的语言。从基于类继承的语言转向使用 JavaScript 的程序员会觉得困惑，但是 ES2015 引入了 classes，作为 JavaScript 内部实现继承的语法糖，它改变了我们编写 JavaScript 程序的方式。 现在，继承变得非常简单，和其他面向对象的编程语言类似： 123456789101112131415class Person &#123; constructor(name) &#123; this.name = name &#125; hello() &#123; return 'Hello, I am ' + this.name + '.' &#125;&#125;class Actor extends Person &#123; hello() &#123; return super.hello() + ' I am an actor.' &#125;&#125;var tomCruise = new Actor('Tom Cruise')tomCruise.hello() 上面的代码会打印出：“Hello, I am Tom Cruise. I am an actor.” Classes 没有显性的声明类变量，你必须在构造函数（constructor）中初始化变量。 ConstructorClasses 拥有一个特殊的方法 constructor，在使用 new 实例化类时被调用。 Super父类可以通过super()引用。 Getters 和 Setters可以像这样声明一个 getter 属性： 12345class Person &#123; get fullName() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;` &#125;&#125; 用同样的方式声明 setter 属性： 12345class Person &#123; set age(years) &#123; this.theAge = years &#125;&#125; 模块化ES2015 之前，至少有三个主要的模块化标准，这分裂了整个社区： AMD RequireJS CommonJS ES2015 制定了统一的模块化标准。 导入模块通过 import ... from ... 导入模块： 1234import * from 'mymodule'import React from 'react'import &#123; React, Component &#125; from 'react'import React as MyLibrary from 'react' 导出模块你可以使用关键字 export 将编写的模块内容导出到其它模块里： 12export var foo = 2export function bar() &#123; /* ... */ &#125; 模板字符串模板字符串是创建字符串的新方法： 1const aString = `A string` 使用 ${a_variable} 语法可以方便地将表达式的值插到字符串里： 12const var = 'test'const string = `something $&#123;var&#125;` //something test 你还可以执行更复杂的表达式，像这样： 12const string = `something $&#123;1 + 2 + 3&#125;`const string2 = `something $&#123;foo() ? 'x' : 'y' &#125;` 字符串可以是多行的： 1234const string3 = `Heythisstringis awesome!` 对比一下 ES2015 之前的多行字符串的写法： 123var str = 'One\n' +'Two\n' +'Three' 参数默认值函数现在支持使用默认参数值： 12const foo = function(index = 0, testing = true) &#123; /* ... */ &#125;foo() 扩展运算符你可以通过扩展运算符 ... 扩展数组，对象或者是字符串。 让我们用数组举个例子： 1const a = [1, 2, 3] 你可以这样创建一个新数组： 1const b = [...a, 4, 5, 6] 你可以复制一个数组： 1const c = [...a] 这对对象同样奏效，这样复制一个对象： 1const newObj = &#123; ...oldObj &#125; 对于字符串，扩展运算符会生成一个对应每个字符的数组： 12const hey = 'hey'const arrayized = [...hey] // ['h', 'e', 'y'] 这个运算符非常有用。最重要的就是可以以一种十分简单的方式为一个函数传递数组形式的参数： 123const f = (foo, bar) =&gt; &#123;&#125;const a = [1, 2]f(...a) 以前你可以使用 f.apply(null, a) 达到同样的效果，但是它不是很易读。 解构赋值给你一个对象，你可以抽出一些值把他们赋值给别的变量： 1234567const person = &#123; firstName: 'Tom', lastName: 'Cruise', actor: true, age: 54, //made up&#125;const &#123;firstName: name, age&#125; = person name 和 age 包含这些值。 这个语法也可以用在数组中： 12const a = [1,2,3,4,5][first, second, , , fifth] = a 加强的函数字面量ES2015 中函数字面量更加强大。 声明变量的简单语法以前： 1234const something = 'y'const x = &#123; something: something&#125; 现在你可以： 1234const something = 'y'const x = &#123; something&#125; 原型可以像这样为变量指定原型： 1234const anObject = &#123; y: 'y' &#125;const x = &#123; __proto__: anObject&#125; super()12345678const anObject = &#123; y: 'y', test: () =&gt; 'zoo' &#125;const x = &#123; __proto__: anObject, test() &#123; return super.test() + 'x' &#125;&#125;x.test() //zoox 动态属性1234const x = &#123; ['a' + '_' + 'b']: 'z'&#125;x.a_b //z for-of 循环2009年的 ES5 引入了 forEach() 循环。虽然很好，但是不能像 for 那样中途跳出循环。 ES2015 引入了 for-of 循环，结合了 forEach 的简洁和跳出循环的能力。 12345678//iterate over the valuefor (const v of ['a', 'b', 'c']) &#123; console.log(v);&#125;//get the index as well, using `entries()`for (const [i, v] of ['a', 'b', 'c'].entries()) &#123; console.log(i, v);&#125; Map 和 SetMap 和 Set（以及各自的弱引用类型 WeakMap 和 WeakSet）是官方实现的两种非常流行的数据结构（稍后介绍）。 ES2016 改进ES7，官方称作 ECMAScript 2016，2016年6月发布。 和 ES6 相比，ES7 是 JavaScript 的小版本更新，包括两个功能： Array.prototype.includes 指数运算符 Array.prototype.includes()这个功能引入了更易读的语法来检查一个数组是否包括一个元素。 在 ES6 以及更低版本中，检查一个元素是否在数组中你不得不使用 indexOf检查数组的索引，如果返回 -1 元素则不在数组中。 因为 -1 被认为是个真值，所以你无法判断下面这个例子： 123if (![1,2].indexOf(3)) &#123; console.log('Not found')&#125; 用 ES7 的新语法可以得到我们预期的结果： 123if (![1,2].includes(3)) &#123; console.log('Not found')&#125; 指数运算符指数运算符 ** 和 Math.pow() 一致，但是引入的是个语言特性，而不是一个库函数。 1Math.pow(4, 2) === 4 ** 2 这个功能是 Math 密集型 JavaScript 应用很好的补充。** 运算符在很多语言中都已经标准化，比如 Python，Ruby，MATLAB，Lua，Perl 等等。 ES2017 改进ECMAScript 2017，ECMA-262 标准的第八版（称作 ES2017 或者 ES8），2017年6月发布。 和 ES6 相比，ES8 仍然带来了很多有用的功能： String padding Object.values Object.entries Object.getOwnPropertyDescriptors() 函数参数尾逗号 异步函数 Shared memory and atomics String paddingString padding 的目的是为一个字符串添加字符，让它可以和声明的长度一致。 ES2017 引入了两个 String 上的方法：padStart() 和 padEnd()。 12padStart(targetLength [, padString])padEnd(targetLength [, padString]) 例子： padStart() 输出 ‘test’.padStart(4) ‘test’ ‘test’.padStart(5) ‘&nbsp;test’ ‘test’.padStart(8) ‘&nbsp;&nbsp;&nbsp;&nbsp;test’ ‘test’.padStart(8, ‘abcd’) ‘abcdtest’ padEnd() 输出 ‘test’.padEnd(4) ‘test’ ‘test’.padEnd(5) ‘test&nbsp;’ ‘test’.padEnd(8) ‘test&nbsp;&nbsp;&nbsp;&nbsp;’ ‘test’.padEnd(8, ‘abcd’) ‘testabcd’ Object.values()这个方法返回一个包含对象自身属性值的数组。用法： 12const person = &#123; name: 'Fred', age: 87 &#125;Object.values(person) // ['Fred', 87] Object.values() 也可以用于数组： 12const people = ['Fred', 'Tony']Object.values(people) // ['Fred', 'Tony'] Object.entries()这个方法返回一个 [key, value] 形式的包含对象自身所有属性及值的数组。用法： 12const person = &#123; name: 'Fred', age: 87 &#125;Object.entries(person) // [['name', 'Fred'], ['age', 87]] Object.entries() 也可以用于数组： 12const people = ['Fred', 'Tony']Object.entries(people) // [['0', 'Fred'], ['1', 'Tony']] getOwnPropertyDescriptors()这个方法返回对象自身的所有描述符（非继承）。 JavaScript 中的所有对象都有一个属性集合，每个属性都有一个描述符。 描述符是属性的 attribute 集合，它包括下面这些子集： value：属性的值 writable：为 true 时属性可以重写 get：属性的 getter 函数，当读取属性时被调用 set：属性的 setter 函数，当设置属性值时被调用 configurable：如果为 false，属性不能被删除，而且不能更改所有的 attribute 值，属性自身的值除外 enumerable：为 true 时属性可枚举 Object.getOwnPropertyDescriptors(obj) 接受对象作为参数，返回一个包含描述符的对象。 这有什么用？ES2015 给我们带来了 Object.assign()，方便我们复制一个或多个对象自身的可枚举属性，返回一个新对象。 然而这样操作有个问题，它无法正确复制没有默认 attributes 的属性。举个例子，如果一个对象只有一个 setter，就不能用 Object.assign() 正确复制它。 12345const person1 = &#123; set name(newName) &#123; console.log(newName) &#125;&#125; 这样不会工作： 12const person2 = &#123;&#125;Object.assign(person2, person1) 但是这样可以： 123const person3 = &#123;&#125;Object.defineProperties(person3,Object.getOwnPropertyDescriptors(person1)) 你可以通过控制台简单测试一下： 123456person1.name = 'x'"x"person2.name = 'x'person3.name = 'x'"x" person2 没有 setter，它不能被正确复制。 使用 Object.create() 对对象浅克隆也有同样的限制。 尾后逗号这个功能允许在函数声明和函数调用中使用尾后逗号： 1234const doSomething = (var1, var2,) =&gt; &#123; //...&#125;doSomething('test2', 'test2',) 这个改变将鼓励开发者停止使用丑陋的“行首逗号”的习惯。 异步函数ES2017 引入了异步函数的概念，它也是这个 ECMAScript 版本里最重要的变化。 异步函数结合了 promises 和 generators 以减少 promises 带来的样板风格和 promises 链的“不要打破调用链”限制。 为什么他们很有用它是对 promises 函数的高级抽象。 当 ES2015 里引入 Promises 的时候，这个功能致力于解决异步代码的问题。但是在 ES2015 到 ES2017 发布的两年里，人们清楚的认识到这不是解决问题的最终方法。 引入 Promises 用来解决著名的回调地狱问题，但是也带来了自身的复杂性，加大了语法的复杂程度。他们是很好的开端，在这个基础上可以让开发者使用更好的语法：那就是异步函数。 一个简短的例子使用异步函数的代码可以像这样： 1234567891011function doSomethingAsync() &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125;async function doSomething() &#123; console.log(await doSomethingAsync())&#125;console.log('Before')doSomething()console.log('After') 上面的代码会在浏览器控制台里打印出： 123BeforeAfterI did something //after 3s 串联多个异步函数链式调用异步函数很简单，而且比原始的 promises 更易读： 12345678910111213141516function promiseToDoSomething() &#123; return new Promise((resolve)=&gt;&#123; setTimeout(() =&gt; resolve('I did something'), 10000) &#125;)&#125;async function watchOverSomeoneDoingSomething() &#123; const something = await promiseToDoSomething() return something + ' and I watched'&#125;async function watchOverSomeoneWatchingSomeoneDoingSomething() &#123; const something = await watchOverSomeoneDoingSomething() return something + ' and I watched as well'&#125;watchOverSomeoneWatchingSomeoneDoingSomething().then((res) =&gt; &#123; console.log(res)&#125;) 共享内存和原子WebWorkers 用来在浏览器里构建多线程程序。 他们通过事件（events）提供一种通信协议。从 ES2017 开始，你可以通过 SharedArrayBuffer 在 web workers 和他们的构造者中间创建一个共享内存数组。 由于我们不知道写入一个共享内存的传递部分需要多长事件，因此原子（Atomics）是一种在读取值时执行操作的方法，并且完成了所有类型的写入操作。 更多内容可以在这个提案中找到，该提案已经被实现。 ES2018 改进ES2018 是最新的 ECMAScript 标准。 它引入了什么新东西呢？ Rest/Spread 属性ES6 引入了针对数组解构的剩余元素： 12const numbers = [1, 2, 3, 4, 5][first, second, ...others] = numbers 和扩展元素： 123const numbers = [1, 2, 3, 4, 5]const sum = (a, b, c, d, e) =&gt; a + b + c + d + econst sum = sum(...numbers) // 勘误：此处不能对 sum 重新赋值，感谢 [森蓝情丶](https://juejin.im/user/59c8ea816fb9a00a4746e258) ES2018 为对象带来了同样的功能。 剩余属性： 1234const &#123; first, second, ...others &#125; = &#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;first // 1second // 2others // &#123; third: 3, fourth: 4, fifth: 5 &#125; 扩展属性允许通过组合在spread运算符之后传递的对象的属性来创建新对象： 12const items = &#123; first, second, ...others &#125;items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125; 异步迭代新的构造函数 for-await-of 允许你使用异步可迭代对象作为循环迭代： 123for await (const line of readLines(filePath)) &#123; console.log(line)&#125; 因为这里用了 await ，所以你只能在 async 函数内部使用它，就像一个普通的 await（参考 async/await）。 Promise.prototype.finally()当一个 promise 完成（fulfilled），它会一个接一个的调用 then() 方法。如果在这个过程中出现了任何错误，then() 方法会被跳过，进而执行 catch() 方法。 无论 promise 执行成功还是失败，finally() 都会运行其中的代码： 1234fetch('file.json') .then(data =&gt; data.json()) .catch(error =&gt; console.error(error)) .finally(() =&gt; console.log('finished')) 正则表达式改进RegExp 后行断言：根据前面的内容匹配字符串。 这是一个先行断言：使用 ?= 匹配特定的子字符串： 123/Roger(?=Waters)//Roger(?= Waters)/.test('Roger is my dog') //false/Roger(?= Waters)/.test('Roger is my dog and Roger Waters is a famous musician') //true ?! 执行相反的操作，匹配字符串后面没有特定的子字符串： 123/Roger(?!Waters)//Roger(?! Waters)/.test('Roger is my dog') //true/Roger(?! Waters)/.test('Roger Waters is a famous musician') //false 先行断言使用 ?= 标识符，它已经可用了。 后行断言，新功能，使用 ?&lt;=。 123/(?&lt;=Roger) Waters//(?&lt;=Roger) Waters/.test('Pink Waters is my dog') //false/(?&lt;=Roger) Waters/.test('Roger is my dog and Roger Waters is a famous musician') //true 使用 ?&lt;! 否定后行断言： 123/(?&lt;!Roger) Waters//(?&lt;!Roger) Waters/.test('Pink Waters is my dog') //true/(?&lt;!Roger) Waters/.test('Roger is my dog and Roger Waters is a famous musician') //false Unicode 属性转义 \p{…} 和 \P{…}在一个正则表达式里，你可以使用 \d 匹配任意数字， \s 匹配不包括空格的任意字符，\w 匹配任意字母数字字符等等。 这个新功能通过引入 \p{} 和 \P{} 将此概念扩展到所有 Unicode 字符。 任何 unicode 字符都有一组特定的属性。举个例子，Script 决定了语言家族，ASCII 是 ASCII 字符串 true 的布尔值，等等。你可以把这个特性放到大括号中，正则表达式会检查是否为真： 123/^\p&#123;ASCII&#125;+$/u.test('abc') //✅/^\p&#123;ASCII&#125;+$/u.test('ABC@') //✅/^\p&#123;ASCII&#125;+$/u.test('ABC🙃') //❌ ASCII_Hex_Digit 是另一个布尔属性，它会检查字符串是否包含有效的十六进制数字： 12/^\p&#123;ASCII_Hex_Digit&#125;+$/u.test('0123456789ABCDEF') //✅/^\p&#123;ASCII_Hex_Digit&#125;+$/u.test('h') //❌ 还有很多布尔属性，你只用把他们的名字放在大括号中就可以用了，比如：Uppercase, Lowercase, White_Space, Alphabatic, Emoji 等等： 1234/^\p&#123;Lowercase&#125;$/u.test('h') //✅/^\p&#123;Uppercase&#125;$/u.test('H') //✅/^\p&#123;Emoji&#125;+$/u.test('H') //❌/^\p&#123;Emoji&#125;+$/u.test('🙃🙃') //✅ 除了这些二进制属性之外，你还可以检查任意 unicode 字符是否匹配特定的值。在这个例子中，我检查了字符串是希腊语还是拉丁字母： 12/^\p&#123;Script=Greek&#125;+$/u.test('ελληνικά') //✅/^\p&#123;Script=Latin&#125;+$/u.test('hey') //✅ 了解更多内容可以阅读提案。 命名捕获组在 ES2018 里匹配到的组可以绑定一个名字，而不是仅在结果数组中绑定一个插槽： 12345const re = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/const result = re.exec('2015-01-02')// result.groups.year === '2015';// result.groups.month === '01';// result.groups.day === '02'; 正则表达式 ‘s’s 是单行的缩写，可以和 . 一起匹配新行，没有它，点标识符不会匹配新行： 12/hi.welcome/.test('hi\nwelcome') // false/hi.welcome/s.test('hi\nwelcome') // true 编程风格JavaScript 编程风格是编写 JavaScript 时的一系列规范。 编程风格是你和你的团队达成的协议，用来保证项目的一致性。如果你没有团队，那么它就是你自己的协定，应该始终保证你的代码符合你的标准。 对代码编写格式有固定的规则有很大的好处，可以使代码更易读和更易管理。 流行的风格指南在 JavaScript 里有很多风格指南，其中有两个最为常见的： The Google JavaScript Style Guide The AirBnb JavaScript Style Guide 你可以选择使用其中一种或者制定自己的代码风格。 和你的项目保持一致的风格即使你有自己更喜欢的代码风格，在团队协作中你也要遵守团队项目风格。 Github 上的每个开源项目都可能会有一系列规则，你参与的另一个项目可能会有完全不同的规则。 Prettier 是格式代码的强大工具，你应该试试它。 本指南使用的规则我们一直使用最新的 ES 版本，在旧版浏览器中使用 Babel。 缩进：用空格代替 tabs，缩进两个空格。 分号：不要使用分号。 每行长度：如果可能，尽力保证每行不超过 80 个字符。 行内注释：在代码里使用行内注释，只在文件里使用块级注释。 不要有无用代码：不要留下旧代码，“仅仅以防万一”它将来还有用。保证只有现在需要的代码，版本控制或者你的笔记应用就是为此而生的。 只在需要时注释：不要添加不能帮助理解的注释。如果代码自身有良好的变量、函数命名和 JSDoc 函数注释，不要添加注释。 变量声明：避免污染全局变量，永远不要使用 var。默认使用 const，只在需要重绑定变量时使用 let。 常量：用大写字母声明所有常量，用 _ 分割 VARIABLE_NAME。 函数：使用箭头函数，除非你有使用常规函数的理由，比如在对象方法或者构造函数中，需要确定 this 的指向。用 const 声明函数，并在可能的情况使用隐式返回。使用嵌套函数隐藏助手函数的多余代码会让你觉得无拘无束。 12const test = (a, b) =&gt; a + bconst another = a =&gt; a + 2 名字：函数命，变量名和方法名以小写字母开始（除非他们是私有且只读的）的驼峰命名，只有构造函数和类名应该以大写字母开始。如果你使用一个有特定规范的框架，根据要求改变你的习惯。文件名应该全部小写，用 - 分割。 特定语句格式和规则： if 123456789101112131415if (condition) &#123; statements&#125;if (condition) &#123; statements&#125; else &#123; statements&#125;if (condition) &#123; statements&#125; else if (condition) &#123; statements&#125; else &#123; statements&#125; for：始终在初始化时缓存遍历对象的长度，不要把它插入到条件语句中。避免使用 for in 表达式，除了和 .hasOwnProperty() 配合使用，首选 for of： 123for (initialization; condition; update) &#123; statements&#125; while 123while (condition) &#123; statements&#125; do 123do &#123; statements&#125; while (condition); switch 123456switch (expression) &#123; case expression: statements default: statements&#125; try 123456789101112try &#123; statements&#125; catch (variable) &#123; statements&#125;try &#123; statements&#125; catch (variable) &#123; statements&#125; finally &#123; statements&#125; 空格：机智的通过空格改善代码可读性：在关键字和 ( 中插入一个空格；在二进制运算符（+, -, / ,*, &amp;&amp; …）前面和后面插入一个空格；在语句内，每个 ; 后插入一个空格将每个语句分开；在每个 , 后插入一个空格。 新行：使用新行分隔执行逻辑相关操作的代码块。 引号：使用单引号 &#39; 代替双引号 &quot;。双引号是 HTML 的标准属性，所以使用单引号避免在处理 HTML 字符串时可能遇到的问题。适当时使用模板字符串而不是变量插值。 词汇结构现在我们将深入探讨JavaScript的构建模块：unicode，分号，空格，大小写敏感，注释，字面量，标识符和保留字。 UnicodeJavaScript 用 Unicode 编写。这意味着你可以用 Emojis 作为变量名。😃 😧 😲 更重要的是，你可以用任何语言书写标识符，比如日文或者中文，相关规则。 分号JavaScript 语法和 C 语言类似，你可能会在很多示例代码里看到每行代码末尾都有分号。 分号不是强制性的，JavaScript 不使用分号没有任何问题。现在很多开发者，特别是从不需要分号的语言转过来的那部分开始避免使用分号。 你只需要避免一些奇怪的做法，比如将语句分割成多行： 12returnvariable 或者是在一行前以（[ 或者 (）开头。这样你在 99.9% 的时间里都是安全的（你的 linter 也会警告你）。 这取决于个人喜好，最近我决定再也不加无用的分号，所以在这篇文章里你看不到任何分号。 空格JavaScript 不认为空格有意义。空格和断行可以凭你的喜好添加，即使理论上是可行的。 在实践中，你很可能遵守良好的风格和人们习以为常的规则，强制使用 linter 或者 Prettier 这样的风格工具。 比如，我喜欢缩进两个字符。 大小写敏感JavaScript 是大小写敏感的。变量 something 和 Somethin 是不同的。这在任何标识符里都是一致的。 注释在 JavaScript 里，有两种注释方式： 12/* */// 第一个可以进行多行注释并且需要闭合。 第二个会注释掉当前行位于其右侧的所有内容。 字面量和标识符我们将源码里的值定义为字面量，例如数字，字符串，布尔值或者更高级的构造，像对象字面量或者数组字面量： 123455'Test'true['a', 'b']&#123;color: 'red', shape: 'Rectangle'&#125; 一个标识符可以用来识别一个变量，一个函数，一个对象。它可以用一个美元符号 $或者一个下划线 _ 开头，它也可以包含数字。使用 Unicode，字母可以是任何被允许的字符，比如 emoji :smile:。 123456TesttestTEST_testTest1$test 美元符号通常被用来区分 DOM 元素。 保留字你不能使用下列标识符，因为他们是语言保留字。 123456789101112131415161718192021222324252627282930313233343536373839404142breakdoinstanceoftypeofcaseelsenewvarcatchfinallyreturnvoidcontinueforswitchwhiledebuggerfunctionthiswithdefaultifthrowdeleteintryclassenumextendssuperconstexportimportimplementsletprivatepublicinterfacepackageprotectedstaticyield 变量变量是一个标识符绑定了一个字面量，所以你可以在后续的代码里引用和使用它。我们将会学习如果在 JavaScript 里声明一个变量。 介绍 JavaScript 变量变量是一个标识符绑定了一个字面量，所以你可以在后续的代码里引用和使用它。在 JavaScript 里，变量没有绑定任何类型。即使你为一个变量绑定了一个特定的类型，你也可以在后面重新绑定其它任何类型，这不会造成类型错误或者其它问题。 这也是为什么有时候提到 JavaScript 会被认为是 “无类型的”。 变量必须在你用到之前声明。有三种声明方法：使用 var, let 或者 const。这三种方式的不同在于后续你如何和这个变量进行交互。 使用 var直到 ES2015, var 是定义变量的唯一方法。 1var a = 0 如果你忘了加 var，你将给未声明的变量绑定值，这个结果可能会有不同：在现代环境里，开启严格模式，这样会报错。在旧环境里（或者关闭严格模式），这样会初始化一个变量并把它绑定到全局对象。 如果你声明变量时没有初始化，它会获得一个 undefined 值直到你为它绑定一个值。 1var a //typeof a === 'undefined' 你可以重复声明同一个变量，重写它的值： 12var a = 1var a = 2 你可以一次性声明多个变量： 1var a = 1, b = 2 代码的作用域是变量可见的范围。 在任何函数外部通过 var 初始化的变量会绑定到全局对象，拥有全局作用域，在任何位置都可用。在函数内部通过 var 初始化的变量会绑定在这个函数内，仅在函数内部可用，就和函数的参数一样。 重要的是要了解一个块（用一对花括号区分）没有定义一个新的作用域。新作用域只会随着函数的创建被创建，因为 var 没有块级作用域，只有函数作用域。 在函数内部，其中定义的任何变量在函数代码里都是可见的，即使是定义在尾部的变量也会在函数头部被引入，这是因为 JavaScript 会自动将所有变量移动到顶部（即变量提升）。为了避免造成困扰，始终在函数头部声明变量。 使用 letlet 是 ES2015 里引入的新特性，本质上是拥有块级作用域的 var。他的作用域被限制在定义它的块，语句或者表达式，以及所有包含的内部块。 现代 JavaScript 开发者可能会只用 let 而完全放弃使用 var。 如果 let 看起来是个模糊的术语，就看看 let color = &#39;red&#39;，让颜色变成红色，这样容易明白得多。 在函数外部使用 let，和 var 相反，没有创建一个全局变量。 使用 const用 var 或者 let 声明的变量可以在后面进行更改和重绑定。一旦 const 被初始化，它的值将不能被修改，也不能绑定其它的值。 1const a = 'test' 我们不能为 a 绑定不同的值。然而，如果 a 是一个提供改变其内容的方法的对象，我们仍然可以改变它。 const 不提供不变性，只能确保不会更改引用。 const 和 let 一样，提供块级作用域。 现在 JavaScript 开发者可能会选择 const 作为声明将来不需要重新绑定的变量的标识符。 为什么？因为我们应该始终使用最简单的构造变量避免发生错误。 类型有时你会读到 JS 是无类型的，但是这是不正确的。你可以为一个变量绑定不同的类型是确实存在的，但是 JavaScript 是有类型的。它提供了基本类型和对象类型。 基本类型原始类型有： Numbers Strings Booleans 还有两个特别类型： null undefined 让我们在下个章节深入了解他们。 Numbers在语言内部，JavaScript 只有一种数字类型：所有数字都是浮点型。 一个数字字面量是源码里表示的数字，amd 取决于它的编写方式，它可以是整型字面量或者是浮点型字面量。 整型： 1231053545767673210xCC //hex 浮点型： 1233.14.12345.2e4 //5.2 * 10^4 strings字符串类型是一系列字符。在源码里，它被定义成字符串字面量，用单引号或者双引号包裹。 12'A string'"Another string" 字符串可以通过反斜杠跨越多行： 12"A \string" 字符串可以包含转义序列，在打印字符串时解释，例如 \n 用来换行。当你需要防止字符被误解为闭合引号时，反斜杠也很有用： 1'I\'m a developer' 字符串可以用 + 操作符拼接： 1"A " + "string" 模板字符串在 ES2015 引入，模板字符串允许用更强大的方法定义一个字符串字面量。 1`a string` 你可以嵌入任何 JavaScript 表达式并替换执行后的结果： 123`a string with $&#123;something&#125;``a string with $&#123;something+somethingElse&#125;``a string with $&#123;obj.something()&#125;` 你可以很容易的获得多行字符串： 123`a stringwith$&#123;something&#125;` Booleans对于布尔型，JavaScript 有两个保留字：true 和 false。大多数比较运算符 == === &gt; &lt; 等等都返回其中的一个。 if，while 语句和其它控制结构使用布尔值决定程序的流程。 他们不仅接受 true 和 fasle，也会接受 truthy 和 falsy 的值。 Falsy，值被解释为 false： 1234560-0NaNundefinednull'' //empty string 其余的都属于 truthy。 nullnull 是一个特殊值，表示没有值。这在其它语言里也是普遍的观念，比如 nil 或者 Python 里的 None。 undefinedundefined 表示变量还没有初始化，值为空。 函数里没有 return 值时就会返回 undefined。当函数参数没有被调用者赋值时，也是 undefined。 检测一个值是否为 undefined，你可以用这个方法： 1typeof variable === 'undefined' 对象类型所有不是基本类型的都是对象类型。 函数，数组和我们叫做对象的都是对象类型。它们本身是特殊的，但是它们继承了 objects 的很多特性，比如具有特性和使特性生效的方法。 表达式表达式是可以执行并解析为值的代码单元。JS 中的表达式可以分为几类。 算术表达式这个分类下所有表达式对数字进行求值： 12341 / 2i++i -= 2i * 2 字符串表达式对字符串求值： 12'A ' + 'string''A ' += 'string' 原始表达式这个分类下，是变量引用，字面量和常量： 1234567820.02'something'truefalsethis //the current objectundefinedi //where i is a variable or a constant 也有一些语言关键字： 123456789functionclassfunction* //the generator functionyield //the generator pauser/resumeryield* //delegate to another generator or iteratorasync function* //async function expressionawait //async function pause/resume/wait for completion/pattern/i //regex() // grouping 数组和对象初始表达式12345[] //array literal&#123;&#125; //object literal[1,2,3]&#123;a: 1, b: 2&#125;&#123;a: &#123;b: 1&#125;&#125; 逻辑表达式逻辑表达式使用逻辑运算符，获得一个布尔值： 123a &amp;&amp; ba || b!a Left-hand-side 表达式123new //create an instance of a constructorsuper //calls the parent constructor...obj //expression using the spread operator 属性访问表达式123object.property //reference a property (or method) of an objectobject[property]object['property'] 对象构造表达式123new object()new a(1)new MyRectangle('name', 2, &#123;a: 4&#125;) 函数定义表达式12345function() &#123;&#125;function(a, b) &#123; return a * b &#125;(a, b) =&gt; a * ba =&gt; a * 2() =&gt; &#123; return 2 &#125; 调用表达式12a.x(2)window.resize() 原型继承JavaScript 在流行编程语言领域是一个非常独特的存在，原因在于对原型继承的使用。让我们看看这是什么意思。 大多数面向对象语言都是基于类继承模式，JavaScript 基于原型继承。 这是什么意思？ 每一个 JavaScript 对象都有一个特性，称作 prototype，指向不同的对象。 这个不同的对象就是原型对象。 我们的对象会继承原型对象的特性和方法。 假设你通过对象字面量语法创建了一个对象： 1const car = &#123;&#125; 或者通过 new Object 创建： 1const car = new Object() 无论哪一种方法，car 的原型都是 Object。 初始化一个数组，也是一个对象： 123const list = []//orconst list = new Array() 这个的原型是 Array。 你可以通过 __proto__ 属性验证： 12345car.__proto__ == Object.prototype //truecar.__proto__ == new Object().__proto__ //truelist.__proto__ == Object.prototype //falselist.__proto__ == Array.prototype //truelist.__proto__ == new Array().__proto__ //true 这里的 __proto__ 属性不是标准的但是在浏览器里被广泛实现。一个更可靠的获得原型的方法是 Object.getPrototypeOf(new Object())。 原型上所有的特性和方法在具有该原型的对象上都是可用的： Object.prototype 是所有对象的原型。 1Array.prototype.__proto__ == Object.prototype 如果你想知道 Object.prototype 的原型是什么，它没有原型。这是一片特殊的雪花。❄️ 上面的例子是原型链的示例。 我可以创建一个扩展 Array 和任何实例化对象的对象，这个对象的原型链上会有 Array 和 Object，它会继承所有祖先的特性和方法。 除了用 new 创建一个对象，或者用对象和数组的字面量语法，你还可以用 Object.create() 实例化一个对象。 第一个参数作为对象的原型： 12const car = Object.create(&#123;&#125;)const list = Object.create(Array) 你可以用 isPrototypeOf() 方法检查这个对象的原型： 1Array.isPrototypeOf(list) //true 注意，因为你可以这样实例化数组： 1const list = Object.create(Array.prototype) 因此，Array.isPrototypeOf(list) 等于 false，而 Array.prototype.isPrototypeOf(list) 等于 true。 类在 2015 年发布的 ECMAScript 6 (ES6) 标准引入了类。 在那之前，JavaScript 只能通过一个十分奇怪的方法实现继承。那就是原型继承，我认为这很神奇，和其它的流行语言都不同。 从 Java 或者 Python 或者其它语言来的人们很难理解原型继承的复杂性，因此，ECMAScript 委员会决定基于此引入语法糖，类似于其它语言的实现方法。 这很重要：JavaScript 底层仍然和之前一样，你可以以一种普适的方法访问原型对象。 定义类类看起来是这样： 12345678class Person &#123; constructor(name) &#123; this.name = name &#125; hello() &#123; return 'Hello, I am ' + this.name + '.' &#125;&#125; 类有一个标识符，可以让我们通过 new ClassIdentifier() 创建一个新对象。 当这个对象被实例化，会调用 constructor 方法，可以传递任何参数。 一个类可以有很多方法，在这个例子中 hello 是一个方法，所有从这个类派生的对象都可以调用它： 12const flavio = new Person('Flavio')flavio.hello() 类继承类可以扩展另一个类，使用该类初始化的对象继承这两个类的所有方法。 如果继承的类和更高一级的类有同名的方法，则按最近优先的原则调用： 1234567class Programmer extends Person &#123; hello() &#123; return super.hello() + ' I am a programmer.' &#125;&#125;const flavio = new Programmer('Flavio')flavio.hello() 上面的程序会打印出：“Hello, I am Flavio. I am a programmer.”。 类没有显式地声明变量，但是必须要在构造函数中初始化变量。 在类中，你可以通过调用 super() 引入父类。 静态方法通常来讲，方法定义在实例上，而不是类上。 而静态方法能在类上执行： 123456class Person &#123; static genericHello() &#123; return 'Hello' &#125;&#125;Person.genericHello() //Hello 私有方法JavaScript 没有内置定义私有方法或者保护方法的手段。有解决方法，但是这里将不再赘述。 Getters 和 Setters你可以添加 get 或者 set 前缀创建一个 getter 和 setter，用哪一种方法取决于你想做什么：访问变量或者修改变量的值。 1234567891011class Person &#123; constructor(name) &#123; this.name = name &#125; set name(value) &#123; this.name = value &#125; get name() &#123; return this.name &#125;&#125; 如果属性只有一个 getter，这个属性就不能被设置，所有的修改都会被忽略： 12345678class Person &#123; constructor(name) &#123; this.name = name &#125; get name() &#123; return this.name &#125;&#125; 如果属性只有一个 setter，你可以随意修改它的值，但是不能从外部访问它： 12345678class Person &#123; constructor(name) &#123; this.name = name &#125; set name(value) &#123; this.name = value &#125;&#125; 异常当代码发生意外错误时，JavaScript 习惯通过 exceptions 处理错误。 创建异常通过关键字 throw 创建异常： 1throw value value 可以是任意的 JavaScript 值，包括字符串，数字或者一个对象。 当 JavaScript 代码执行到这一行，就会暂停正常的程序流程，控制会跳转到最近的异常处理器。 处理异常异常处理器是 try/catch 语句。 try 代码块内抛出的异常都会在相应的 catch 中处理： 12345try &#123; //lines of code&#125; catch (e) &#123; &#125; 在这个例子中，e 代表异常值。 你可以添加多个处理器，它们可以捕捉不同的错误。 finally为了完成整个代码语句，JavaScript 有另一个语句，finally，不管程序流程如何，异常是否被处理，是否产生异常，其中的代码都会执行： 1234567try &#123; //lines of code&#125; catch (e) &#123; &#125; finally &#123; &#125; 你也可以在没有 catch 的情况下使用 finally，以清除可能在 try中打开的任何资源，比如文件或者网络请求： 1234try &#123; //lines of code&#125; finally &#123;&#125; 嵌套 try 代码块try 可以被嵌套使用，异常始终在最近的 catch 块中被处理： 12345678910try &#123; //lines of code try &#123; //other lines of code &#125; finally &#123; //other lines of code &#125;&#125; catch (e) &#123; &#125; 如果在内部的 try中发现异常，它会在外部的 catch中被处理。 分号JavaScript 分号是可选的，我个人倾向于不写分号，但是很多人喜欢带上分号。 分号在 JavaScript 社区中产生了很大的分歧。一些人不论在什么情况都很喜欢用它，而另一部分则相反。 在用了几年分号之后，2017 年秋天我决定尝试避免使用分号，我通过 Prettier 自动移除代码中的分号，除非有特定的代码构造需要它。 现在我很自然就会避免分号，我认为代码看起来更优秀，也更易读了。 因为 JavaScript 不强制要求使用分号，所以万事皆有可能。当一个位置需要分号，它会自动添加。 执行此操作的过程成为自动插入分号。 了解使用分号的规则非常重要，可以避免编写与预期行为不一致的错误代码。 JavaScript 自动插入分号规则在解释源码期间，发现一下特定情况，JavaScript 解释器会自动添加分号： 当下一行的起始代码打断了当前行（代码可能是多行的） 当下一行代码以 } 开头，闭合了当前代码块 当执行到源代码末尾 当前行有 return 语句 当前行有 break 语句 当前行有 throw 语句 当前行有 continue 语句 代码行为不一致的例子基于上面的规则，这有一些其它例子，比如： 1234const hey = 'hey'const you = 'hey'const heyYou = hey + ' ' + you['h', 'e', 'y'].forEach((letter) =&gt; console.log(letter)) 你会看到错误 Uncaught TypeError: Cannot read property &#39;forEach&#39; of undefined，因为规则 1 尝试把代码解释为： 123const hey = 'hey';const you = 'hey';const heyYou = hey + ' ' + you['h', 'e', 'y'].forEach((letter) =&gt; console.log(letter)) 还有： 1(1 + 2).toString() // 3 1234const a = 1const b = 2const c = a + b(a + b).toString() 相反，上面的代码抛出 TypeError: b is not a function 异常，因为 JavaScript 尝试把它解释为： 123const a = 1const b = 2const c = a + b(a + b).toString() 另一个关于规则 4 的例子： 123456(() =&gt; &#123; return &#123; color: 'white' &#125;&#125;)() 你希望这个立即执行函数可以返回一个包含 color 属性的对象，但是没有。它返回的是 undefined，因为 JavaScript 会在 return 后插入一个分号。 正确的做法是把花括号放在 return 的后面： 12345(() =&gt; &#123; return &#123; color: 'white' &#125;&#125;)() 你认为这个代码会弹出 0： 121 + 1-1 + 1 === 0 ? alert(0) : alert(2) 但是它显示的是 2，因为规则 1 把它解释成： 11 + 1 -1 + 1 === 0 ? alert(0) : alert(2) 小心点。有些人对待分号很偏执，我是无所谓，这个工具既然给了我们不用分号的选项，我们就应该避免使用分号。我不是在推荐什么，你自己选择。 我们只需要稍微注意一些特殊情况，即使这些很少会出现在你的代码中。 记住这些规则： 小心使用 return 语句。如果你想返回一些东西，应该和 return 放在同一行（break, throw, continue 同理） 永远不要用圆括号开头，这可能会和上一行连接形成函数调用或者数组元素引用 最后，始终测试你的代码，确保它是你想要的。 引号现在我们将谈谈 JavaScript 里的引号和特殊的功能。 JavaScript 允许三种形式的引号： 单引号 双引号 反引号 前两种差不多： 12const test = 'test'const bike = "bike" 使用其中一种没有什么大的差别。唯一的不同在于必须转移用于分隔字符串的引号字符： 12345const test = 'test'const test = 'te\'st'const test = 'te"st'const test = "te\"st"const test = "te'st" 有很多不同的风格指南，建议始终使用其中一种。 我个人一直都用单引号，只在 HTML 中使用双引号。 反引号是另一个选项，在 2015 年的 ES6 中引入。 它们都有一个特殊的功能 - 允许多行字符串。 多行字符串可能是常规字符串加上转义字符： 1const multilineString = 'A string\non multiple lines' 使用反引号（键盘左上角的数字 1 键），你可以不用转义字符： 12const multilineString = `A stringon multiple lines` 不仅如此。你可以用 ${} 解析变量： 12const multilineString = `A stringon $&#123;1+1&#125; lines` 这也叫做模板字符串。 模板字符串ES2015，即ES6引入，模板字符串提供了一个新的方式展示字符串，一些新的有趣的构造已经被广泛使用。 与 ES5 及更低版本相比，模板字符串作为 ES2015/ES6 的功能允许你用更新颖的方式处理字符串。 乍一看，反引号语法和单引号，双引号相比很简单： 1const a_string = `something` 它们和普通的字符串相比提供了更多的功能，特别是： 提供了优秀的语法定义多行字符串 提供了简单的方式解释字符串中的变量和表达式 允许通过模板标签创建 DSLs 让我们仔细看看这些功能。 多行字符串在 ES6 之前，创建多行字符串需要在每行行尾添加 \ 字符： 12const string = 'first part \second part' 这样看是两行字符串，但是渲染时会变成一行： 1"first part second part" 为了能够渲染多行字符串，你需要在每行末尾添加 \n： 12const string = 'first line\n \second line' 或者 12const string = 'first line\n' + 'second line' 模板字符串使创建多行字符串变得很简单： 使用反引号开始多行字符串，你只用按下回车键就能创建一个新行，不用什么特别的字符，像这样： 12345const string = `Heythisstringis awesome!` 注意：空格也是有意义的，这样做： 12const string = `First Second` 将会创建一个这样的字符串： 12First Second 解决这个问题有一个简单的办法：让第一行是空的，在闭合反引号后面加上 trim() 方法，这样会忽略掉所有第一个字符前的空格： 123const string = `FirstSecond`.trim() 插值模板字符串提供了一个在字符串中插入变量和表达式的简单方法。 你用可以使用 ${...} 语法： 12const var = 'test'const string = `something $&#123;var&#125;` //something test 在 ${} 里你可以添加任何东西，甚至是表达式： 12const string = `something $&#123;1 + 2 + 3&#125;`const string2 = `something $&#123;foo() ? 'x' : 'y' &#125;` 模板标签模板标签是一个最初听起来可能不那么有用的功能，但实际上，它被很多流行库使用，比如Styled Components、Apollo、GraphQL客户端/服务端库，所以理解它的原理也很重要。 在 Styled Components 中，模板标签被用来定义 CSS： 12345const Button = styled.button` font-size: 1.5em; background-color: black; color: white;`; 在 Apollo 中，模板标签被用来定义 GraphQL 查询表： 12345const query = gql` query &#123; ... &#125;` 这些例子中高亮的 styled button 和 gql 模板标签都是 函数： 123function gql(literals, ...expressions) &#123; &#125; 这个函数返回一个字符串，该字符串可以是任何计算结果。 literals 是一个包含被表达式插值标记的模板标签数组。 expressions 包含所有的插值。 比如上面的例子： 1const string = `something $&#123;1 + 2 + 3&#125;` literals 数组包含两项。第一个从 something开始直到遇到第一个插值字符串，第二个是空字符串，是第一个插值末尾（我们只有一个）和整个字符串末尾之间的空格。 一个更复杂的例子是： 1234const string = `somethinganother $&#123;'x'&#125;new line $&#123;1 + 2 + 3&#125;test` 在这个例子中，literals 数组中第一项是： 12`somethinganother ` 第二项是： 12`new line ` 第三项是： 12`test` expressions 是包含 x 和 6 的数组。 传递这些值的函数可以对它们进行任何操作，这也是这个功能的强大之处。 最简单的例子就是赋值插值字符串的功能，通过加入 literals 和 expressions： 1const interpolated = interpolate`I paid $&#123;10&#125;€` interpolate 是这样： 12345678function interpolate(literals, ...expressions) &#123; let string = `` for (const [i, val] of expressions) &#123; string += literals[i] + val &#125; string += literals[literals.length - 1] return string&#125; JavaScript 函数现在我们由面及点地了解所有函数功能，帮助你使用它们。 JavaScript 里的一切都是函数。 函数是一个自包含的代码块，定义一次，可以使用无数次。 函数参数是可选的，只能返回一个值。 JavaScript 里的函数也是对象，一个特殊的对象：函数对象。它们的超能力在于它们可以被调用。 另外，函数被称为头等函数（first class functions），因为它们可以绑定值，可以传递参数，可以返回一个值。 让我们先从“旧”的 ES6 之前的语法开始。这是一个函数声明式： 123function dosomething(foo) &#123; // do something&#125; 现在，在 ES6/ES2015 里，属于常规函数。 函数可以绑定给一个变量（这叫做函数表达式）： 123const dosomething = function(foo) &#123; // do something&#125; 命名函数表达式很简单，但在堆栈调用跟踪中很好用，当错误发生时，它会显示这个函数的名字： 123const dosomething = function dosomething(foo) &#123; // do something&#125; ES6/ES2015 引入了箭头函数，在作为参数或者回调的行内函数时很好用： 123const dosomething = foo =&gt; &#123; //do something&#125; 箭头函数和上面其它函数有一个巨大的差异，我们会在后面的话题中深入它。 参数一个函数可以有一个或多个参数。 1234567891011const dosomething = () =&gt; &#123; //do something&#125;const dosomethingElse = foo =&gt; &#123; //do something&#125;const dosomethingElseAgain = (foo, bar) =&gt; &#123; //do something&#125; ES6/ES2015 开始，函数参数可以有默认值： 123const dosomething = (foo = 1, bar = 'hey') =&gt; &#123; //do something&#125; 这让你不用填满参数也可以调用调用函数： 12dosomething(3)dosomething() ES2018 可以为参数添加尾逗号，帮助减少移动参数时漏掉逗号的 bug（比如把最后一个参数移到中间）： 1234const dosomething = (foo = 1, bar = 'hey') =&gt; &#123; //do something&#125;dosomething(2, 'ho!') 你可以用数组包裹所有参数，然后在调用时用扩展运算符展开： 12345const dosomething = (foo = 1, bar = 'hey') =&gt; &#123; //do something&#125;const args = [2, 'ho!']dosomething(...args) 记住：函数参数是有序的。使用对象作为参数，可以获得参数的名字： 1234567const dosomething = (&#123; foo = 1, bar = 'hey' &#125;) =&gt; &#123; //do something console.log(foo) // 2 console.log(bar) // 'ho!'&#125;const args = &#123; foo: 2, bar: 'ho!' &#125;dosomething(args) 返回值每个函数都会返回一个值，默认是 undefined。 所有函数都会在最后一行代码执行完后终止，或者执行到 return 关键字。当 JavaScript 遇到这个关键字时会自动终止函数执行，并把控制权交给调用者。 如果你传递一个值，这个值就会作为函数的返回值。 1234const dosomething = () =&gt; &#123; return 'test'&#125;const result = dosomething() // result === 'test' 你只能返回一个值： 为了模拟返回多个值，你可以返回一个对象字面量或一个数组，调用函数时用解构绑定单一值。 使用数组： 使用对象： 嵌套函数函数可以定义在另一个函数内部： 12345const dosomething = () =&gt; &#123; const dosomethingelse = () =&gt; &#123;&#125; dosomethingelse() return 'test'&#125; 嵌套的函数在外部函数的作用域里，不能在除此之外的位置调用。 对象方法作为对象特性时，函数作为方法调用： 12345678const car = &#123; brand: 'Ford', model: 'Fiesta', start: function() &#123; console.log(`Started`) &#125;&#125;car.start() 箭头函数中的“this”作为对象方法，箭头函数和常规函数“this”的指向很重要。看看这个例子： 12345678910const car = &#123; brand: 'Ford', model: 'Fiesta', start: function() &#123; console.log(`Started $&#123;this.brand&#125; $&#123;this.model&#125;`) &#125;, stop: () =&gt; &#123; console.log(`Stopped $&#123;this.brand&#125; $&#123;this.model&#125;`) &#125;&#125; 这个 stop() 方法不会像你预期的工作。 这是因为两种函数风格中的 this 不一样。箭头函数中的 this 指向封闭的上下文，在这个例子中是 window 对象： 使用 function() ，this 指向宿主对象。 这意味着箭头函数不适合用于对象方法和构造函数（箭头构造函数会在调用中跑出 TypeError错误）。 IIFE, 立即执行函数表达式IIFE 在声明之后会立即执行： 123;(function dosomething() &#123; console.log('executed')&#125;)() 你可以将结果赋值给变量： 123const something = (function dosomething() &#123; return 'something'&#125;)() 它们非常方便，因为你无需在定义后单独调用该函数。 函数提升在执行代码之前，JavaScript 会根据规则将其重新排序。 比如将函数移动到作用域的顶部。这就是这样写合法的原因： 12 在底层，JavaScript 把这个函数移动到调用语句之前，和其它函数处于同一作用域中： 1234function dosomething() &#123; console.log('did something')&#125;dosomething() 现在，如果你使用命名函数表达式，因为你用了 variables，事情会有所不同。变量被提升了，但是值没有，也就不是一个函数了。 1234dosomething()const dosomething = function dosomething() &#123; console.log('did something')&#125; 不会工作： 这是因为内部变成了： 12345const dosomethingdosomething()dosomething = function dosomething() &#123; console.log('did something')&#125; 这在 let 声明，var 声明也一样不会工作，但是抛出的错误不同： 这是因为 var 声明被提升并初始化值为 undefined，而const 和 let 仅仅只会被提升。 箭头函数箭头函数是 ES6/ES2015 中最重要的改变，现在被广泛使用。它们和常规函数不同，下面我们看看为什么。 在上面我已经介绍了箭头函数，但是它们很重要，所以单独介绍一下它们。 箭头函数在 ES6/ES2015 中引入，它们的存在永远的改变了 JavaScript 代码的写法（和工作）。 在我的观点中，这个改变很受欢迎，以致于现代代码很少用 function 关键字。 在视觉上，它是个受欢迎和简单的变化，让你可以用更简单的语法写一个函数，从： 123const myFunction = function foo() &#123; //...&#125; 变成： 123const myFunction = () =&gt; &#123; //...&#125; 如果函数体只有一个语句，你可以忽略花括号，然后把所有内容写在一行： 1const myFunction = () =&gt; doSomething() 在圆括号中传递参数： 1const myFunction = (param1, param2) =&gt; doSomething(param1, param2) 如果只有一个参数，你可以忽略圆括号： 1const myFunction = param =&gt; doSomething(param) 多谢这个语法，箭头函数鼓励使用短函数。 隐性返回箭头函数可以隐性返回值：不用使用 return 关键字返回。 它在函数体只有一个语句时有效： 123const myFunction = () =&gt; 'test'myFunction() //'test' 另一个例子，返回一个对象（记住用圆括号包裹返回值，避免解释器把它看作函数体）： 123const myFunction = () =&gt; (&#123;value: 'test'&#125;)myFunction() //&#123;value: 'test'&#125; 箭头函数中 this 如何工作this 是一个很难掌握的理念，上下文造成了它的不同，也受 JavaScript 模式（是否是严格模式）的影响。 理清这个概念很重要，因为箭头函数的表现和常规函数不同。 当定义了对象里的某一方法，在常规函数里 this 指向这个对象，所以你可以： 1234567const car = &#123; model: 'Fiesta', manufacturer: 'Ford', fullName: function() &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125;&#125; 调用 car.fullname() 会返回 Ford Fiesta。 箭头函数的 this 继承自执行上下文。箭头函数根本不会·绑定 this，所以它的值会在调用栈里查询，所以在这个代码里 car.fullName()无意义，然后返回 undefined undefined： 1234567const car = &#123; model: 'Fiesta', manufacturer: 'Ford', fullName: () =&gt; &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125;&#125; 因为此，箭头函数不适合用于对象方法。 箭头函数也不能用于初始化对象的构造函数，它会抛出 TypeError。 当不需要动态上下文，应该使用常规函数替代。 处理事件时也会有问题。DOM 事件监听器会设置 this为目标元素，如果你需要事件处理器的 this，应该用常规函数： 123456789const link = document.querySelector('#link')link.addEventListener('click', () =&gt; &#123; // this === window&#125;)const link = document.querySelector('#link')link.addEventListener('click', function() &#123; // this === link&#125;) 闭包这是对闭包话题很友好的介绍，是理解 JavaScript 函数如何工作的关键。 如果你写过 JavaScript 函数，你已经使用了 闭包。这是一个需要理解的关键主题，它会影响你所做的事情。当一个函数运行时，它运行在定义它的作用域中，而不是执行它的位置。 作用域基本上是可见的变量合集。函数会记住它的词法作用域，并且能够访问在父作用域中定义的变量。 简而言之，函数有一整套可以访问的变量。 我们赶紧通过例子验证一下： 123456const bark = dog =&gt; &#123; const say = `$&#123;dog&#125; barked!` ;(() =&gt; console.log(say))()&#125;bark(`Roger`) 这个预期一样打印出：Roger barked!。 如果你想要返回操作，这样做： 12345678const prepareBark = dog =&gt; &#123; const say = `$&#123;dog&#125; barked!` return () =&gt; console.log(say)&#125;const bark = prepareBark(`Roger`)bark() 这个代码段会打印出 Roger barked!。 最后一个例子，让两种不同的狗 prepareBark： 123456789101112const prepareBark = dog =&gt; &#123; const say = `$&#123;dog&#125; barked!` return () =&gt; &#123; console.log(say) &#125;&#125;const rogerBark = prepareBark(`Roger`)const sydBark = prepareBark(`Syd`)rogerBark()sydBark() 打印： 12Roger barked!Syd barked! 正如你所见，变量 say 的结果和函数 prepareBark 返回的是相关的。 第二个调用 prepareBark() 时重新定义了新的 say 变量，但是不会影响第一次 prepareBark() 的作用域。 这就是闭包的原理：返回的函数保持作用域里的初始状态。 数组随着不断地发展，JavaScript 数组有了越来越多的功能，有些时候知道什么使用什么方法是很棘手的。本章节旨在解释截至 2018 年你应该使用什么。 初始化数组1234const a = []const a = [1, 2, 3]const a = Array.of(1, 2, 3)const a = Array(6).fill(1) //init an array of 6 items of value 1 不要使用旧语法（除了类型数组）： 12const a = new Array() //never useconst a = new Array(1, 2, 3) //never use 获取数组长度1const l = a.length 通过 every 遍历数组1a.every(f) 遍历 a 直到 f() 返回 false。 通过 some 遍历数组1a.some(f) 遍历 a 直到 f() 返回 true。 遍历数组并返回函数结果组成的新数组1const b = a.map(f) 遍历 a，返回每一个 a 元素执行 f() 产生的结果数组。 过滤数组1const b = a.filter(f) 遍历 a，返回每一个 a 元素执行 f() 都为 true 的新数组。 Reduce123a.reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; //...&#125;, initialValue) reduce() 对数组中每一项都调用回调函数，并逐步计算计算结果。如果 initaiValue 存在，accumulator在第一次迭代时等于这个值。 例子： 12 foreach ES6 1a.forEach(f) 遍历 a 执行 f，不能中途停止。 例子： 123a.forEach(v =&gt; &#123; console.log(v)&#125;) for…of ES6 123for (let v of a) &#123; console.log(v)&#125; for123for (let i = 0; i &lt; a.length; i += 1) &#123; //a[i]&#125; 遍历 a，可以通过 return 或者 break 中止循环，通过 continue 跳出循环。 @@iterator ES6 获取数组迭代器的值： 123456const a = [1, 2, 3]let it = a[Symbol.iterator]()console.log(it.next().value) //1console.log(it.next().value) //2console.log(it.next().value) //3 .entries() 返回一个键值对的迭代器： 12345let it = a.entries()console.log(it.next().value) //[0, 1]console.log(it.next().value) //[1, 2]console.log(it.next().value) //[2, 3] .keys() 返回包含所有键名的迭代器： 12345let it = a.keys()console.log(it.next().value) //0console.log(it.next().value) //1console.log(it.next().value) //2 数组结束时 .next() 返回 undefined。你可以通过 it.next() 返回的 value, done 值检测迭代是否结束。当迭代到最后一个元素时 done 的值始终为 true。 在数组末尾追加值1a.push(4) 在数组开头添加值12a.unshift(0)a.unshift(-2, -1) 移除数组中的值删除末尾的值1a.pop() 删除开头的值1a.shift() 删除任意位置的值12a.splice(0, 2) // get the first 2 itemsa.splice(3, 2) // get the 2 items starting from index 3 不要使用 remove()，因为它会留下未定义的值。 移除并插入值123a.splice(2, 3, 2, 'a', 'b') //removes 3 items starting from//index 2, and adds 2 items,// still starting from index 2 合并多个数组123const a = [1, 2]const b = [3, 4]a.concat(b) // 1, 2, 3, 4 查找数组中特定元素ES51a.indexOf() 返回匹配到的第一个元素的索引，元素不存在返回 -1。 1a.lastIndexOf() 返回匹配到的最后一个元素的索引，元素不存在返回 -1。 ES6123a.find((element, index, array) =&gt; &#123; //return true or false&#125;) 返回符合条件的第一个元素，如果不存在返回 undefined。 通常这么用： 1a.find(x =&gt; x.id === my_id) 上面的例子会返回数组中 id === my_id的第一个元素。 findIndex 返回符合条件的第一个元素的索引，如果不存在返回 undefined： 123a.findIndex((element, index, array) =&gt; &#123; //return true or false&#125;) ES71a.includes(value) 如果 a 包含 value 返回 true。 1a.includes(value, i) 如果 a 从位置 i 后包含 value 返回 true。 获取数组的一部分1a.slice() 数组排序按字母顺序排序（按照 ASCII 值 - 0-9A-Za-z）： 12345const a = [1, 2, 3, 10, 11]a.sort() //1, 10, 11, 2, 3const b = [1, 'a', 'Z', 3, 2, 11]b = a.sort() //1, 11, 2, 3, Z, a 自定义排序 12const a = [1, 10, 3, 2, 11]a.sort((a, b) =&gt; a - b) //1, 2, 3, 10, 11 逆序 1a.reverse() 数组转字符串1a.toString() 返回字符串类型的值 1a.join() 返回数组元素拼接的字符串。传递参数以自定义分隔符： 1a.join(',') 复制所有值12const b = Array.from(a)const b = Array.of(...a) 复制部分值1const b = Array.from(a, x =&gt; x % 2 == 0) 将值复制到本身其它位置123456789const a = [1, 2, 3, 4]a.copyWithin(0, 2) // [3, 4, 3, 4]const b = [1, 2, 3, 4, 5]b.copyWithin(0, 2) // [3, 4, 5, 4, 5]//0 is where to start copying into,// 2 is where to start copying fromconst c = [1, 2, 3, 4, 5]c.copyWithin(0, 2, 4) // [3, 4, 3, 4, 5]//4 is an end index 循环JavaScript 提供了许多种循环方法。这个章节通过小例子和主要属性讲解现代 JavaScript 中的所有循环方法。 for12345const list = ['a', 'b', 'c']for (let i = 0; i &lt; list.length; i++) &#123; console.log(list[i]) //value console.log(i) //index&#125; 可以通过 break 中断 for 循环 可以通过 continue 跳过当前 for 循环 forEachES5 中引入。给你一个数组，你可以通过 list.forEach() 遍历它的属性： 1234567const list = ['a', 'b', 'c']list.forEach((item, index) =&gt; &#123; console.log(item) //value console.log(index) //index&#125;)//index is optionallist.forEach(item =&gt; console.log(item)) 不幸的是，你不能中断这个循环。 do…while1234567const list = ['a', 'b', 'c']let i = 0do &#123; console.log(list[i]) //value console.log(i) //index i = i + 1&#125; while (i &lt; list.length) 可以通过 break 中断 do...while 循环： 123do &#123; if (something) break&#125; while (true) 可以通过 continue 跳过当前 do...while 循环： 1234do &#123; if (something) continue //do something else&#125; while (true) while1234567const list = ['a', 'b', 'c']let i = 0while (i &lt; list.length) &#123; console.log(list[i]) //value console.log(i) //index i = i + 1&#125; 可以通过 break 中断 while 循环： 123while (true) &#123; if (something) break&#125; 可以通过 continue 跳过当前 while 循环： 1234while (true) &#123; if (something) continue //do something else&#125; 和 do...while 不同的是 do...while 至少会循环一次。 for…in遍历对象的所有可迭代属性名。 1234for (let property in object) &#123; console.log(property) //property name console.log(object[property]) //property value&#125; for…ofES2015 中引入了 for...of 循环，它结合了 forEach 的易用性和不能中断的特性： 12345678910//iterate over the valuefor (const value of ['a', 'b', 'c']) &#123; console.log(value) //value&#125;//get the index as well, using `entries()`for (const [index, value] of ['a', 'b', 'c'].entries()) &#123; console.log(index) //index console.log(value) //value&#125; 注意使用 const。这个循环在每次迭代都创建了一个新的作用域，所以我们可以安全的使用它替代 let。 for…in vs for…of和 for...in 不同的是： for...of 迭代属性值 for...in 迭代属性名 事件浏览器中的 JavaScript 使用事件驱动编程模型。万物始于事件。这个章节介绍了 JavaScript 事件以事件处理器的工作原理。 事件可能是 DOM 加载完成，或者是异步请求结束，或者是用户点击了元素或是滚动了页面，或者是用户按下键盘。 有很多种不同的事件。 事件处理器你可以通过事件处理器响应所有事件，就是事件发生时调用对应函数。 你可以对同一个事件注册多个处理器，它们都会在事件发生时被调用。 JavaScript 提供了三种方法注册事件处理器： 行内事件处理器这种方法由于自身限制现在已经很少使用，但在早期的 JavaScript 中是唯一的方法： 1&lt;a href="site.com" onclick="dosomething();"&gt;A link&lt;/a&gt; DOM 事件处理器当一个对象只有一个事件处理器时这种方法很常用，在这个例子中没办法添加多个处理器： 123window.onload = () =&gt; &#123; //window loaded&#125; 在处理 XHR 请求时这也很常见： 1234const xhr = new XMLHttpRequest()xhr.onreadystatechange = () =&gt; &#123; //.. do something&#125; 你可以通过 if (&#39;onsomething&#39; in window) {} 检查处理器是否已经分配给某个属性。 使用 addEventListener()这是很现代的方法。这个方法允许我们按需注册多个事件处理器，你会发现它是最流行的： 123window.addEventListener('load', () =&gt; &#123; //window loaded&#125;) 注意：IE8 及以下版本不支持这个方法，可以使用 attachEvent() 代替。如果你需要兼容旧浏览器这很重要。 监听不同的元素你可以监听 window 拦截“全局”事件，比如键盘的使用。你也可以监听特定元素上发生的事件，比如鼠标点击了某个按钮。 这也是为什么 addEventListener 有时候在 window 上调用，有时间在某个 DOM 元素上。 事件对象事件处理器会获得一个 Event 对象作为第一个参数： 1234const link = document.getElementById('my-link')link.addEventListener('click', event =&gt; &#123; // link clicked&#125;) 这个对象包含很多有用的属性和方法，比如： target，事件发生的目标 DOM 元素 type，事件类型 stopPropagation()，调用以阻止 DOM 事件传播 (查看完整清单) 其它属性提供给特定的事件，Event 只是不同事件的一个接口： MouseEvent KeyboardEvent DragEvent FetchEvent 等等 上面的每一个都链接到了 MDN 页面，你可以在那查看它们所有的属性。 举个例子，当一个键盘事件发生时，你可以检查哪个键被按下，通过 key 属性值得到一个易读的值（Escape, Enter 等等）： 1234window.addEventListener('keydown', event =&gt; &#123; // key pressed console.log(event.key)&#125;) 在鼠标事件中我们可以直到哪个按钮被按下： 12345const link = document.getElementById('my-link')link.addEventListener('mousedown', event =&gt; &#123; // mouse button pressed console.log(event.button) //0=left, 2=right&#125;) 事件冒泡和事件捕捉事件冒泡和事件捕捉是事件传播的两个模型。 假设你的 DOM结构是这样的： 123&lt;div id="container"&gt; &lt;button&gt;Click me&lt;/button&gt;&lt;/div&gt; 你希望跟踪用户什么时候点击了这个按钮，你有两个事件处理器，一个在 button 上，一个在 #container 上。记住，子元素上的点击事件也会传播到它的父元素上，除非你阻止了事件传播（稍后详解）。 这些事件处理器会按照顺序调用，这个顺序通过事件冒泡/事件捕捉模型决定。 冒泡意味着事件从被点击的元素（子元素）一直向上传播到所有祖先元素，从最近的一个开始。 在我们的例子中，button 上的处理器会在 #container 之前发生。 捕捉恰恰相反：最外部的事件会在特定处理器之前发生，比如 button。 默认采用事件冒泡模型。 你也可以选择使用事件捕捉，通过将 addEventListener 的第三个参数设为 true： 1234567document.getElementById('container').addEventListener( 'click', () =&gt; &#123; //window loaded &#125;, true) 注意：首先运行的是捕捉阶段的事件处理器，然后才是冒泡的事件处理器。 这个顺序遵循这个原则：DOM 从 Window 对象开始遍历所有元素，直到找到被点击的对象。执行此操作时，会调用任何绑定的事件处理器（捕捉阶段）。一旦找到目标元素，它会重复这个过程直到回到 Window 对象，此时调用相应的事件处理器（冒泡阶段）。 阻止传播DOM 元素事件会一直在它的母树上传播，除非手动阻止它： 1234&lt;html&gt; &lt;body&gt; &lt;section&gt; &lt;a id="my-link" ...&gt; a 上的点击事件会传播到 section 然后是 body。 你可以调用 stopPropagation() 方法阻止事件传播，一般放在事件处理器的末尾： 1234567const link = document.getElementById('my-link')link.addEventListener('mousedown', event =&gt; &#123; // process the event // ... event.stopPropagation()&#125;) 常见事件这是一个你经常会用到的事件清单。 loadwindow 和 body 元素的 load 事件在页面加载完成时触发。 鼠标事件click 事件在鼠标单击时触发。dbclick 事件在双击鼠标时触发，当然，在这种情况下会先触发 click 事件。mousedown，mousemove和 mouseup可以和拖动事件结合在一起。小心使用 mousemove，它会在鼠标移动过程中触发很多次（稍后会看到节流）。 键盘事件keydown事件在按下键盘时触发（并在处于按下状态时持续触发）。keyup 事件在松开键盘时触发。 滚动scroll 事件在每一次滚动页面时触发。在这个事件处理器内部，你可以通过 window.scrollY（Y轴）查看当前滚动位置。 注意这个事件不是一次性的，它会在滚动过程中持续发生，不仅仅是在滚动开始和滚动结束，所以不要在处理事件时进行大量计算和操作 - 使用节流代替。 节流正如上面提到的，mousemove 和 scroll都不是一次性事件，它们在操作发生期间持续调用事件处理器。这是因为它们需要提供你需要知道的坐标。 如果你在这些事件处理器中进行复杂的操作，将会影响性能给你的网页用户带来糟糕的体验。 像 Lodash 这样的库提供了 100 行代码实现的节流函数来帮助解决这个问题。一个简单又容易理解的实现是使用定时器每隔 100ms 缓存一次滚动事件： 12345678910let cached = nullwindow.addEventListener('scroll', event =&gt; &#123; if (!cached) &#123; setTimeout(() =&gt; &#123; //you can access the original event at `cached` cached = null &#125;, 100) &#125; cached = event&#125;) 事件循环事件循环是 JavaScript 中最重要的内容。 我已经使用 JavaScript 好多年了，但是也没有完全理解它的工作原理。当然不了解这些细枝末节也没有什么关系，但通常来讲，知道它的工作原理是很有帮助的，你可能也很好奇这个内容。 这个章节致力于解释 JavaScript 如何是单线程工作以及如何处理异步函数的内在细节。 你的 JavaScript 代码运行在单线程，同一时间只会发生一件事情。这是一个非常有用的限制，它简化了很多程序，你不用再为并发问题担忧。你只需要关注于 如何书写代码，避免造成线程堵塞的内容，比如同步网络请求或者无限循环。 通常，大多数浏览器的每一个浏览标签都有独立的事件循环，以使进程隔离避免有无限循环或者繁重处理的页面阻塞整个浏览器。浏览器管理多个并发的事件循环来解决 API 的调用。Web Workers 也运行在自己的事件循环里。 你只需要明白你的代码运行在单一事件循环，并在写代码时考虑到这一点，避免阻塞它。 阻塞事件循环任何执行时间过长不能将控制权返回给事件循环的 JavaScript 代码都会阻塞页面内其它代码的执行，甚至阻塞 UI 线程，导致用户不能点击、滚动页面等等。 大多数 JavaScript 原语是非阻塞的，比如网络请求，Node.js文件系统操作等等。发生阻塞是意外的，这也是为什么 JavaScript 基于大量的回调以及最近的 promises 和 async/await。 调用堆栈调用堆栈是 LIFO 队列（Last In, First Out）。 事件循环不断检查调用堆栈里是否仍有函数需要运行。于此同时，它将找到的函数加入调用堆栈，然后按照顺序执行。 你了解调试器或者浏览器控制台里的错误堆栈跟踪信息吗？浏览器在调用堆栈中查询函数名字，然后标记出当前调用由哪个函数触发： 一个简单的事件循环说明举个例子： 12345678910const bar = () =&gt; console.log('bar')const baz = () =&gt; console.log('baz')const foo = () =&gt; &#123; console.log('foo') bar() baz()&#125;foo() 这个代码打印出： 123foobarbaz 和预期一样。 当这个代码运行时，最开始 foo() 被调用，在 foo() 内部先调用 bar()，然后调用 baz()。 这时我们的调用栈看起来就是这样： 每次迭代的事件循环都会查看调用堆栈中是否还有内容，并执行它： 直到整个调用堆栈是空的。 函数执行队列上面的例子很普通，也没有什么特殊之处：JavaScript 发现需要执行的内容然后按照顺序执行。 让我们看看如何延迟函数执行直到清空调用栈。 使用 setTimeout(() =&gt; {}, 0)调用一个函数，会在其它函数全部执行完毕那一刻执行这个函数。 举个例子： 12345678910const bar = () =&gt; console.log('bar')const baz = () =&gt; console.log('baz')const foo = () =&gt; &#123; console.log('foo') setTimeout(bar, 0) baz()&#125;foo() 结果令人惊讶： 123foobazbar 当这个代码运行时，foo() 先被调用。foo() 内部先调用 setTimeout，将 bar 作为参数传入定时器，我们传入 0 指示它立即执行，然后调用 baz()。 这时调用栈时这样的： 我们的程序中所有函数的执行顺序： 为什么这样？ 消息队列当 setTimeout() 调用时，浏览器或者 Node.js 开始计时。在这个例子中，我们将 0 作为延时时间，时间一到，回调函数就会被推入消息队列。 消息队列也包含用户发出的点击或者键盘事件，或者是在你的代码之前已经存在的获取响应的队列，或者是像 onLoad 这样的 DOM 事件。 整个循环会优先进行调用堆栈，它会先处理调用堆栈里找到的所有内容，一旦没有内容，它就会在事件队列里拾取内容。 我们不必等待像 setTimeout，fetch等其它自己完成工作的函数，因为它们由浏览器提供，具有自己的线程。举个例子，如果你设置一个延时 2 秒的 setTimeout 定时器，你不用等待 2 秒 - 等待在别的地方完成。 ES6 工作队列（Job Queue)ECMASciprt 2015 引入了工作队列概念，用在 Promises（同样在 ES6/ES2015 中引入）中。这是一种尽快执行异步函数的方法，而不是放在调用堆栈的末尾。 在当前函数结束前完成的 Promises 将会在当前函数之后执行。 我发现在游乐场坐过山车可以很好的解释这个内容：消息队列将你放在其它游客队列之后，工作队列是一张快速通行证，能让你插队提前坐上过山车。 例子： 12345678910111213const bar = () =&gt; console.log('bar')const baz = () =&gt; console.log('baz')const foo = () =&gt; &#123; console.log('foo') setTimeout(bar, 0) new Promise((resolve, reject) =&gt; resolve('should be right after baz, before bar') ).then(resolve =&gt; console.log(resolve)) baz()&#125;foo() 这会打印出： 1234foobazshould be right after baz, before barbar 这是 Promises（包括基于 promises 的 Async/await）和原生的旧异步函数 setTimeout() 或者其它平台 API 之间最大的不同。 异步编程和回调JavaScript 默认就是异步和单线程的。这意味着代码不能创建新线程并且并行运行。让我们了解异步代码是什么。 编程语言里的异步计算机在设计上是异步的。 异步是某些东西可以独立于主程序流程发生。 在当前的消费计算机中，每一个程序都运行在一个特殊的时间段，然后停止之后让其它程序开始运行。这一切发生的很快以至于我们无法注意到，我们认为我们的计算机同时运行许多程序，但这是一种误解（除了多进程机器）。 程序内部使用中断，一种提交给处理器获得系统注意的信号。 我不会深入介绍它，但是要记住这对异步程序来说很普便，在它们被注意之前停止执行，同时计算机可以执行其它内容。当一个程序等待网络响应时，只有等请求结束才能终止运行。 一般，编程语言是异步的，其中一些也会提供异步操作的办法，这些语言或者库，C 语言，Java，C#，PHP，Go，Ruby，Swift，Python 默认都是异步的，其中一些通过使用线程处理异步，产生一个新进程。 JavaScriptJavaScript 默认就是异步和单线程的。这意味着代码不能创建新线程并且并行运行。 每行代码都是一个接着一个执行，举个例子： 12345const a = 1const b = 2const c = a * bconsole.log(c)doSomething() 但是 JavaScript 是为了浏览器而生的，一开始它的主要工作是响应用户的操作，比如 onClick，onMouseOver，onChnage，onSubmit 等等。它怎么能使用异步编程模式？ 答案在它的环境中。浏览器通过提供一系列可以处理这种功能的 API 解决了这个问题。 尤其最近 Node.js 引入了非阻塞 I/O 环境将这个理念扩展到文件访问，网络调用等等方面。 回调函数你无法知道用户何时要单击按钮，因此你要为 click 事件定义事件处理程序。此事件处理程序接受一个函数，该函数将在触发事件时调用： 123document.getElementById('button').addEventListener('click', () =&gt; &#123; //item clicked&#125;) 这也被叫做回调函数。 回调是一个简单的函数，作为值传入其它函数，只会在事件发生时被调用。我们可以这么是因为 JavaScript 的头等函数可以和变量绑定并传入其它函数（称作高阶函数）。 把你所有的代码包裹在 window 对象上的 load 事件监听器里是很常见的，这样代码只会在页面准备好时运行： 1234window.addEventListener('load', () =&gt; &#123; //window loaded //do what you want&#125;) 回调函数任何地方都会用到，不仅仅是 DOM 事件。 一个常见的例子是使用定时器： 123setTimeout(() =&gt; &#123; // runs after 2 seconds&#125;, 2000) XHR 请求同样接受一个回调函数。在这个例子中，将一个函数分配给一个属性，这样当特定事件（这里是请求状态发生变化）发生时就会调用这个函数： 12345678const xhr = new XMLHttpRequest()xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; xhr.status === 200 ? console.log(xhr.responseText) : console.error('error') &#125;&#125;xhr.open('GET', 'https://yoursite.com')xhr.send() 处理回调中的错误你如何处理回调错误？一个常见的策略是采用 Node.js 的方法：回调函数的第一个参数始终是错误对象：错误优先回调。 如果没有错误，这个对象为 null。如果发生错误，它包含描述错误和其它信息的内容。 123456789fs.readFile('/file.json', (err, data) =&gt; &#123; if (err !== null) &#123; //handle error console.log(err) return &#125; //no errors, process data console.log(data)&#125;) 回调伴随的问题回调让简单代码更简单！ 然而每一个回调函数都会添加一级嵌套，如果你有很多个回调函数，代码会变得十分复杂： 123456789window.addEventListener('load', () =&gt; &#123; document.getElementById('button').addEventListener('click', () =&gt; &#123; setTimeout(() =&gt; &#123; items.forEach(item =&gt; &#123; //your code here &#125;) &#125;, 2000) &#125;)&#125;) 这仅仅是一个简单的四级代码，但是我看到很多层嵌套，这并不有趣。 怎么解决这个问题？ 回调的替代方案从 ES6 开始，JavaScript 引入了很多功能让我们不用回调就能优雅的写异步代码： Promises（ES6) Async/Await（ES8) PromisesPromises 是 JavaScript 解决异步代码中需要写太多回调函数的一种方法。 Promises 通常被定义为一个最终可用的值的代理（a proxy for a value that will eventually become available）。 Promises 是一个解决异步代码的方法，不用在代码中写太多回调函数。尽管这些年已经变得很流行，也在 ES2015 中被引入并成为标准，在 ES2017 中也被异步函数（async functions）代替。 promises 工作原理（简短）一旦一个 promise 被调用，它就会变成 pending 状态。这意味调用者会持续执行，同时等待自身处理结果，然后给调用函数一些反馈。 此时，该调用函数等待这个 promise 返回 resolved 状态 或者 rejected 状态，但是你知道 JavaScript 是异步的，所以这个函数会在 promise 工作时继续执行其它代码。 哪些 JS API 使用 promises？除了你自己的代码和一些库之外，现在 Web API 也使用 promises： 电池 API Fetch API Service Workers 在现代 JavaScript 中你不太可能不使用 promises，所以让我们深挖一下它。 创建 promisePromise API 暴露出一个 Promise 构造函数，你可以通过 new Promise() 初始化： 12345678910111213let done = trueconst isItDoneYet = new Promise( (resolve, reject) =&gt; &#123; if (done) &#123; const workDone = 'Here is the thing I built' resolve(workDone) &#125; else &#123; const why = 'Still working on something else' reject(why) &#125; &#125;) 你可以看到这个 promise 在全局常量 done 为 true 时，返回一个已解决的 promise，否则返回一个被拒绝的 promise。 使用 resolve 和 reject我们可以回传一个值，在上面的例子中，我们返回了一个字符串，也可以返回一个对象。 使用 promise在上个章节中，我们介绍了如何创建一个 promise。 现在让我们看看如何使用 promise。 12345678910111213const isItDoneYet = new Promise( //...)const checkIfItsDone = () =&gt; &#123; isItDoneYet .then((ok) =&gt; &#123; console.log(ok) &#125;) .catch((err) =&gt; &#123; console.error(err) &#125;)&#125; 运行 checkIfItsDone() 会执行 isItDoneYet() promise 然后等待它 resolve 调用 then 回调，如果发生错误，会在 catch 回调中处理错误。 链式 promisepromise 可以返回另一个 promise，形成链式 promise。 Fecth API（XMLHttpRequest API 上层 API）提供了一个很好的例子。我们可以用它获取资源并用 promise 链式操作资源。 Fetch API 基于 promise 机制，调用 fetch() 等同于我们通过 new promise() 定义一个 promise。 链式 promise 例子12345678910111213const status = (response) =&gt; &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return Promise.resolve(response) &#125; return Promise.reject(new Error(response.statusText))&#125;const json = (response) =&gt; response.json()fetch('/todos.json') .then(status) .then(json) .then((data) =&gt; &#123; console.log('Request succeeded with JSON response', data) &#125;) .catch((error) =&gt; &#123; console.log('Request failed', error) &#125;) 在这个例子中，我们调用 fetch() 从根域名中的 todos.json 文件获取一个 TODO 清单，我们创建了一个 promises 链。 运行 fetch() 返回一个包含很多个属性的响应，我们引用了其中的： status，反应 HTTP 状态的数值 statusText，状态消息，请求成功时为 OK response 也有一个 json() 方法，可以将成功获取的响应内容转化为 JSON 并作为 promise 返回。 基于此：链中第一个 promise 是我们定义的函数 status()，它用来检查响应状态，当结果不在 200 和 299 之间时拒绝这个 promise。这样会导致 promise 链跳过所有链表直接进入末尾的 catch() 语句，打印出 Request failed和错误信息。 如果成功，它会调用我们定义的 json()函数。当成功时，上一个 promise 返回 response 对象，作为第二个 promise 的输入。 在这个过程中，我们返回处理过的 JSON 数据，所以第三个 promise 直接获得 JSON 对象： 123.then((data) =&gt; &#123; console.log('Request succeeded with JSON response', data)&#125;) 在控制台会打印出这些内容。 处理错误在上面的例子中，promises 链后面有一个 catch 块。当链式 promises 有任何错误发生，亦或手动返回 rejects，程序控制权会交给错误代码后距离最近的 catch() 语句。 1234567891011new Promise((resolve, reject) =&gt; &#123; throw new Error('Error')&#125;) .catch((err) =&gt; &#123; console.error(err) &#125;)// ornew Promise((resolve, reject) =&gt; &#123; reject('Error')&#125;) .catch((err) =&gt; &#123; console.error(err) &#125;) 级联错误如果在 catch() 内部又抛出一个错误，你可以添加第二个 catch() 处理它，以此类推。 12345new Promise((resolve, reject) =&gt; &#123; throw new Error('Error')&#125;) .catch((err) =&gt; &#123; throw new Error('Error') &#125;) .catch((err) =&gt; &#123; console.error(err) &#125;) 编排 promisesPromise.all()如果你需要同时处理多个 promises，Promise.all() 可以帮助你定义一组 promises，等待它们全部完成之后再执行某些操作。比如： 123456789const f1 = fetch('/something.json')const f2 = fetch('/something2.json')Promise.all([f1, f2]).then((res) =&gt; &#123; console.log('Array of results', res)&#125;).catch((err) =&gt; &#123; console.error(err)&#125;) ES2015 的结构语法也允许你这么做： 123Promise.all([f1, f2]).then(([res1, res2]) =&gt; &#123; console.log('Results', res1, res2)&#125;) 这不仅限于 fetch，任何 promise 都可以处理。 Promise.race()当传入的 promise 有一个完成 Promise.race() 就开始运行，且只会运行一次附加的回调函数，传入首先运行完的 promise 返回的结果。例子： 12345678910const first = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 500, 'first')&#125;)const second = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, 'second')&#125;)Promise.race([first, second]).then((result) =&gt; &#123; console.log(result) // second&#125;) Async 和 Await现在，我们将探讨 JavaScript 中更现代的异步函数方法。JavaScript 从回调函数发展为 Promise 只用了很短的时间，从 ES2017 开始，async 和 await 让异步 JavaScript 变得更加简单。 异步函数结合了 promise 和生成器，基本上可以看作是 promises 之上的抽象方法。我再重复一遍：async 和 await 基于 promises。 为什么引入 async 和 await？它们减少了 promises 的固定样板和链式 promise “不能切断链式”的限制。 ES2015 引入 promises 时，只是为了解决异步代码的问题，这一点做得很好，但是，ES2015 和 ES2017 之间的这两年人们发现 promises 并不是最终的解决方案。 引入 Promises 是为了解决著名的回调地狱问题，但其自身也很复杂，引入了更复杂的语法。 它们是很好的开始，但是应该有更好的语法供开发者使用，所以异步函数（async functions）诞生了。它让代码看起来是同步的，但其实它们是异步的并不会阻塞后面的代码。 工作原理一个异步函数返回一个 promise，就像这个例子： 12345const doSomethingAsync = () =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125; 你在前面加上 await 然后调用这个函数，这样代码会暂停执行直到这个 promise 变成 resolved 或者 rejected。需要注意的是：委托函数必须定义为 async。例子： 123const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync())&#125; 例子这是一个使用 async/await 异步运行函数的例子： 12345678910111213const doSomethingAsync = () =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125;const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync())&#125;console.log('Before')doSomething()console.log('After') 上面的代码在浏览器控制台中打印出： 123BeforeAfterI did something //after 3s 一切都是 promise在任何函数前加上 async 前缀都使这个函数返回一个 promise。即使它没有明确这么做，它也会在内部让它返回一个 promise。这也是为什么这个代码是合法的： 12345const aFunction = async () =&gt; &#123; return 'test'&#125;aFunction().then(alert) // This will alert 'test' 它和这个类似： 12345const aFunction = async () =&gt; &#123; return Promise.resolve('test')&#125;aFunction().then(alert) // This will alert 'test' 代码更易读你看我们上面的代码和原生的 promise 链式回调比起来是多么的简单。这仅仅是一个非常简单的例子，代码越复杂，越能凸显它的优势。 拿 promises 举个例子，你需要获取一个 JSON 资源并且对它进行解析： 123456789const getFirstUserData = () =&gt; &#123; return fetch('/users.json') // get users list .then(response =&gt; response.json()) // parse JSON .then(users =&gt; users[0]) // pick first user .then(user =&gt; fetch(`/users/$&#123;user.name&#125;`)) // get user data .then(userResponse =&gt; response.json()) // parse JSON&#125;getFirstUserData() 用 async/await 实现同样的需求： 12345678910const getFirstUserData = async () =&gt; &#123; const response = await fetch('/users.json') // get users list const users = await response.json() // parse JSON const user = users[0] // pick first user const userResponse = await fetch(`/users/$&#123;user.name&#125;`) // get user data const userData = await user.json() // parse JSON return userData&#125;getFirstUserData() 串联多个异步函数异步函数可以很容易的串联起来，语法也比原生 promise 更易读： 1234567891011121314151617const promiseToDoSomething = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 10000) &#125;)&#125;const watchOverSomeoneDoingSomething = async () =&gt; &#123; const something = await promiseToDoSomething() return something + ' and I watched'&#125;const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; &#123; const something = await watchOverSomeoneDoingSomething() return something + ' and I watched as well'&#125;watchOverSomeoneWatchingSomeoneDoingSomething().then((res) =&gt; &#123; console.log(res)&#125;) 打印出： 1I did something and I watched and I watched as well 更容易调试调试 promise 很难，因为调试器不能跳过异步代码。 Async/await 就很简单了，因为对编译器来说它就是同步代码。 循环作用域对开发者来说，JavaScript 的循环作用域可能会让人感到头疼。我们将学习循环作用域中和 var，let 有关的技巧。 例子： 1234567891011const operations = []for (var i = 0; i &lt; 5; i++) &#123; operations.push(() =&gt; &#123; console.log(i) &#125;)&#125;for (const operation of operations) &#123; operation()&#125; 它遍历 5 次，每次添加一个函数到 operations 数组。这个函数能够打印出循环时的索引变量 i。稍后运行这些函数。 期望的结果是： 1234501234 但真实结果却是： 1234555555 为什么这样？原因在于 var。 由于 var 声明会被提升，上面的代码等同于： 123456789101112var i;const operations = []for (i = 0; i &lt; 5; i++) &#123; operations.push(() =&gt; &#123; console.log(i) &#125;)&#125;for (const operation of operations) &#123; operation()&#125; 所以，在 for-of 循环中，i 始终等于 5。在这个函数中每一次调用 i 都等于 5。 所以我们怎么做能让它按照我们的需要工作呢？ 最简单的方法是用 let 声明。在 ES2015 引入，它可以避免 var 声明带来一些奇怪的事情。 把循环中的 var 改成 let 一切就正常了： 1234567891011const operations = []for (let i = 0; i &lt; 5; i++) &#123; operations.push(() =&gt; &#123; console.log(i) &#125;)&#125;for (const operation of operations) &#123; operation()&#125; 输出： 1234501234 这怎么可能？原因是每一次循环迭代 i 都创建了一个新的作用域，每个添加到 operations 数组的函数都获取当时的 i 副本。 另一个解决这个问题的办法在 ES6 之前很常用，使用立即执行函数表达式（IIFE）。 在这个问题中，你可以包裹整个函数并绑定 i。这样每次都创建了一个立即执行的函数，并返回了一个新函数，所以我们可以稍后执行： 1234567891011const operations = []for (var i = 0; i &lt; 5; i++) &#123; operations.push(((j) =&gt; &#123; return () =&gt; console.log(j) &#125;)(i))&#125;for (const operation of operations) &#123; operation()&#125; 定时器写 JavaScript 代码时，你可能想要延时执行某个函数。本节我们将讨论如何使用 setTimeout 和 setInterval 安排将来的函数。 setTimeout()写 JavaScript 代码时，你可能想要延时执行某个函数。这个工作交给 setTimeout。你可以指定一个延时执行的函数和需要的延时时间，以毫秒计： 1234567setTimeout(() =&gt; &#123; // runs after 2 seconds&#125;, 2000)setTimeout(() =&gt; &#123; // runs after 50 milliseconds&#125;, 50) 这个语法定义了一个新函数。你可以在任何位置调用它，你也可以传递一个已经存在的函数名，也可以设置一些参数： 123456const myFunction = (firstParam, secondParam) =&gt; &#123; // do something&#125;// runs after 2 secondssetTimeout(myFunction, 2000, firstParam, secondParam) setTimeout 返回一个定时器标识符。通常不会用到它，但是你可以保存这个 id，在需要删除这个定时函数时清空它： 123456const id = setTimeout(() =&gt; &#123; // should run after 2 seconds&#125;, 2000)// I changed my mindclearTimeout(id) 零延时如果你指定延时时间为 0，这个回调函数将会尽可能快的执行，但是必须等当前函数执行完毕： 12345setTimeout(() =&gt; &#123; console.log('after ')&#125;, 0)console.log(' before ') 会打印出 before after。 通过对调度程序中的函数进行排序，这对于避免在密集型任务上阻塞 CPU 并在执行繁重计算时让其他函数能够执行特别有用。 一些浏览器（IE 和 Edge）实现了 setImmediate() 方法达到上述目的，但是没有成为标准，不能在其它浏览器中使用。但在 Node.js 可用。 setInterval()setInterval 和 setTimeout 类似，区别在于：和只运行一次回调函数不同，它能够在指定的特定时间间隔（以毫秒为单位）一直运行它： 123setInterval(() =&gt; &#123; // runs every 2 seconds&#125;, 2000) 上面的函数每隔两秒运行一次，除非你用 clearInterval 停止它，传入 setInterval返回的间隔 id： 12345const id = setInterval(() =&gt; &#123; // runs every 2 seconds&#125;, 2000)clearInterval(id) 在 setInterval 回调函数中调用 clearInterval 很常见，这让它自己决定是否需要继续运行。例子中的代码会一直运行，除非 App.somethingIWait 的值等于 arrived： 1234567const interval = setInterval(() =&gt; &#123; if (App.somethingIWait === 'arrived') &#123; clearInterval(interval) return &#125; // otherwise do things&#125;, 100) 递归 setTimeoutsetInterval 每隔 n 毫秒执行一次函数，不会考虑函数是否执行完毕。如果函数执行都花费相同的时间，这没有任何问题： 但存在执行时间不一致的可能，比如网络条件导致的： 还有执行时间与下一个重合： 为了避免这个情况，你可以使用递归 setTImeout，在回调函数结束后调用： 12345678const myFunction = () =&gt; &#123; // do something setTimeout(myFunction, 1000)&#125;setTimeout( myFunction()&#125;, 1000) 实现这种情况： setTimeout 和 setInterval 在 Node.js 的 Timers 模块里可用。 Node.js 也提供了 setImmediate()，和使用 setTimeout(() =&gt; {}, 0) 效果一样，主要用在 Node.js 的事件循环。 Thisthis 的值取决于在哪里使用它。不了解这个小细节会让人头大，所以花五分钟时间学习一下它吧。 严格模式的 this严格模式，在对象外的 this 始终是 undefined。 注意我提到了严格模式。如果严格模式没有开启（默认关闭，除非你在文件头部显式添加 use strict），即草率模式（ sloppy mode），没有特别说明，下面提到的 this 都指向全局对象。在浏览器环境里是 window 对象。 方法里的 this方法是附加在对象里的函数。 你可以看到不同的格式，比如： 12345678910const car = &#123; maker: 'Ford', model: 'Fiesta', drive() &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`) &#125;&#125;car.drive()//Driving a Ford Fiesta car! 在这个例子中，使用了常规函数，this 自动绑定了这个对象。 注意：上面的方法声明和 drive: function() {..} 相同，只是更短： 12345678const car = &#123; maker: 'Ford', model: 'Fiesta', drive: function() &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`) &#125;&#125; 在这个例子里也一样： 1234567891011const car = &#123; maker: 'Ford', model: 'Fiesta'&#125;car.drive = function() &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`)&#125;car.drive()//Driving a Ford Fiesta car! 箭头函数与此不同，因为它属于词法绑定： 1234567891011const car = &#123; maker: 'Ford', model: 'Fiesta', drive: () =&gt; &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`) &#125;&#125;car.drive()//Driving a undefined undefined car! 绑定箭头函数你不能像给普通函数那样给箭头函数绑定值。这是因为它们的原理不同，this 是词法绑定，这意味着它的值来自定义它们的上下文。 显式传递 this 指向的对象JavaScript 提供了一种映射 this 和对象的方法。 在函数声明阶段使用 bind()： 1234567891011const car = &#123; maker: 'Ford', model: 'Fiesta'&#125;const drive = function() &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`)&#125;.bind(car)drive()//Driving a Ford Fiesta car! 你也可以重新映射一个已经存在的对象作为 this 值： 123456789101112131415const car = &#123; maker: 'Ford', model: 'Fiesta', drive() &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`) &#125;&#125;const anotherCar = &#123; maker: 'Audi', model: 'A4'&#125;car.drive.bind(anotherCar)()//Driving a Audi A4 car! 在函数调用阶段使用 call() 和 apply()： 1234567891011121314const car = &#123; maker: 'Ford', model: 'Fiesta'&#125;const drive = function(kmh) &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car at $&#123;kmh&#125; km/h!`)&#125;drive.call(car, 100)//Driving a Ford Fiesta car at 100 km/h!drive.apply(car, [100])//Driving a Ford Fiesta car at 100 km/h! 传入 call() 或者 apply() 的第一个参数始终绑定 this。call() 和 apply() 不同之处在于 apply() 传入的作为函数参数的参数是一个数组，而 call() 可以接受多个参数。 浏览器事件处理中的特殊情况在事件处理器的回调中。this 指向收到事件的 HTML 元素： 123document.querySelector('#button').addEventListener('click', function(e) &#123; console.log(this) //HTMLElement&#125;) 你可以这样绑定： 123456document.querySelector('#button').addEventListener( 'click', function(e) &#123; console.log(this) //Window if global, or your context &#125;.bind(this)) 严格模式严格模式是 ES5 的功能，它使 JavaScript 表现得更好 - 开启严格模式可以改变 JavaScript 语言的语义。知道严格模式和一般模式，也经常被称作草率模式，在 JavaScript 代码的不同十分重要。 严格模式主要移除了 ES3 中存在的功能，从 ES5 开始弃用这些功能（考虑到向后兼容的需要没有被删除）。 如何开启严格模式严格模式是可选的。伴随着不兼容的变化，我们不能简单的改变语言的默认行为，这会破坏大量的 JavaScript 代码，而且 JavaScript 花费了巨大的努力确保 1996 年的代码在今天仍然能够生效。这也是它能成功的关键。 所以在我们需要开启严格模式的时候，有了 use strict 指令。你可以把它放在文件的开头，把它应用到整个文件： 123456'use strict'const name = 'Flavio'const hello = () =&gt; 'hey'//... 你也可以在独立的函数中启动严格模式，只需要把 use strict 放在函数体开始的位置： 12345function hello() &#123; 'use strict' return 'hey'&#125; 这对操作那些你没有时间测试或者没有信心在整个文件开启严格模式的历史遗留代码很有用。 严格模式的变化意外的全局变量如果你把值绑定在未声明的变量上，JavaScript 默认会在全局对象上创建这个变量： 12345678;(function() &#123; variable = 'hey'&#125;)()(() =&gt; &#123; name = 'Flavio'&#125;)()variable //'hey'name //'Flavio' 打开严格模式，这样做就会抛出错误： 1234567;(function() &#123; 'use strict' variable = 'hey'&#125;)()(() =&gt; &#123; 'use strict' myname = 'Flavio'&#125;)() 分配错误JavaScript 默默处理了一些转换错误。 在严格模式，这些错误会被展示出来： 1234const undefined = 1(() =&gt; &#123; 'use strict' undefined = 1&#125;)() Infinity，NaN，eval，arguments等等同样如此。 在 JavaScript 中，你可以定义一个不可写的对象属性，比如： 12const car = &#123;&#125;Object.defineProperty(car, 'color', &#123; value: 'blue', writable: false &#125;) 在严格模式下，你不能覆盖这个值，但在草率模式下可以这么做： 和 getters 的原理一样： 12 草率模式下可以扩展一个不可扩展对象： 12345678910const car = &#123; color: 'blue' &#125;Object.preventExtensions(car)car.model = 'Fiesta'( //ok () =&gt; &#123; 'use strict' car.owner = 'Flavio' //TypeError: Cannot add property owner, object is not extensible &#125;)() 而且可以设置原始值的属性，没有任何错误提示，但是也不生效： 12345678true.false = ''( //'' 1).name = 'xxx' //'xxx'var test = 'test' //undefinedtest.testing = true //truetest.testing //undefined 严格模式下这些都不被允许： 123456789;(() =&gt; &#123; 'use strict' true.false = ''( //TypeError: Cannot create property 'false' on boolean 'true' 1 ).name = 'xxx' //TypeError: Cannot create property 'name' on number '1' 'test'.testing = true //TypeError: Cannot create property 'testing' on string 'test'&#125;)() 删除错误草率模式下，如果你尝试删除不能删除的属性值，JavaScript 只会返回 false，但在严格模式，它会抛出 TypeError： 12345678delete Object.prototype( //false () =&gt; &#123; 'use strict' delete Object.prototype //TypeError: Cannot delete property 'prototype' of function Object() &#123; [native code] &#125; &#125;)() 同名函数参数在一般函数中，可能有冲突的参数名： 12345678910(function(a, a, b) &#123; console.log(a, b)&#125;)(1, 2, 3)//2 3(function(a, a, b) &#123; 'use strict' console.log(a, b)&#125;)(1, 2, 3)//Uncaught SyntaxError: Duplicate parameter name not allowed in this context 在这个例子中，箭头函数始终抛出 SyntaxError： 1234((a, a, b) =&gt; &#123; console.log(a, b)&#125;)(1, 2, 3)//Uncaught SyntaxError: Duplicate parameter name not allowed in this context 八进制八进制语法在严格模式下是禁用的。默认情况下，在数字前加上兼容八进制格式的 0 可以把它解释为八进制数字（有时看起来很困惑）： 12345678910(() =&gt; &#123; console.log(010)&#125;)()//8(() =&gt; &#123; 'use strict' console.log(010)&#125;)()//Uncaught SyntaxError: Octal literals are not allowed in strict mode. 你仍然可以通过 0oXX 语法在严格模式下使用八进制数字： 12345;(() =&gt; &#123; 'use strict' console.log(0o10)&#125;)()//8 移除了 with严格模式不能使用 with 关键字，移除了一些边界情况，以使编译器层面可以更好的优化。 立即执行函数（IIFE）立即执行函数在它们被创建的时候就会立即执行。 立即执行函数非常有用，因为它们不会污染全局变量，而且能够隔离变量声明。 立即执行函数的语法是这样的： 123;(function() &#123; /* */&#125;)() 立即执行函数也可以使用箭头函数： 123;(() =&gt; &#123; /* */&#125;)() 基本上，我们把函数定义在圆括号内，然后再后面加上一对 () 执行这个函数：(/* function */)()。 这些括号实际上是使我们的函数在内部被视为表达式的原因，否则，函数声明将是无效的，因为我们没有指定任何名称： 函数声明需要一个名字，而函数表达式不需要。 你也可以把调用括号放在表达式括号里面，这是一样的，仅仅是写法不同： 1234567(function() &#123; /* */&#125;())(() =&gt; &#123; /* */&#125;()) 使用一元运算符在使用 IIFE 时使用任意一元运算符很奇怪，但是在实际运用中却非常有用： 123456789101112131415;-(function() &#123; /* */&#125;)()+(function() &#123; /* */&#125;)()~(function() &#123; /* */&#125;)()!(function() &#123; /* */&#125;)() （箭头函数上无效） 命名的 IIFEIIFE 也可以命名常规函数（不是箭头函数）。这不会导致函数“泄露”到全局作用域，而且在它执行之后也不能再次调用： 123;(function doSomething() &#123; /* */&#125;)() IIFE 前的分号你会看到： 123;(function() &#123; /* */&#125;)() 这是为了防止把两个文件拼合在一起时出现问题。因为 JavaScript 不强制使用分号，你可能会在最后一行中使用某些语句连接一个文件，从而导致语法错误。 这个问题可以通过一种“聪明”的代码打包工具解决，比如webpack。 数学运算符对任何编程语言执行数学运算都是很常见的事情。JavaScript 提供了几个操作符来帮助我们处理数字。 算术运算符加（+）12const three = 1 + 2const four = three + 1 + 运算符也会拼接字符串，所以注意： 123const three = 1 + 2three + 1 // 4'three' + 1 // three1 减（-）1const two = 4 - 2 除（/）返回第一个数字和第二个数字之间商： 12const result = 20 / 5 //result === 4const result = 20 / 7 //result === 2.857142857142857 如果除以 0，JavaScript 不会抛出任何错误，而是返回 Infinity（如果是负值返回 -Infinity）。 121 / 0 //Infinity-1 / 0 //-Infinity 取余（%）取余在很多情况下都很有用： 12const result = 20 % 5 //result === 0const result = 20 % 7 //result === 6 对 0 取余始终是 NaN，意思是“不是一个数字”： 121 % 0 //NaN-1 % 0 //NaN 乘（*）121 * 2 //2-1 * 2 //-2 求幂（**）将第一个操作数乘第二个操作数次数： 123451 ** 2 //12 ** 1 //22 ** 2 //42 ** 8 //2568 ** 2 //64 一元运算符递增（++）递增数字。这是一个一元运算符，如果把它放在数字前面，返回自增后的值。如果把它放在数字后面，先返回初始值，然后递增。 1234let x = 0x++ //0x //1++x //2 递减（–）和递增操作符相似，不过它递减值。 1234let x = 0x-- //0x //-1--x //-2 一元减（-）返回负值 123let x = 2-x //-2x //2 一元加（+）如果目标不是数字，它会尝试转化它。否则什么也不做。 12345678let x = 2+x //2x = '2'+x //2x = '2a'+x //NaN 快速赋值常规的赋值操作符 = 对所有的数学运算符都有一个快捷方式让你能组合赋值，将第一个操作数和第二个操作数的结果赋值给第一个操作数。 它们是： +=：加法赋值 -=：除法赋值 *=：乘法赋值 /=：除法赋值 %=：取余赋值 **=：求幂赋值 例子： 123456const a = 0a += 5 //a === 5a -= 2 //a === 3a *= 2 //a === 6a /= 2 //a === 3a %= 2 //a === 1 优先级每个复杂的语句都会引入优先问题。看这个： 1const a = 1 * 2 + 5 / 2 % 2 结果等于 2.5。但是为什么呢？哪个运算先执行，哪个后执行？ 有些运算符的优先级比其它的高。其优先级遵循以下规则： - + ++ -- 一元运算符，递增，递减 * / % 乘法/除法 + - 加法/减法 = += -= *= /= %= **= 赋值运算 同级运算符（比如 + 和 -）按照顺序执行。 根据上面的顺序，我们可以计算这个式子： 12345const a = 1 * 2 + 5 / 2 % 2const a = 1 * 2 + 5 / 2 % 2const a = 2 + 2.5 % 2const a = 2 + 0.5const a = 2.5 Math 对象Math 对象包含很多数学相关的工具。让我们看看都有什么。 常量 函数所有函数方法都是静态的，Math 不能被继承。 Math.abs()返回数字的绝对值 12Math.abs(2.5) //2.5Math.abs(-2.5) //2.5 Math.acos()返回反余弦值，参数必须在 -1 到 1 之间。 1Math.acos(0.8) //0.6435011087932843 Math.asin()返回反正弦值，参数必须在 -1 到 1 之间。 1Math.asin(0.8) //0.9272952180016123 Math.atan()返回反正切值 1Math.atan(30) //1.5374753309166493 Math.atan2()返回其参数商的反正切值 1Math.atan2(30, 20) //0.982793723247329 Math.ceil()向上取整 1234Math.ceil(2.5) //3Math.ceil(2) //2Math.ceil(2.1) //3Math.ceil(2.99999) //3 Math.cos()用弧度表示角度的余弦值 12Math.cos(0) //1Math.cos(Math.PI) //-1 Math.exp()返回 Math.E 的参数次方 123Math.exp(1) //2.718281828459045Math.exp(2) //7.38905609893065Math.exp(5) //148.4131591025766 Math.floor()向下取整 1234Math.ceil(2.5) //2Math.ceil(2) //2Math.ceil(2.1) //2Math.ceil(2.99999) //2 Math.log()返回基数 e 的自然对数 12Math.log(10) //2.302585092994046Math.log(Math.E) //1 Math.max()返回传入的一系列数字中的最大值 12Math.max(1,2,3,4,5) //5Math.max(1) //1 Math.min()返回传入的一系列数字中的最小值 12Math.max(1,2,3,4,5) //1Math.max(1) //1 Math.pow()返回第一个参数的第二参数次方 1234Math.pow(1, 2) //1Math.pow(2, 1) //2Math.pow(2, 2) //4Math.pow(2, 4) //16 Math.random()返回 0.0 到 1.0 之间的伪随机值 12Math.random() //0.9318168241227056Math.random() //0.35268950194094395 Math.round()四舍五入 12Math.round(1.2) //1Math.round(1.6) //2 Math.sin()用弧度计算角度的正弦值 12Math.sin(0) //0Math.sin(Math.PI) //1.2246467991473532e-16) Math.sqrt()开方 123Math.sqrt(4) //2Math.sqrt(16) //4Math.sqrt(5) //2.23606797749979 Math.tan()用弧度计算角度的正切值 12Math.tan(0) //0Math.tan(Math.PI) //-1.2246467991473532e-16 ES 模块ES 模块是用于处理模块的 ECMAScript 标准。Node.js 长期以来一直使用 CommonJS，然而浏览器还没有模块系统。每个主要决策（如模块系统）必须首先先由 ECMAScript 标准化，然后由浏览器实现。 这个标准化过程在 ES6 中完成，与此同时，浏览器开始逐步实现这个标准，尽力使工作方式保持一致。现在 ES 模块被 Chrome，Safari，Edge 和 Firefox（从 60 版本开始）支持。 模块很酷，它们允许你封装任意功能，然后作为库暴露给其它 JavaScript 文件。 ES 模块语法导入一个模块可以用： 1import package from 'module-name' 然而 CommonJS 使用： 1const package = require('module-name') 一个模块是一个通过 export 导出一个或多个值（对象，函数或变量）的 JavaScript 文件。举个例子，这个模块导出了一个大写字符串的函数： uppercase.js 1export default str =&gt; str.toUpperCase() 在这个例子中，模块定义了一个唯一的，默认导出（default export），所以它可以是一个匿名函数。否则它需要一个名字来区分其它的导出。现在，其它任何的 JavaScript 模块都可以通过导入 uppercase.js 导入这个函数。 一个 HTML 页面可以通过 &lt;script&gt; 标签上特殊的 type=&quot;module&quot; 属性添加一个模块： 1&lt;script type="module" src="index.js"&gt;&lt;/script&gt; 注意：模块导入行为和 defer 脚本加载类似。查看使用延迟和异步高效加载 JavaScript。 重要的是任何有 type=&quot;module&quot; 的模块都是以严格模式加载的。 在这个例子中，uppercase.js 模块定义了一个默认导出，所以我们可以导入这个模块，还能够给它绑定一个我们喜欢的名字： 1import toUpperCase from './uppercase.js' 然后我们可以使用它： 1toUpperCase('test') //'TEST' 你也可以使用绝对路径导入模块，以便引用其它域名中定义的模块： 1import toUpperCase from 'https://flavio-es-modules-example.glitch.me/uppercase.js' 这种语法也是有效的： 12import &#123; foo &#125; from '/uppercase.js'import &#123; foo &#125; from '../uppercase.js' 这种不行： 12import &#123; foo &#125; from 'uppercase.js'import &#123; foo &#125; from 'utils/uppercase.js' 路径必须是绝对路径，或在名字前加上 ./ 或者 /。 其它导入/导出方法我们已经知道这个例子： 1export default str =&gt; str.toUpperCase() 这创建了一个默认的导出。然而在一个文件中你可以导出多个内容，比如： 12345const a = 1const b = 2const c = 3export &#123; a, b, c &#125; 另一个模块可以导入所有： 1import * from 'module' 你可以只选择导入部分内容，使用解构绑定： 12import &#123; a &#125; from 'module'import &#123; a, b &#125; from 'module' 你也可以导入默认导出，然后通过名字导入没有默认导出的内容，就像常见的导入 React： 1import React, &#123; Component &#125; from 'react' 在这里查看 ES 模块的示例。 跨域资源共享 CORS通过 CORS 获取模块，意味着如果你从其它域名引入脚本，他们必须有一个有效的 CORS 头允许跨网页加载（像 Access-Control-Allow-Origin）。 不支持模块的浏览器怎么办？结合使用 type=module 和 nomodule： 12&lt;script type="module" src="module.js"&gt;&lt;/script&gt;&lt;script nomodule src="fallback.js"&gt;&lt;/script&gt; 总结ES 模块是现代浏览器引入的最重要的功能。它们是 ES6 的一部分，但实现它们的过程很漫长。 现在我们可以使用它们！但是我们也必须知道多个模块会影响页面的性能，因为这是浏览器必须执行的一步。 即使 ES 模块已经在浏览器端登陆，Webpack 也将扮演重要的角色，但是直接用语言构建这样的功能对于统一模块在客户端和 Node.js 上的工作方式来说任务繁重。 CommonJSCommonJS 模块规范是 Node.js 中的模块标准。 浏览器端的 JavaScript 采用 ES 模块。 它们让你能够创建易于分割且可复用的代码片段，每个片段都可以独立测试。 庞大的 npm 生态环境就建立在 CommonJS 格式之上。 导入模块的语法如下： 1const package = require('module-name') 在 CommonJS 中，模块同步加载，按照 JavaScript 运行时找到的顺序执行。这个系统原本为服务器端 JavaScript 而生，不兼容客户端（这也是为什么引入 ES 模块）。 JavaScript 文件是导出一个或多个其中定义的符号的模块，它们可以是变量，函数，对象： uppercase.js 1exports.uppercase = str =&gt; str.toUpperCase() 任何 JavaScript 文件都可以导入并且使用这个模块： 12const uppercaseModule = require('uppercase.js')uppercaseModule.uppercase('test') 在 Glitch 上的简单例子。 你可以导出多个值： 123exports.a = 1exports.b = 2exports.c = 3 通过解构赋值单独导入每一个值： 1const &#123; a, b, c &#125; = require('./uppercase.js') 或者只导出一个值： 12//file.jsmodule.exports = value 然后导入： 1const value = require('./file.js') 词汇表最后，一些前端开发的术语可能和你理解的不同。 异步异步代码是当你启动某个内容，可以先忘掉它，无需刻意等待，当结果准备就绪你会自动得到它。典型的例子就是 AJAX 调用，可能会占用很多秒，与此同时你可以完成其它事情，当获取响应，回调函数会被调用。Promises 和 async/await 是处理异步代码更现代的方法。 块（block）在JavaScript中，块由大括号（{}）做区隔，一个if语句包含一个块,一个for循环也包含一个块。 块级作用域块级作用域里任何定义在块内的变量对整个块可见，可以在内部访问，不能在块外部访问。 回调回调是一个事件发生时调用的函数。元素绑定的点击事件在用户点击了元素时调用。一个 fetch 请求的回调在资源下载完成后调用。 声明声明方法是你说明细节，告诉机器你需要做什么。React 被认为是声明式的，理由是更注重抽象推理而不是直接编辑 DOM。每个高级编程语言都比低级编程语言，如 Assembler，更具声明性。JavaScript 比 C 语言更加声明性，HTML 也是声明性的。 回退回退用来在用户无法访问特定功能时提供更好的体验。比如浏览器关闭了 JavaScript，用户应该得到一个原生版本的 HTML 页面。或者遇到浏览器没有实现的 API，你应该有一个可靠的办法避免严重影响用户体验。 函数作用域函数作用域里任何定义在函数内的变量对整个函数可见，可以在函数内部访问，不能在函数外部访问。 一致性一个变量的值在创建之后不能改变，我们就称这变量是不变的。可变变量是可变的。这在数组和对象里都一样。 词法作用域词法作用域是一个特定作用域，父函数的变量可以在内部函数使用。内部函数的作用域也包括父函数的作用域。 PolyfillPolyfill 用来为旧浏览器提供它没有原生支持的现代浏览器具有的新功能。Polyfill 是一种特殊的 shim。 纯函数（pure function）纯函数是一个没有副作用（不会修改外部资源），这种函数的输出结果只取决于传入的参数。你可以调用函数一百万次，每次都用相同的参数，输出始终保持一致。 重新赋值var 和 let 允许你无数次地为变量重新赋值。const 声明了一个不可变的字符串，整型，布尔值，对象（但是你仍然可以通过提供的方法修改它）。 域域是一系列变量对于程序可见的部分。 作用域作用域是编程语言里定义的决定变量值的一系列规则。 ShimShim 包含了许多功能或者 API。它通常用于抽象内容，预填充参数或为不支持某些功能的浏览器添加 polyfill。你可以把它看作兼容层。哈哈 副作用副作用是一个函数与其它函数或者对象进行交互。与网络、文件系统或者是 UI 交互都有副作用。 状态（state）谈到组件时，不得不提到状态。一个组件管理数据是有状态的，否则是无状态的。 有状态（stateful）一个有状态的组件，函数或者类会自己管理自己的状态（数据）。它可以存储一个数组，一个计时器或者其它的东西。 无状态（stateless）一个无状态的组件，函数或者类也被称作 dumb，因为它无法使用自己的数据做出决定，所以它的输出或者展示完成基于它的参数。这意味着纯函数是无状态的。 严格模式严格模式是 ECMAScipt 5.1 的新功能，它会导致 JavaScript 运行时捕捉更多的错误，但是它可以通过拒绝未声明的变量和冲突的对象属性等其他容易被忽视的问题来帮助你改进 JavaScript 代码。建议：使用严格模式。另一个“非严格模式”看名字就知道不是什么好东西。 Tree ShakingTree Shaking 意味着从你打包发送给用户的代码中删除未引用代码。如果你在很重要语句中添加了从来不会用到的代码，它不会发送给你的应用用户，以此减少文件体积和加载时间。 感谢阅读！ 注意：你可以获取这篇 JavaScript 指南的 PDF, ePub, Mobi 版本以便在 Kindle 或平板上阅读。 转自https://juejin.im/post/5bff57fee51d45021a167991 参照原文做了部分更正。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双波浪号JavaScript运算符的使用]]></title>
    <url>%2F2018%2F11%2F30%2F%E5%8F%8C%E6%B3%A2%E6%B5%AA%E5%8F%B7JavaScript%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[~是二进制的按位取反,~~可以理解为是取整的简写 1234567891011~~null; // =&gt; 0~~undefined; // =&gt; 0~~0; // =&gt; 0~~&#123;&#125;; // =&gt; 0~~[]; // =&gt; 0~~(1/0); // =&gt; 0~~false; // =&gt; 0~~true; // =&gt; 1~~1.2543; // =&gt; 1~~4.9; // =&gt; 4~~(-2.999); // =&gt; -2 对于非数字（包括0）, ~ ~的结果为0,布尔的true是1；对于大于0的数, ~ ~相当于是Math.floor；对于小于0的数,~~相当于是Math.ceil ~~在性能上来说更快.]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中for...in循环与for...of循环的执行效率和使用]]></title>
    <url>%2F2018%2F11%2F30%2Fjavascript%E4%B8%ADfor-in%E5%BE%AA%E7%8E%AF%E4%B8%8Efor-of%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[for…in性能这么慢,因为它要遍历自身的属性和原型链上的属性,这无疑就增加了所有不必要的额外开销. 对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名。 1234567891011121314151617let es6 = &#123; edition: 6, committee: "TC39", standard: "ECMA-262"&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// TypeError: es6[Symbol.iterator] is not a function 上面代码表示，对于普通的对象，for…in循环可以遍历键名，for…of循环会报错。 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125; 经验就是：鉴于for of 循环比for in循环要快，在有性能需要的情况下，可以考虑将for in 循环更改成for of 循环，前提是使用Object.keys()将对象循环转为对数组进行循环。 参考：http://es6.ruanyifeng.com/#docs/iterator]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改hosts文件的作用与方法]]></title>
    <url>%2F2018%2F11%2F30%2F%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是hosts文件？hosts是一个没有扩展名的系统文件，其基本作用就是将一些常用的网址域名与其对应的 IP 地址建立一个关联“ 数据库 ”。当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从hosts文件中寻找对应的 IP 地址，一旦找到，系统就会立即打开对应网页，如果没有找到，则系统会将网址提交 DNS 域名解析服务器进行 IP 地址的解析。 hosts文件的作用加快域名解析对于经常访问的网站，咱们可以通过在hosts文件中配置域名和 IP 的映射关系，提高域名的解析速度。由于有了映射关系，当咱们输入域名后，计算机就能够快速解析出 IP 地址，而不用请求网络上的 DNS 服务器。 构建映射关系在很多单位中，都会有自己局域网，而且还会有不同的服务器提供给公司的成员使用。但由于局域网中一般很少架设 DNS 服务器，因此在访问这些服务器时，就需要输入难记的 IP 地址，这对大家来说相当麻烦。因此，咱们可以分别给这些服务器取个容易记住的名字，然后在hosts文件中建立 IP 映射，这样在以后访问的时候，只要输入这个服务器的名字就 OK 啦！ 屏蔽垃圾网站现在有很多网站，在不经过咱们同意的时候，就将各种各样的插件安装到咱们的计算机中，其中不乏病毒和木马。对于这些网站，咱们就可以利用hosts文件把这些网站的域名映射到一个错误的 IP 或本地计算机的 IP 地址上，这样就可以达到禁止访问的目的啦！ 修改hosts文件的方法由于 hosts 文件属性系统文件，因此需要管理员权限才能对其进行修改。 第一种方法：先将权限修改成管理员权限，然后在对其进行修改。第二种方法：先将hosts文件复制到桌面，这时就不需要管理员权限了，因此可以对其进行修改了，等修改之后，在将其拖回原目录，替换就可以啦！在 iOS 系统中中，hosts文件的位置为：~/private/etc 在 Windows 系统中，hosts文件的位置为：C:\Windows\System32\drivers\etc hosts文件修改示例： 202.108.22.5 www.baidu.com 如上所示，咱们在本地的hosts文件中，将百度的 IP 地址与百度的域名建立了映射关系，也就起到了“加快域名解析”的作用，因为不需要再去请求 DNS 服务器啦！此外，如果咱们想要对其进行注释的话，直接在前面加#符号就可以，例如： #202.108.22.5 www.baidu.com]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>开发实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue开发小知识点整理]]></title>
    <url>%2F2018%2F11%2F30%2Fvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇用于总结vue日常开发中会用到，但是经常踩坑或闹不太清楚的知识点，持续更新。 vue中template标签嵌套的作用123456789&lt;template&gt; &lt;div class=&quot;mainedit&quot;&gt; &lt;template v-if=&quot;renderStatus&gt;=0 &amp;&amp; renderStatus&lt;8&quot;&gt; &lt;em&gt;&#123;&#123;renderMsg&#125;&#125;&lt;strong class=&quot;dotting&quot;&gt;&lt;/strong&gt;&lt;/em&gt; &lt;span&gt;&lt;ins :style=&quot;&#123;width:percent&#125;&quot;&gt;&lt;/ins&gt;&lt;/span&gt; &lt;b v-html=&quot;percent&quot;&gt;&lt;/b&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt; template不会渲染成元素，用div的话会被渲染成元素。把if,show,for等语句抽取出来放在template上面，把绑定的事件放在temlpate里面的元素上，可以使html结构更加清晰，还可以改善一个标签过长的情况。 一个具体的跨组件tab切换功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;rightpart&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a @click=&quot;changeTab(1)&quot; :class=&quot;tabIndex==1?&apos;on&apos;:&apos;&apos;&quot;&gt; &lt;i class=&quot;fa fa-picture-o&quot;&gt;&lt;/i&gt; &lt;span&gt;图片&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a @click=&quot;changeTab(2)&quot; :class=&quot;tabIndex==2?&apos;on&apos;:&apos;&apos;&quot;&gt; &lt;i class=&quot;fa fa-music&quot;&gt;&lt;/i&gt; &lt;span&gt;音乐&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;keep-alive&gt; &lt;div class=&quot;funcwrap&quot; :class=&quot;&#123;&apos;closed&apos;:!isShow&#125;&quot;&gt; &lt;picfunc v-if=&quot;tabIndex == 1&quot;&gt;&lt;/picfunc&gt; &lt;musicfunc v-if=&quot;tabIndex == 2&quot;&gt;&lt;/musicfunc&gt; &lt;/div&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import picfunc from &quot;./right/PicFunc&quot;; import musicfunc from &quot;./right/MusicFunc&quot;; import &#123;mapState&#125; from &quot;vuex&quot;; export default &#123; computed: &#123; ...mapState([&quot;tabIndex&quot;]) &#125;, components: &#123; picfunc, musicfunc &#125;, methods:&#123; //更新打开窗口 changeTab(tab) &#123; var params = &#123;&#125;; params.index = tab; this.$store.dispatch(&quot;changeTab&quot;, params); &#125;, &#125; &#125;&lt;/script&gt; vuex相关 1234567891011121314151617181920212223//index.jsconst state = &#123; tabIndex: -1&#125;//mutation-types.jsexport const CHANGETAB= 'CHANGETAB'//mutations.jsimport &#123;CHANGETAB&#125; from './mutation-types.js'export default &#123; [CHANGETAB](state, params) &#123; state.tabIndex = params.index; &#125;&#125;//actions.jsimport &#123;CHANGETAB&#125; from './mutation-types.js'export default &#123; changeTab(&#123;commit&#125;, params) &#123; commit(CHANGETAB, params) &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview组件库实现自定义modal]]></title>
    <url>%2F2018%2F11%2F24%2Fiview%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89modal%2F</url>
    <content type="text"><![CDATA[最近业务中有这样一项需求：使用iview组件库实现一个自定义的modal。查了下iview官方文档，并没有这方面的详细说明，举的例子也不能够满足需要，于是就开始自己试着去实现。 实现效果 Modal.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;Row&gt; &lt;Form :rules=&quot;ruleValidate&quot; :model=&quot;formValidate&quot;&gt; &lt;FormItem label=&quot;标题：&quot; prop=&quot;tit&quot;&gt; &lt;Input v-model=&quot;formValidate.tit&quot; placeholder=&quot;请输入标题&quot; @on-change=&quot;titChange&quot;&gt;&lt;/Input&gt; &lt;/FormItem&gt; &lt;FormItem label=&quot;描述：&quot; prop=&quot;des&quot;&gt; &lt;Input v-model=&quot;formValidate.des&quot; placeholder=&quot;请输入描述&quot; type=&quot;textarea&quot; :autosize=&quot;&#123;minRows: 2,maxRows: 5&#125;&quot; @on-change=&quot;desChange&quot;&gt;&lt;/Input&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;/Row&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;Modal&apos;, data() &#123; return &#123; formValidate:&#123; tit:&apos;&apos;, des:&apos;&apos; &#125;, ruleValidate:&#123; tit:[ &#123;required: true, message: &apos;标题不能为空&apos;, trigger: &apos;blur&apos;&#125;, &#123;type: &apos;string&apos;, max: 3, message: &apos;最多可填三个字&apos;,trigger: &apos;blur&apos;&#125; ], des:[ &#123; required: true, message: &apos;描述不能为空&apos;, trigger: &apos;blur&apos; &#125;, &#123; type: &apos;string&apos;, min: 10, message: &apos;请填入至少十个字&apos;, trigger: &apos;blur&apos; &#125; ] &#125; &#125; &#125;, methods:&#123; // 将表单填入的数据传给RightPart.vue titChange:function() &#123; this.$emit(&apos;tit&apos;, this.formValidate.tit) &#125;, desChange:function() &#123; this.$emit(&apos;des&apos;, this.formValidate.des) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; RightPart.vue 点击a标签，弹出modal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;template&gt; &lt;div class=&quot;rightpart&quot;&gt; &lt;div class=&quot;temp&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in storyList&quot;&gt; &lt;p&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;a class=&quot;deleteitem&quot;&gt; &lt;Icon type=&quot;ios-close-circle-outline&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a @click=&quot;addStory()&quot;&gt;+&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import modal from &apos;./Modal&apos;; export default &#123; name: &quot;rightpart&quot;, components: &#123; modal &#125;, data() &#123; return &#123; title:&apos;&apos;, description:&apos;&apos;, storyList:[] &#125;; &#125;, methods: &#123; addStory() &#123; this.$Modal.confirm(&#123; title:&apos;创建故事&apos;, render: (h) =&gt; &#123; return h(modal, &#123; props: &#123; //若父组件有需要传递给内容组件的参数，需要在props中填入 &#125;, on: &#123; tit: (tit) =&gt; &#123; this.title = tit &#125;, des: (des) =&gt; &#123; this.description = des &#125; &#125; &#125;) &#125;, onOk: () =&gt; &#123; // 获取组件Modal传过来的值 var modalInfo = &#123; title: this.title, description:this.description &#125; this.storyList.push(modalInfo); &#125; &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>iview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuejs数据绑定更新视图与传统dom操作比较]]></title>
    <url>%2F2018%2F11%2F24%2Fvuejs%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%BC%A0%E7%BB%9Fdom%E6%93%8D%E4%BD%9C%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[前几天写代码的时候突发奇想，想试试同一个功能先用vue来实现一次，再使用传统dom操作来实现一次。功能很简单，但实际操作一次，也能让我对MVVM思想和传统dom操作思想有一个感官的比较和认识。 SubComp.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div @click=&quot;transforData(subtemplate)&quot;&gt; &lt;img :src=&quot;ALIOSS_DOMAIN + &apos;template/&apos; + subtemplate.path + &apos;/&apos; + subtemplate.thumb&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &quot;../bus/eventBus.js&quot;;export default &#123; methods: &#123; transforData(obj) &#123; eventBus.$emit(&apos;transforData&apos;,&#123; title:obj.title, path:obj.path, thumb:obj.thumb &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Story.vue 传统dom操作 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;tabcont&quot;&gt; &lt;ul ref=&quot;storyItem&quot;&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &quot;../bus/eventBus.js&quot;;export default &#123; created() &#123; //获取subcomp传过来的数据并进行处理 eventBus.$on(&quot;transforData&quot;,function(obj)&#123; var li = document.createElement(&quot;li&quot;); li.innerHtml = &quot;&lt;img src=&quot;ALIOSS_DOMAIN + &apos;template/&apos; + obj.path + &apos;/&apos; + obj.thumb+&quot;&gt;&quot;+&quot;&lt;span&gt;&quot; + obj.title+&quot;&lt;span&gt;&quot;+&quot;&lt;a class=&apos;deletepic&apos;&gt;&lt;/a&gt;&quot;; this.$refs.storyItem.appendChid(li); //追加的节点绑定事件是无效的 &#125;) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Story.vue vue操作 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;ul class=&quot;tabcont&quot;&gt; &lt;li v-for=&quot;item in myMaterial&quot;&gt; &lt;img :src=&quot;ALIOSS_DOMAIN + &apos;template/&apos; + item.path + &apos;/&apos; + item.thumb&quot;&gt; &lt;span&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;a class=&quot;deletepic&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &quot;../bus/eventBus.js&quot;;export default &#123; data() &#123; return &#123; myMaterial:[] &#125; &#125;, created() &#123; //获取subcomp传过来的数据并进行处理 eventBus.$on(&apos;transforData&apos;,function (obj) &#123; this.myMaterial.push(obj) &#125;.bind(this)) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 可以看得出来，即使撇开性能不论，传统dom操作的写法也是让人抓狂的，拼接字符串既增加了写代码的难度也增加了读代码的难度，Vue操作中虽然模板增加了不少内容，但摒弃了拼接字符串的弊端，简单清晰许多。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2018%2F11%2F24%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件通信是vue项目中几乎必须做的事情，vue中实现组件通信的场景，包括父子组件通信，非父子组件通信两种；而通信手段，则包括： （1）props down,events up(父子组件通信) （2）bus事件总线 （3）vuex通信 下面根据本人项目中的实践，具体来说说如何进行组件通信。 props down,events up（一）父组件向子组件传值 1.创建子组件，在src/components/文件夹下新建一个子组件2.在子组件中创建props，然后创建一个名为message的属性 Child.vue 1234567891011121314&lt;template&gt;&lt;div&gt;&lt;h2&gt;Child子组件&lt;/h2&gt;&lt;!--此时message即显示为“我是要传给子组件的数据”--&gt;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; props:[&quot;message&quot;]&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3、创建父组件，在src/components/文件夹下再创建一个父组件 4、在父组件中注册子组件，并在template中加入child标签，标签中添加message属性并赋值 Parent.vue 12345678910111213141516&lt;template&gt;&lt;div&gt;&lt;child message=&quot;我是要传给子组件的数据&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &apos;./Child&apos;;export default&#123; name:&quot;parent&quot;, components:&#123; child &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 父组件向子组件传值总结： 子组件在props中创建一个属性，用以接收父组件传过来的值； 父组件中注册子组件； 在子组件标签中添加子组件props中创建的属性； 把需要传给子组件的值赋给该属性； (二)子组件向父组件传值 1.在子组件中创建一个按钮，给按钮绑定一个点击事件 2.在响应该点击事件的函数中使用$emit来触发一个自定义事件，并传递一个参数 Child.vue 12345678910111213141516171819&lt;template&gt;&lt;div&gt;&lt;h2&gt;Child子组件&lt;/h2&gt;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;button @click=&quot;sendMessageToParent()&quot;&gt;&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; props:[&quot;message&quot;], methods:&#123; sendMessageToParent()&#123; this.$emit(&quot;listenToChildEvent&quot;,&quot;我是子组件传过来的数据&quot;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.在父组件中的子标签中监听该自定义事件并添加一个响应该事件的处理方法 Parent.vue 123456789101112131415161718192021&lt;template&gt;&lt;div&gt;&lt;child message=&quot;我是要传给子组件的数据&quot; @listenToChildEvent=&quot;showMessageFromChild()&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &quot;./Child&quot;;export default&#123; name:&quot;parent&quot;, components:&#123; child &#125;, methods:&#123; showMessageFromChild(data)&#123; console.log(data); // data即为子组件传过来的数据 &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件向父组件传值总结： 子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件； 将需要传的值作为$emit的第二个参数，该值将作为实参传给响应自定义事件的方法； 在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听； bus事件总线(非父子组件通信)如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，之后通过分别调用Bus事件触发和监听来实现组件之间的通信和参数传递。 1.添加一个bus.js 123456789├── node_modules├── src ├── assets ├── components ├── data ├── bus ├── bus.js └── store ├── actions.js bus.js 12import Vue from "vue"export default new Vue; 2.在需要通信的组件都引入bus.js compoment1.vue 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;bus()&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;import Bus from &apos;./bus/bus.js&apos; ;export default &#123; data() &#123; return &#123; message: &quot;&quot; &#125; &#125;, methods: &#123; bus () &#123; Bus.$emit(&apos;msg&apos;, &apos;我是要传给你的信息&apos;); //$emit函数的第二个参数即为要传递的数据 &#125; &#125;&#125;&lt;/script&gt; component2.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;!--此时message即显示为“我是要传给你的信息”--&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bus from &quot;./bus/bus.js&quot;;export default &#123; data() &#123; return &#123; message: &quot;&quot; &#125; &#125;, mounted() &#123; let self = this; Bus.$on(&apos;msg&apos;, (e) =&gt; &#123; self.message = e console.log(`传来的数据是：$&#123;e&#125;`) //$on事件的回调函数的参数即为接收到的数据； &#125;) &#125; &#125;&lt;/script&gt; 非父子组件数据传递总结： 创建一个事件总线，用它作为通信桥梁; 在需要传值的组件中用bus.$emit触发一个自定义事件，并传递参数; 在需要接收数据的组件中用bus.$on监听自定义事件，并在回调函数中处理传递过来的参数; Vuex传值如果说bus事件总线是为了处理简单场景下的数据传递，那么vuex则是为了复杂场景下的数据传递而设计。 关于Vuex，建议参阅https://www.jianshu.com/p/054486340a9b 以后有时间的话，我会单开一篇来说说vuex。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以一个实例入门nodejs]]></title>
    <url>%2F2018%2F11%2F20%2F%E4%BB%A5%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%85%A5%E9%97%A8nodejs%2F</url>
    <content type="text"><![CDATA[构建一个基础的http服务器 server.js 在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。 123456789101112131415161718var http = require("http");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); //发送一个HTTP状态和HTTP头的内容类型 response.write("Hello World"); //在HTTP相应主体中发送文本 response.end(); //调用 response.end() 完成响应&#125;).listen(8888);//orvar http = require("http");function onRequest(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end();&#125;//我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行回调 。http.createServer(onRequest).listen(8888); 创建及使用属于自己的模块 server.js 把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 导出 到请求这个模块的脚本 123456789101112131415var http = require("http");function start() &#123; function onRequest(request, response) &#123; console.log("Request received."); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log("Server has started.");&#125;exports.start = start; index.js 我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。 123var server = require("./server");server.start(); 请求路由 start.js 1234567891011121314151617var http = require("http");var url = require("url");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; //使用url模块解析请求的url console.log("Request for " + pathname + " received."); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log("Server has started.");&#125;exports.start = start; router.js 编写路由 12345function route(pathname) &#123; console.log("About to route a request for " + pathname);&#125;exports.route = route; 扩展start函数，将路由函数作为参数传递进去 1234567891011121314151617181920var http = require("http");var url = require("url");function start(route) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log("Request for " + pathname + " received."); route(pathname); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log("Server has started.");&#125;exports.start = start; 扩展index.js，使得路由函数可以被注入到服务器中 1234var server = require("./server");var router = require("./router");server.start(router.route); 启动应用（node index.js），随后请求一个URL，将会看到应用输出相应的信息，这表明HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由。 123bash$ node index.jsRequest for /foo received.About to route a request for /foo]]></content>
      <categories>
        <category>web前端</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[querySelector*和getElementBy*方法的区别]]></title>
    <url>%2F2018%2F11%2F19%2FquerySelector%E5%92%8CgetElementById%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[区别（1）querySelector属于 W3C 中的 Selectors API 规范，而getElementsBy 系列则属于 W3C 的 DOM 规范。 （2）querySelector*方法接收的参数是一个 CSS 选择符,其中querySelector()是用于接收一个CSS选择符，返回与该模式匹配的第一个元素；querySelectorAll()用于选择匹配到的所有元素；而 getElementsBy 系列接收的参数只能是单一的className、tagName 和 name等。 （3）querySelector选择符选出来的元素及元素数组是静态的，而getElementsBy 方法选出的元素是动态的。 说明querySelector list 是一个静态的 Node List，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。 12345678910111213141516&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var ul=document.querySelector('ul');var list=ul.querySelectorAll('li');for(var i=0;i&lt;list.length;i++)&#123; ul.appendChild(document.createElement('li'));&#125;//这个时候就创建了3个新的li，添加在ul列表上。console.log(list.length);// 输出的结果仍然是3，不是此时li的数量6&lt;/script&gt; getElementById list 是一个动态的 Node List， 每一次调用 lis 都会重新对文档进行查询，导致无限循环的问题。 12345678910111213&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var ul=document.getElementsByTagName('ul')[0];var list=ul.getElementsByTagName('li');for(var i=0;i&lt;5;i++)&#123; ul.appendChild(document.createElement('li'));&#125;console.log(list.length)//此时输出的结果就是3+5=8&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将异步请求callback转换为同步请求promise]]></title>
    <url>%2F2018%2F11%2F16%2F%E5%A6%82%E4%BD%95%E5%B0%86%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82callback%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82promise%2F</url>
    <content type="text"><![CDATA[promise的出现，解决了回调函数因为层层嵌套导致的可读性差问题。那么，对于老项目大量存在的异步回调，如何使用promise进行改造呢？ 每个promise都有三个状态。pending、Fulfilled、Rejected。最初为pending，状态一但改变为Fulfilled、Rejected中的一种，即成永远，不再改变。 pending: 等待状态。 Fulfilled: 表示成功完成。 Rejected: 表示被拒绝，失败。 原生ajax请求及promise改造12345678910111213141516171819202122232425262728293031323334353637// 原生ajax请求function nativeRequest(url) &#123;var xhr = new XMLHttpRequest()// 这里我建议的书写顺序是： onreadystatechange -&gt; open -&gt; send// 这样，onreadystatechange 可以获取 readyState 的状态 1 2 3 4xhr.onreadystatechange = function () &#123;if (xhr.readyState === 4) &#123; // 请求已完成，且响应已就绪if (xhr.status === 200) &#123;// TODO: 处理返回正常的数据 xhr.responseText&#125; else &#123;// TODO: 处理返回非正常的数据&#125;&#125;&#125;xhr.open('GET', url, true)xhr.send(null)&#125;// promise请求function promiseRequest(url) &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; resolve(xhr.responseText) &#125; else &#123; reject(xhr.responseText) &#125; &#125; &#125; xhr.open('GET', xhr, true) xhr.send(null) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125; jquery中的ajax请求及promise改造1234567891011121314151617181920212223242526272829//jQuery的ajax请求function ajaxResponse(url) &#123;$.ajax(&#123;url: url,type: 'GET',success: res =&gt; &#123;console.log(res)&#125;,error: err =&gt; &#123;console.log(err)&#125;&#125;)&#125;//promise改造function promiseAjaxResponse(url, &#123;type = 'GET',&#125; = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url, type, success: res =&gt; &#123; resolve(res) &#125;, error: err =&gt; &#123; reject(err) &#125; &#125;) &#125;)&#125; node风格的callback请求及promise改造1234567891011nodeGet(param, function (err, data) &#123; &#125;)//promise改造function nodeGetAysnc(param) &#123; return new Promise((resolve, reject) =&gt; &#123; nodeGet(param, function (err, data) &#123; if (err !== null) return reject(err) resolve(data) &#125;) &#125;)&#125; DOM load事件或者其他一次性事件请求及promise改造12345678910111213function load() &#123;console.log('onload - end')&#125;window.onload = load// promise改造function promiseLoad() &#123; return new Promise(function (resolve, reject) &#123; window.onload = resolve &#125;)&#125;promiseLoad().then(load) 转自https://www.cnblogs.com/weiqinl/p/9651515.html]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hasOwnProperty方法的使用]]></title>
    <url>%2F2018%2F11%2F16%2FhasOwnProperty%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。 判断自身属性是否存在123456789var o = new Object();o.prop = 'exists';function changeO() &#123;o.newprop = o.prop;delete o.prop;&#125;o.hasOwnProperty('prop'); // truechangeO();o.hasOwnProperty('prop'); // false 判断自身属性与继承属性1234567891011121314151617function foo() &#123;this.name = 'foo'this.sayHi = function () &#123;console.log('Say Hi') &#125;&#125;foo.prototype.sayGoodBy = function () &#123;console.log('Say Good By')&#125;let myPro = new foo()console.log(myPro.name) // fooconsole.log(myPro.hasOwnProperty('name')) // trueconsole.log(myPro.hasOwnProperty('toString')) // falseconsole.log(myPro.hasOwnProperty('hasOwnProperty')) // fasleconsole.log(myPro.hasOwnProperty('sayHi')) // trueconsole.log(myPro.hasOwnProperty('sayGoodBy')) // falseconsole.log('sayGoodBy' in myPro) // true 遍历一个对象的所有自身属性使用for…in循环对象的所有枚举属性，然后再使用hasOwnProperty()方法来忽略继承属性。 12345678910var buz = &#123;fog: 'stack'&#125;;for (var name in buz) &#123;if (buz.hasOwnProperty(name)) &#123; alert("this is fog (" + name + ") for sure. Value: " + buz[name]); &#125; else &#123; alert(name); // toString or something else &#125;&#125; 使用 hasOwnProperty 作为属性名JavaScript 并没有保护 hasOwnProperty 属性名，因此某个对象是有可能存在使用这个属性名的属性的。 1234567891011121314var foo = &#123; hasOwnProperty: function() &#123; return false; &#125;, bar: 'Here be dragons'&#125;;foo.hasOwnProperty('bar'); // 始终返回 false// 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法(&#123;&#125;).hasOwnProperty.call(foo, 'bar'); // true// 也可以使用 Object 原型上的 hasOwnProperty 属性Object.prototype.hasOwnProperty.call(foo, 'bar'); // true]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JavaScript中的this]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[ES6中新增了箭头函数这种语法,箭头函数以其简洁性和方便获取this的特性,俘获了大批粉丝儿。 它也可能是面试中的宠儿, 我们关键要搞清楚箭头函数和普通函数中的this。 普通函数中的this 1.this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj。 2.在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成)。 3.在严格模式下,没有直接调用者的函数中的this是 undefined。 4.使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象。 箭头函数中的this 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中使用this。 下面通过一些例子来研究一下 this的一些使用场景。 要整明白这些, 我们需要首先了解一下作用域链: 当在函数中使用一个变量的时候,首先在本函数内部查找该变量,如果找不到则找其父级函数,最后直到window,全局变量默认挂载在window对象下。 全局变量默认挂载在window对象下123456var aa = 2;console.log(window.aa); //2(function () &#123; aa = 3;&#125;)();console.log(window.aa); //3 我们仅仅声明了一个全局变量aa,但是打印出window.aa却和aa保持一致,为什么呢? 我们可以看到在window属性中,看到 aa 属性了;此外,函数也适用于此情况,全局函数也会挂在window对象下 我们常见的window的属性和方法有: alert, location,document,parseInt,setTimeout,setInterval等,window的属性默认可以省略window前缀! 普通函数中的this普通函数中的this指向它的直接调用者;如果找不到直接调用者,则是window。 我们来看一些例子。 示例1: 1234function test() &#123; console.log(this);&#125;test(); 结果是: window 。 原因: test()是一个全局函数,也就是说是挂在window对象下的,所以test()等价于 window.test() ,所以此时的this是window。 示例2: 12345678var obj = &#123; say: function () &#123; setTimeout(function () &#123; console.log(this) &#125;); &#125;&#125;obj.say(); 结果是: window。 匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window。 问题: 如果想要在setTimeout/setInterval中使用这个对象的this引用呢? 用一个变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针! 1234567891011var obj = &#123; func: function() &#123;&#125;, say: function () &#123; var that = this; //此时的this就是obj对象 setTimeout(function () &#123; console.log(this) that.func() &#125;); &#125;&#125;obj.say(); 我们也可以使用 func.bind(this) 给回调函数直接绑定宿主对象, bind绑定宿主对象后依然返回这个函数, 这是更优雅的做法： 1234567891011var obj = &#123; func: function() &#123;&#125;, say: function () &#123; // 此时的this就是obj对象 setTimeout(function () &#123; console.log(this) this.func() &#125;.bind(this)); &#125; &#125; obj.say(); // obj 示例3： 1234567891011121314window.val = 1;var obj = &#123; val: 2, dbl: function () &#123; this.val *= 2; val *= 2; console.log(val); console.log(this.val); &#125;&#125;;// 说出下面的输出结果obj.dbl();var func = obj.dbl;func(); 结果是: 2 4 8 8 val变量在没有指定对象前缀,默认从函数中找,找不到则从window中找全局变量。 即 val =2 就是 window.val = 2。this.val默认指的是 obj.val ;因为 dbl()第一次被obj直接调用func() 没有任何前缀,类似于全局函数,即 window.func调用,所以第二次调用的时候, this指的是window, val指的是window.val，第二次的结果受第一次的影响。 在严格模式下的this12345function test() &#123; 'use strict'; console.log(this);&#125;test(); 结果是: undefined。 箭头函数中的 this12345678var obj = &#123; say: function () &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;); &#125;&#125;obj.say(); // obj 此时的 this继承自obj, 指的是定义它的对象obj, 而不是 window! 示例(多层嵌套的箭头函数): 123456789101112var obj = &#123;say: function () &#123; var f1 = () =&gt; &#123; console.log(this); // obj setTimeout(() =&gt; &#123; console.log(this); // obj &#125;) &#125; f1(); &#125;&#125;obj.say() 因为f1定义时所处的函数中的this是指的obj, setTimeout中的箭头函数this继承自f1, 所以不管有多层嵌套,都是 obj。 示例(复杂情况: 普通函数和箭头函数混杂嵌套) 123456789101112var obj = &#123;say: function () &#123; var f1 = function () &#123; console.log(this); // window, f1调用时,没有宿主对象,默认是window setTimeout(() =&gt; &#123; console.log(this); // window &#125;) &#125;; f1(); &#125;&#125;obj.say() 结果: 都是 window,因为箭头函数在定义的时候它所处的环境相当于是window, 所以在箭头函数内部的this函数window。 示例(严格模式下的混杂嵌套) 12345678910111213var obj = &#123;say: function () &#123; 'use strict'; var f1 = function () &#123; console.log(this); // undefined setTimeout(() =&gt; &#123; console.log(this); // undefined &#125;) &#125;; f1(); &#125;&#125;obj.say() 结果都是undefined。 说明: 严格模式下,没有宿主调用的函数中的this是undefined!!!所以箭头函数中的也是undefined! 总结使用箭头函数,可以让我们解决一些在匿名函数中 this指向不正确的问题; 但是要注意在和普通函数混合的时候,this的指向可能是window !]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解闭包]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包，是 Javascript 比较重要的一个概念，对于初学者来讲，闭包是一个特别抽象的概念，特别是ECMAScript 规范给的定义，如果没有实战经验，很难从定义去理解它。因此，本文不会对闭包的概念进行大篇幅描述，直接上干货，让你分分钟理解闭包！ 闭包，一睹为快在接触一个新技术的时候，我首先会做的一件事就是找它的 demo。对于我们来说，看代码比自然语言更能理解一个事物的本质。其实，闭包无处不在，比如：jQuery、zepto的核心代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包，以便让你在大脑里产生闭包的画面： 12345678function A()&#123; function B()&#123; console.log("Hello Closure!"); &#125; return B;&#125;var C = A();C();//Hello Closure! 这是最简单的闭包。 有了初步认识后，我们简单分析一下它和普通函数有什么不同，上面代码翻译成自然语言如下： （1）定义普通函数 A （2）在 A 中定义普通函数 B （3）在 A 中返回 B （4）执行 A, 并把 A 的返回结果赋值给变量 C （5）执行 C 把这5步操作总结成一句话就是： 函数A的内部函数B被函数A外的一个变量 c 引用。 把这句话再加工一下就变成了闭包的定义： 当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 因此，当你执行上述5步操作时，就已经定义了一个闭包！ 这就是闭包。 闭包的用途在了解闭包的作用之前，我们先了解一下 Javascript 中的GC机制: 在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收，否则这个对象一直会保存在内存中。 在上述例子中，B 定义在 A 中，因此 B 依赖于 A ,而外部变量 C 又引用了 B , 所以A间接的被 C 引用。 也就是说，A 不会被 GC 回收，会一直保存在内存中。为了证明我们的推理，上面的例子稍作改进： 123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;&#125;var C = A();C();// 1C();// 2C();// 3 count 是函数A 中的一个变量，它的值在函数B 中被改变，函数B 每执行一次，count 的值就在原来的基础上累加 1 。因此，函数A中的 count 变量会一直保存在内存中。 count 是函数A 中的一个变量，它的值在函数B 中被改变，函数B 每执行一次，count 的值就在原来的基础上累加 1 。因此，函数A中的 count 变量会一直保存在内存中。 当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会“污染”全局的变量时，就可以用闭包来定义这个模块。 闭包的高级写法上面的写法其实是最原始的写法，而在实际应用中，会将闭包和匿名函数联系在一起使用。下面就是一个闭包常用的写法： 123456789101112131415(function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector("#"+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;)(document); 这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。 功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行，需要重点理解的是这种写法是如何实现闭包功能的。 可以将上面的代码拆分成两部分：(function(){}) 和 () , 第1个() 是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加 () 就表示执行这个匿名函数。 因此这段代码执行执行过程可以分解如下： 12345678910111213141516var f = function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector("#"+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;;f(document); 在这段代码中似乎看到了闭包的影子，但 f 中没有任何返回值，似乎不具备闭包的条件，注意这句代码： 1window.jView = obj; obj 是在函数 f 中定义的一个对象，这个对象中定义了一系列方法， 执行window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj . 而 obj 对象中的函数又引用了函数 f 中的变量 viewport ,因此函数 f 中的 viewport 不会被 GC 回收，viewport 会一直保存到内存中，所以这种写法满足了闭包的条件。 总结这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解JS的执行环境(execution context)、活动对象(activation object)以及作用域(scope)和作用域链(scope chain)的运行机制。但作为初学者，暂时不必了解这些，有了简单的理解之后，一定要在实际项目中用起来，等你用的多了，对于闭包，你自然会有更深层次的理解！ 转自https://www.cnblogs.com/onepixel/p/5062456.html]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流与函数防抖]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，onmousemove,resize,onscroll等等，有些时候，我们并不能或者不想频繁触发事件，咋办呢？这时候就该用到函数防抖和函数节流了！ 函数防抖什么是防抖？短时间内多次触发同一个事件，只执行最后一次，或者只在开始时执行，中间不执行。 12345678910111213141516171819/** * 防抖函数 * @param method 事件触发的操作 * @param delay 多少毫秒内连续触发事件，不会执行 * @returns &#123;Function&#125; */ function debounce(method, delay) &#123; let timer = null return function () &#123; let self = this let args = arguments timer &amp;&amp; clearTimeout(timer) timer = setTimeout(function () &#123; method.apply(self, args) &#125;, delay) &#125;&#125;,// 触发onmouseover事件xcd.onmousemove = debounce(method,1000); 函数节流什么是节流？节流是连续触发事件的过程中以一定时间间隔执行函数。节流会稀释你的执行频率，比如每间隔1秒钟，只会执行一次函数，无论这1秒钟内触发了多少次事件。 1234567891011121314151617181920212223242526272829303132333435363738 /** * 节流函数 * @param method 事件触发的操作 * @param mustRunDelay 间隔多少毫秒需要触发一次事件 * @returns &#123;Function&#125; *///节流时间戳版 function throttle(method,mustRunDelay)&#123; var self,args,initTime = 0; return function()&#123; var now = +new Date();//将new date()转化为时间戳 self = this; args = arguments; if(now - initTime&gt;mustRunDelay)&#123; method.apply(self,args); initTime = now; &#125; &#125; &#125; //触发onmousemove事件 xcd.onmousemove = throttle(method,1000); //节流定时器版 function throttle(method,mustRunDelay)&#123; var timeout; return function()&#123; var self = this;args = arguments; if(!timeout)&#123; timeout = setTimeout(function()&#123; timeout = null; method.apply(self,args); &#125;,mustRunDelay); &#125;; &#125; &#125; //触发onmousemove事件 xcd.onmousemove = throttle(method,1000);]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript去重与排序方法总结]]></title>
    <url>%2F2018%2F11%2F15%2FJavaScript%E5%8E%BB%E9%87%8D%E4%B8%8E%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[去重还排序是程序设计中最为基本的算法以及面试中的基本考点，本文对去重和排序方法进行总结。 去重 123456789101112131415161718192021222324252627282930313233// 方法一var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0]function test()&#123; for (var i = 0; i &lt; arr.length; i++)&#123; for(var j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] === arr[j]) arr.splice(j,1);//如果前一个值与后一个值相等，那么就去掉后一个值，splice()可以修改原数组 &#125; &#125; return arr;&#125;test();// 方法二var arr = [1, 1, 4, 50, 50, 6, 2, 2];function test()&#123; return arr.filter(function(item,index,array)&#123; return array.indexOf(item) === index; //或者这样写return array.indexOf(item, index+1) === -1; 如果没有重复项，返回true //用filter方法，返回ietm对应的indexOf索引值与本身index索引值相等的值，也就是去掉重复的值，filter本身不修改数组，只是会自动遍历数组， // 去掉重复值后，那么arr就剩下不重复的了 &#125;);&#125;test();//输出Array [ 1, 4, 50, 6, 2 ]// 方法三（es6）var arr = [1, 1, 4, 50, 50, 6, 2, 2];function unique(arr)&#123; return Array.from(new Set(arr));&#125;unique(arr); 排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//冒泡排序 从数组中随便拿一个数与后一位比较，如果前者比后者大，那么两者交换位置，从而遍历数组可以得到排序的效果var arr = [1, 9, 4, 50, 49, 6, 3, 2];function test(arr)&#123; for (var i = 0; i &lt; arr.length - 1; i++)&#123; for (var j = i + 1; j &lt; arr.length; j++)&#123; var tempi = arr[i]; //获取第一个值，并与后一个值比较 var tempj = arr[j]; if (tempi &gt; tempj)&#123; arr[i] = tempj; arr[j] = tempi;//如果前一个值比后一个值大，那么相互交换 &#125; &#125; &#125; console.log(arr); //return arr；&#125;test(arr);// 快速排序 在数组中间那一个值，然后用这个值跟数组里面的值相比较，大于此值的放在一边，小于的也放在一边，然后用concat()合并，// 再进行比较，如此反复var arr = [1, 9, 4, 50, 49, 6, 3, 2];function test(arr)&#123; if (arr.length &lt;= 1) return arr;//如果数组只有一位，就没有必要比较了 var index = Math.floor(arr.length / 2);//获取中间值的索引 var cur = arr.splice(index, 1);//截取中间值，如果此处使用cur=arr[index]; 那么将会出现无限递归的错误 var left = [], right = [];//小于中间值的放在left数组里，大于的放在right数组 for (var i = 0; i &lt; arr.length; i++)&#123; if (cur &gt; arr[i])&#123; left.push(arr[i]); &#125; else&#123; right.push(arr[i]); &#125; &#125; return test(left).concat(cur, test(right));//通过递归，上一轮比较好的数组合并，并且再次进行比较&#125;test(arr);// sort方法var arr = [1, 9, 4, 50, 49, 6, 3, 2];function test(arr)&#123; return arr.sort(sortNumber);&#125;function sortNumber(a, b)&#123; return a - b;&#125;test(arr);]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常用工具函数]]></title>
    <url>%2F2018%2F11%2F15%2FJavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[平时在工作中都会积累一些常用方法，持续更新。 判断数据类型1234567function getType(params)&#123; return Object.prototype.toString.call(params);&#125;//examplegetType([]) //"[object Array]"getType(function()&#123;&#125;) //"[object Function]"getType(&#123;&#125;) //"[object Object]" 1234567function toType(obj) &#123; return &#123;&#125;.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();&#125;//exampletoType([]) //"array"toType(function()&#123;&#125;) //"function"toType(&#123;&#125;) //"object" 参数过滤123456789101112131415161718192021//结合类型判断函数，对传入的对象参数进行过滤function filterNull (o) &#123; for (var key in o) &#123; if (o[key] === null) &#123; delete o[key] &#125; if (toType(o[key]) === 'string') &#123; o[key] = o[key].trim() &#125; else if (toType(o[key]) === 'object') &#123; o[key] = filterNull(o[key]) &#125; else if (toType(o[key]) === 'array') &#123; o[key] = filterNull(o[key]) &#125; &#125; return o&#125;function foo (params) &#123; if(params) &#123; params = filterNull(params) &#125;&#125; 将arguments对象转成数组123var argArray = Array.prototype.slice.call(arguments);//或者ES6：var argArray = Array.from(arguments) 评分方法12345function getRate(rate)&#123; return '★★★★★☆☆☆☆☆'.slice(5 - rate, 10 - rate);&#125;//examplegetRate(2) //★★☆☆☆ 范围内生成随机数12345function randNum(min, max) &#123; return Math.floor(min + Math.random() * ((max+1) - min));&#125;//examplerandNum(0 ,100) //生成0-100的随机数 生成随机字符串12345678//生成一个指定位数的随机字符串function randomAlphaNum(len) &#123; var rdmString = ''; for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len).toUpperCase();&#125;//examplerandomAlphaNum(16) //"017W8K1EQ63IW0T4" 对象深拷贝 深度拷贝通用函数。 深拷贝就是指创建一个数据内容和结构一模一样的新对象，新对象内的所有值的指针地址都是新的地址，即复制出一个全新的对象实例，新对象跟原对象不共享内存，两者操作互不影响。 12345678910111213141516171819202122232425262728function deepClone(values) &#123; var copy; if (null == values || "object" != typeof values) return values; if (values instanceof Date) &#123; copy = new Date(); copy.setTime(values.getTime()); return copy; &#125; if (values instanceof Array) &#123; copy = []; for (var i = 0, len = values.length; i &lt; len; i++) &#123; copy[i] = deepClone(values[i]); &#125; return copy; &#125; if (values instanceof Object) &#123; copy = &#123;&#125;; for (var attr in values) &#123; if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]); &#125; return copy; &#125; throw new Error("Unable to copy values! Its type isn't supported.");&#125; json对象的parse和stringify。 JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。该方法的不足之处是能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深拷贝。 123var source = &#123; name:"source", child:&#123; name:"child" &#125; &#125; var target = JSON.parse(JSON.stringify(source));console.log(target) 对象浅拷贝 浅拷贝ShallowCopy，是一个对象的逐位副本。创建一个新对象，该对象具有原始对象中的精确副本。如果对象的任何字段是对其他对象的引用，则只复制引用地址，即只复制内存地址，而不复制对象本身，新旧对象还是共享同一块堆内存。改变其中一个对象，另一个也会受影响。如果有修改，会失去原始数据。 简单的引用复制。 1234567891011121314function shallowClone(copyObj) &#123; var obj = &#123;&#125;; for ( var i in copyObj) &#123; obj[i] = copyObj[i]; &#125; return obj;&#125;var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = shallowClone(x);console.log(y.b.f === x.b.f); // true Object.assign()方法。 Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 1234567var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = Object.assign(&#123;&#125;, x);console.log(y.b.f === x.b.f); // true 求数组的最大值、最小值、和、平均数1234567891011121314151617var arr = [23,45,23,890]取最大值：max = Math.max.apply(null, arr)取最小值：min = Math.min.apply(null,arr)取和：function arrAdd() &#123; var sum = 0for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; return sum &#125;add = arrAdd() //取和average = arrAdd()/arr.length //取平均数 获取数组某个元素的下标123456789101112131415/** * 获取数组某个元素下标 * @param arrays 传入的数组 * @param item 需要获取下标的元素 */function contains(arrays, item) &#123; var i = arrays.length; while (i--) &#123; if (arrays[i] === item) &#123; return i; &#125; &#125;&#125;//结合数组的splice方法，用来删除数组的当前项myArray.splice(contains(myArray,item),1)]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目的过滤器配置]]></title>
    <url>%2F2018%2F11%2F12%2Fvue%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一个项目中，可能要用到很多过滤器来处理数据，多个组件公用的，可以注册全局过滤器。单个组件使用的，就挂载到实例filters中。项目做的多了以后，可以整理一套常用的filters，不用反复的写。比如：时间等各种操作，数据格式转化，单位换算，部分数据的md5加密等… 创建一个filters文件夹，专门放过滤器 123456789├── node_modules├── src ├── assets ├── components ├── data ├── filters ├── filters.js └── store ├── actions.js filter.js 1234567891011121314151617181920212223//将秒转换为时分秒export function formatSeconds(value) &#123; var secondTime = parseInt(value);// 秒 var minuteTime = 0;// 分 var hourTime = 0;// 小时 if(secondTime &gt; 60) &#123; minuteTime = parseInt(secondTime / 60); secondTime = parseInt(secondTime % 60); if(minuteTime &gt; 60) &#123; hourTime = parseInt(minuteTime / 60); minuteTime = parseInt(minuteTime % 60); &#125; &#125; var result = "" + parseInt(secondTime) + "秒"; if(minuteTime &gt; 0) &#123; result = "" + parseInt(minuteTime) + "分" + result; &#125; if(hourTime &gt; 0) &#123; result = "" + parseInt(hourTime) + "小时" + result; &#125; return result; &#125; main.js 123456789101112import Vue from 'vue'import App from './App'import router from './router'import Vuex from 'vuex'import store from './store/index'import axios from 'axios'import * as filters from './filters/filter.js' //引入过滤器Vue.prototype.$http = axios//使用过滤器Object.keys(filters).forEach(key=&gt;&#123; Vue.filter(key,filters[key])&#125;) 页面中直接使用过滤器即可 1&lt;div class="videolength fl"&gt;视频总时长：&lt;em&gt;&#123;&#123;worksInfo.duration|formatSeconds&#125;&#125;&lt;/em&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vue中使用websocket]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8websocket%2F</url>
    <content type="text"><![CDATA[之前在一个大数据治理项目中，因为需要页面主动更新数据，就用到了websocket，现将核心代码贴出，以备查阅。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859data()&#123; return &#123; logCountTotalDataSocket:&#123;&#125; websock:null &#125;&#125;,methods:&#123; threadPoxi() &#123; //与后端约定要发送的数据 const agentString = '&#123;"event": "subscribe", "topic": "logStatistic", "serviceId": "all"&#125;' // 若是ws开启状态 if (this.websock.readyState === this.websock.OPEN) &#123; this.websocketsend(agentString) &#125; else if (this.websock.readyState === this.websock.CONNECTING) &#123; const that = this setTimeout(function() &#123; that.websocketsend(agentString) &#125;, 300) &#125; else &#123; this.initWebSocket() const that = this setTimeout(function() &#123; that.websocketsend(agentString) &#125;, 500) &#125; &#125;, initWebSocket() &#123; // 服务器地址必须是ws地址，创建websocket对象 const wsuri = 'ws://121.40.165.18:8800' this.websock = new WebSocket(wsuri) this.websock.onmessage = this.websocketonmessage this.websock.onerror = this.websocketerror this.websock.onclose = this.websocketclose &#125;, // 数据接收 websocketonmessage(e) &#123; console.log(e) console.log('websocketonmessage', typeof e.data) this.logCountTotalDataSocket = JSON.parse(e.data) || &#123;&#125; &#125;, // 数据发送 websocketsend(data) &#123; console.log('websocketsend', data) this.websock.send(data) console.log(data) &#125;, // 连接发送错误 websocketerror(e) &#123; console.log(e.code) &#125;, // 关闭 websocketclose(e) &#123; console.log(e.code) &#125; &#125;,mounted()&#123; this.initWebSocket() this.threadPoxi()&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue调试工具Devtools不出现的解决方式]]></title>
    <url>%2F2018%2F10%2F25%2Fvue%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7Devtools%E4%B8%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在使用vuex时，想直观的查看数据state的变动，用Devtools可实现，但是在Google浏览器中开发调试的时候，右上角出现vue的图标，但是在开发者工具中没有出现vue调试（已在扩展程序中安装 Vue Devtools） 没显示调试工具的原因是用了生产环境的版本或是压缩的vue版本，或是扩展程序没有勾选：允许访问文件网址。 如果勾选了还是没有显示，说明采用了压缩版/生产版的Vuejs，则继续采用如下方案： 在main.js中添加代码： 123456// 若是没有开启Devtools工具，在开发环境中开启，在生产环境中关闭if (process.env.NODE_ENV == 'development') &#123; Vue.config.devtools = true;&#125; else &#123; Vue.config.devtools = false;&#125;]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用webstorm时提示please specify eslint package的解决方法]]></title>
    <url>%2F2018%2F10%2F25%2F%E4%BD%BF%E7%94%A8webstorm%E6%97%B6%E6%8F%90%E7%A4%BAplease-specify-eslint-package%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[webstorm的file –&gt; settings –&gt; Language &amp; Frameworrks –&gt; Javascript –&gt; Code Quality Tools –&gt; 打开ESLint，把他们的 Enable 属性都取消，点击右下角‘Apply’，‘OK’ 即可。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个loading模板]]></title>
    <url>%2F2018%2F10%2F25%2F%E4%B8%80%E4%B8%AAloading%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[12345678910111213var _LoadingTitle="努力加载中...";var _LoadingHtml = '&lt;div id="loadingDiv" style="position:absolute;left:0;width:100%;height:100%;top:0;opacity:1;filter:alpha(opacity=80);z-index:10000;"&gt;&lt;div style="position: absolute; cursor1: wait; left: 50%; top:50%; width: 448px; height: 118px; line-height: 118px; border: 2px solid #4dd3c5; color: #4dd3c5; margin-left:-225px;margin-top: -60px;font-size:24px;text-align: center;"&gt;'+_LoadingTitle+'&lt;/div&gt;&lt;/div&gt;';document.write(_LoadingHtml);//监听加载状态改变document.onreadystatechange = completeLoading;//加载状态为complete时移除loading效果function completeLoading() &#123; if (document.readyState == "complete") &#123; var loadingMask = document.getElementById('loadingDiv'); loadingMask.parentNode.removeChild(loadingMask);&#125;&#125; //在index.html中引入该文件]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css用border设置hover是出现div抖动和走位问题解决]]></title>
    <url>%2F2018%2F10%2F24%2FCss%E7%94%A8border%E8%AE%BE%E7%BD%AEhover%E6%98%AF%E5%87%BA%E7%8E%B0div%E6%8A%96%E5%8A%A8%E5%92%8C%E8%B5%B0%E4%BD%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[样式设置 ：div:hover { border:1px solid red;} 当鼠标移动到div时，产生抖动和偏移。 产生的原因：是因为设置border时设置了1px边框，多出的这1px，与其它元素产生了挤压， 导致div偏移。 解决方法：第一种方法：先将这个div设置一个跟背景颜色一样的边框，比如背景颜色为#aaa；那么你先设置这个div的样式：div {border:1px solid #aaa;}，然后再设置hover动作，div:hover { border:1px solid red;} 。 第二种方法：将这个div的border颜色设置为透明 ，div {border:1px solid transparent;},然后再引入hover动作div:hover { border:1px solid red;} 。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目实现图片的横向滚动]]></title>
    <url>%2F2018%2F10%2F23%2Fvue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[源起最近公司的AE编辑器项目有一项需求，就是滚动鼠标滚轮的时候实现图片列表的横向滚动。那么，如何在vue中实现这个功能呢？话不多说，上代码。 创建Firefox全局变量创建Firefox全局变量是为了达到浏览器兼容的效果。 创建global文件夹，并新建index.js。 index.js 12const Firefox = navigator.userAgent.indexOf('Firefox') != -1;export default &#123; Firefox &#125; vue文件引入global变量，并使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;div class=&quot;scenelist&quot;&gt; &lt;div class=&quot;listwrap&quot; id=&quot;listwrap&quot;&gt; &lt;draggable :options=&quot;&#123;chosenClass:&apos;chosen&apos;, animation: 500&#125;&quot; element=&quot;ul&quot; v-model=&quot;list&quot; :move=&quot;allow&quot;&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot; @click=&quot;cur_index = index&quot; :class=&quot;&#123;active: cur_index === index&#125;&quot;&gt; &lt;img :src=&quot;item.src&quot;&gt; &lt;div class=&quot;btns&quot;&gt; &lt;Tooltip content=&quot;复制场景&quot; placement=&quot;top&quot; class=&quot;btnitem&quot;&gt; &lt;a class=&quot;copybtn&quot; @click=&quot;copyPage(index)&quot;&gt; &lt;i class=&quot;iconfont icon-fuzhi&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/Tooltip&gt; &lt;Tooltip content=&quot;删除场景&quot; placement=&quot;top&quot; class=&quot;btnitem&quot;&gt; &lt;a class=&quot;deletebtn&quot; @click=&quot;showDelMessage(index)&quot;&gt; &lt;i class=&quot;iconfont icon-shanchu&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/Tooltip&gt; &lt;/div&gt; &lt;div class=&quot;itemcount pa&quot;&gt;&#123;&#123;index+1&#125;&#125;&lt;/div&gt; &lt;div class=&quot;checkall&quot;&gt;&lt;/div&gt; &lt;/li&gt; &lt;/draggable&gt; &lt;/div&gt; &lt;a class=&quot;addscene&quot; @click=&quot;addScene()&quot;&gt; &lt;Icon type=&quot;md-add&quot; /&gt; &lt;/a&gt; &lt;Modal v-model=&quot;showModal&quot; title=&quot;提示&quot; @on-ok=&quot;delPage&quot; width=&quot;300&quot;&gt; &lt;p&gt;删除后不可恢复, 是否继续?&lt;/p&gt; &lt;/Modal&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import global_ from &apos;../../global/index&apos; export default &#123; methods:&#123; MouseWheel(e) &#123; e = e || window.event; if (e.stopPropagation) &#123; e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; &#125; if (e.preventDefault) &#123; e.preventDefault(); &#125; else &#123; e.returnValue = false; &#125; if (global_.Firefox) &#123; if (e.detail &gt; 0) &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() + 60); &#125; else &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() - 60); &#125; &#125; else &#123; if (e.wheelDelta &lt; 0) &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() + 60); &#125; else &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() - 60); &#125; &#125; &#125; &#125;, mounted() &#123; let scrollDiv = document.getElementById(&quot;listwrap&quot;); global_.Firefox ? scrollDiv.addEventListener(&apos;DOMMouseScroll&apos;, this.MouseWheel, false) : (scrollDiv.onmousewheel = this.MouseWheel); &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
