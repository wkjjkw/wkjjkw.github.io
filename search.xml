<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序radioChange方法的使用]]></title>
    <url>%2F2019%2F04%2F27%2F%E5%B0%8F%E7%A8%8B%E5%BA%8FradioChange%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景开发中有一项需求是根据radio表单的不同，显示不同的选项，类似于这样： 这种效果，需要使用到小程序表单的radioChange事件。 radioChange事件的使用1234567891011121314151617181920212223242526&lt;radio-group class="radio-group" bindchange="radioChange"&gt; &lt;label class="radio" wx:for="&#123;&#123;items&#125;&#125;" wx:key="&#123;&#123;item.name&#125;&#125;"&gt; &lt;radio value="&#123;&#123;item.name&#125;&#125;" checked="&#123;&#123;item.checked&#125;&#125;" /&gt; &#123;&#123;item.value&#125;&#125; &lt;/label&gt;&lt;/radio-group&gt;&lt;block wx:if="&#123;&#123;radioStatus === '选择通用券'&#125;&#125;"&gt;&lt;view class='price-view'&gt; &lt;span&gt;剩余额度：&lt;/span&gt; &lt;text&gt;&#123;&#123;orderDetail.pay.couponLimit&#125;&#125;&lt;/text&gt;&lt;/view&gt;&lt;view class='price-view'&gt; &lt;span&gt;可抵扣额度：&lt;/span&gt; &lt;text&gt;&#123;&#123;orderDetail.pay.couponDiscountLimit&#125;&#125;&lt;/text&gt;&lt;/view&gt;&lt;/block&gt;&lt;block wx:if="&#123;&#123;radioStatus === '选择专用券'&#125;&#125;"&gt;&lt;view class='price-view'&gt; &lt;span&gt;剩余额度：&lt;/span&gt; &lt;text&gt;&#123;&#123;orderDetail.pay.specialLimit&#125;&#125;&lt;/text&gt;&lt;/view&gt;&lt;view class='price-view'&gt; &lt;span&gt;可抵扣额度：&lt;/span&gt; &lt;text&gt;&#123;&#123;orderDetail.pay.specialDiscountLimit&#125;&#125;&lt;/text&gt;&lt;/view&gt;&lt;/block&gt; 123456789101112131415data: &#123; items:[ &#123;name:'选择通用券',value:'选择通用券',checked: 'true'&#125;, &#123;name:'选择专用券',value:'选择专用券'&#125; ], radioStatus:'选择通用券', orderDetail:&#123;&#125;&#125;, radioChange: function (e) &#123; console.log(e) this.setData(&#123; radioStatus:e.detail.value &#125;)&#125;]]></content>
      <categories>
        <category>移动端开发</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序的表单数据绑定]]></title>
    <url>%2F2019%2F04%2F27%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[背景最近的工作是开发一款用来差交易流程的微信小程序，流程比较复杂，业务量也比较大。之前没有开发过小程序，从学习小程序到开发接近完成花了半个多月时间。这里记录下自己在开发表单业务上的某些经验。 具体步骤具体的做法直接看代码： 12345678&lt;view class='evaluateTxt'&gt; &lt;textarea placeholder='点击输入取消交易的原因' placeholder-class="place-gray" data-name="stopReason" value="&#123;&#123;stopReason&#125;&#125;" bindinput="editStopReason" &gt;&lt;/textarea&gt;&lt;/view&gt; 12345678910111213141516data: &#123; stopReason:''&#125;,// 监听文字域editStopReason:function(e)&#123; console.log(e) var that = this var dataSet = e.currentTarget.dataset var value = e.detail.value var name = dataSet.name that.data[name] = value that.setData(&#123; stopReason: that.data[name] &#125;)&#125;]]></content>
      <categories>
        <category>移动端开发</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（36）：JavaScript术语表]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8836%EF%BC%89%EF%BC%9AJavaScript%E6%9C%AF%E8%AF%AD%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[最后，介绍一些你可能不熟悉的前端开发术语。 异步当你启动某些内容时，代码是异步的，忘记它，当结果准备就绪时，你可以将其取回而无需等待它。 典型的例子是一个 AJAX 调用，它可能需要几秒钟，与此同时你可以完成其他事情，当获取响应，回调函数会被调用。 Promise 和 async/await 是处理异步的现代方法。 块(Block)在 JavaScript 中，块是用大括号（ {} ）包裹的。 if 语句包含一个块， for 循环包含一个块。 块级作用域使用函数作用域，在块中定义的任何变量对整个块都是可见的，可以在块内部访问，但块外部不能访问。 回调回调是在发生某些事情时调用的函数。元素单击事件会绑定一个事件处理程序，这就是回调函数，当用户单击元素时会调用该回调函数。fetch 请求有一个回调函数，当资源被下载时调用该回调函数。 声明声明就是告诉机器你需要做什么，然后让他计算出详细信息。 React 被认为是声明性的，因为你更注重推理抽象而不是直接编辑 DOM 。 每种高级编程语言都比低级编程语言，如 Assembler，更具声明性。JavaScript 比 C 语言更具声明性，HTML是声明性的。 回退当用户无法访问特定功能时，回退可以用于提供良好的体验。例如，禁用 JavaScript 的用户应该能够返回到页面的纯 HTML 版本。或者对于没有实现 API 的浏览器，你应该有一个回退，以避免完全破坏用户的体验。 函数作用域在函数作用域中，函数中定义的任何变量都是可见的，并且可以在整个函数内部访问。 不可变性(Immutability)当一个变量的值在创建后无法更改时，该变量就被认为是不可变的。可变变量是可以改变的。这同样适用于对象和数组。 词法作用域词法作用域是一个特定作用域，父函数的变量可以被其内部函数访问。内部函数的作用域也包括了父函数的作用域。 PolyfillPolyfill 用来为旧浏览器提供它没有原生支持的现代浏览器具有的新功能。Polyfill 是一种特殊的 shim。 纯函数（pure function）纯函数是一个没有副作用(side effects）的函数（不会修改外部资源），其输出仅由参数决定。你可以调用此函数 一百万次次，每次都用相同的参数，输出将始终相同。 重新赋值JavaScript 中，使用 var 和 let 声明的变量允许你无数次地重新赋值。 使用 const 声明，你可以有效地为字符串，整数，布尔值和对象声明一个不可变值（对于对象值来说，你无法重新绑定值，但你仍然可以通过其提供的方法进行修改）。 作用域作用域是一个变量集合，该变量集合对于程序来说是可见的那一部分。 ScopingScoping 是编程语言里定义的一组规则，用于确定变量的值。 ShimShim 包含了许多功能或者 API。它通常用于抽象内容，预填充参数或为不支持某些功能的浏览器添加 polyfill。你可以把它看作兼容层。 副作用(side effects）副作用是一个函数与其它函数或者对象进行交互。与网络、文件系统或者是 UI 交互都有副作用。 state(状态)在讨论组件时，不得不提到状态。如果组件管理自己的数据，则组件可以是 stateful(有状态的)，如果组件不管理自己的数据，则可以是 stateless(无状态) 组件。 有状态（stateful）一个有状态的组件，函数或类会管理自己的状态（数据）。它可以存储数组，计数器或其他任何东西。 无状态（stateless）一个无状态的组件，函数或者类也被称作 dumb ，因为它无法使用自己的数据做出决定，所以它的输出或者展示完成基于它的参数。这意味着纯函数是无状态的。 严格模式（Strict mode）严格模式是 ECMAScipt 5.1 的新功能，它会导致 JavaScript 运行时捕捉更多的错误，它可以通过拒绝未声明的变量和冲突的对象属性等其他容易被忽视的问题来帮助你改进 JavaScript 代码。建议：使用严格模式。另一个“草率模式（sloppy mode）”看名字就知道不是什么好东西。 Tree ShakingTree Shaking 意味着从你发送给用户的包中删除“死代码”。如果你在 import 语句中添加了一些从未使用过的代码，这些代码就不会被发送给你的用户，从而减少文件大小和加载时间。 感谢阅读！]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（35）：CommonJs介绍]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8835%EF%BC%89%EF%BC%9ACommonJs%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[CommonJS 模块规范是 Node.js 中用于处理模块的标准。 在浏览器中运行的客户端 JavaScript 使用另一种标准，名叫 ES Modules。 它们可以让你创建清晰独立且可重复使用的功能片段，每个片段都可以独立测试。 庞大的 npm 生态系统建立在这种 CommonJS 规范之上。 导入模块的语法是： 1const package = require('module-name') 在 CommonJS 中，模块是同步加载的，并按照 JavaScript 运行时查找它们的顺序进行处理。 这个系统原本为服务器端 JavaScript 而生，不兼容客户端（这也是为什么引入 ES 模块）。 一个 JavaScript 文件是一个 模块，它可以导出一个或多个定义的符号，它们是变量，函数，对象： uppercase.js 文件 1exports.uppercase = str =&gt; str.toUpperCase() 任何 JavaScript 文件都可以导入并且使用这个模块： 12const uppercaseModule = require('uppercase.js')uppercaseModule.uppercase('test') 一个简单例子可以在 这个 Glitch 上找到。 你可以导出多个值： 123exports.a = 1exports.b = 2exports.c = 3 通过解构赋值单独导入每一个值： 1const &#123; a, b, c &#125; = require('./uppercase.js') 或使用以下方法只导出一个值： 12//file.jsmodule.exports = value 然后导入使用： 1const value = require('./file.js')]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（34）：模块]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8834%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[ES Modules 是用于处理模块的 ECMAScript 标准。 虽然 Node.js 长期使用 CommonJS 标准，但浏览器从未有过模块系统。 每个主要决策（如模块系统）必须首先由 ECMAScript 标准化，然后由浏览器实现。 这个标准化过程在 ES6 中完成，浏览器开始实现这个标准，尽力使工作方式保持一致。现在 Chrome，Safari，Edge 和 Firefox（从 60 版本开始）已支持ES 模块。 模块非常酷，因为它们允许你封装各种功能，并将这些功能作为库暴露给其他 JavaScript 文件使用。 ES 模块语法导入一个模块可以用 import ： 1import package from 'module-name' 然而 CommonJS 使用： 1const package = require('module-name') 一个模块是一个 JavaScript 文件，通过 export 导出一个或多个值（对象，函数或变量）。举个例子，这个模块导出一个返回字符串大写的函数： uppercase.js 文件: 1export default str =&gt; str.toUpperCase() 在这个例子中，模块定义单个默认导出(default export)，因此它可以是匿名函数。 否则，它需要一个名称来区分其它的导出。 现在，其它任何的 JavaScript 模块都可以通过导入 uppercase.js 导入这个函数。 一个HTML页面可以使用带有特殊的 type=&quot;module&quot; 属性的 &lt;script&gt; 标记添加模块： 1&lt;script type="module" src="index.js"&gt;&lt;/script&gt; 注意：此模块导入的行为类似于 defer 脚本加载。请参阅 使用延迟和异步高效加载JavaScript) 特别要注意：任何使用 type=&quot;module&quot; 加载的脚本都是以 严格模式(strict mode) 加载的。 在这个例子中，uppercase.js 模块定义了一个默认导出，所以当我们导入这个模块时，可以为它指定一个你自己喜欢的名称： 1import toUpperCase from './uppercase.js' 然后我们可以使用它： 1toUpperCase('test') //'TEST' 你还可以使用绝对路径来导入模块，以便引用其它域名中定义的模块： 1import toUpperCase from 'https://flavio-es-modules-example.glitch.me/uppercase.js' 这种导入语法也是有效的： 12import &#123; foo &#125; from '/uppercase.js'import &#123; foo &#125; from '../uppercase.js' 但是下面的导入语法是无效的： 12import &#123; foo &#125; from 'uppercase.js'import &#123; foo &#125; from 'utils/uppercase.js' 路径必须是绝对路径，或在名字前加上 ./ 或者 / 。 其它 导入(import)/导出(export) 方法我们在上面看到了这个例子： 1export default str =&gt; str.toUpperCase() 上面的代码会创建一个默认导出(export)。然而在一个文件中你可以导出多个内容： 12345const a = 1const b = 2const c = 3export &#123; a, b, c &#125; 另一个模块可以使用以下代码导入所有上面这些导出： 1import * from 'module' 你可以使用解构分配只选择导入部分内容： 12import &#123; a &#125; from 'module'import &#123; a, b &#125; from 'module' 为方便起见，你可以使用 as 重命名任何导入(import)： 1import &#123; a, b as two &#125; from 'module' 你可以按名称 导入(import) 默认导出(default export) 和任何 非默认导出(non-default export)，例如常见的 React 导入： 1import React, &#123; Component &#125; from 'react' 你可以在 此处 查看 ES 模块的示例。 跨域资源共享 CORS通过 CORS 获取模块，意味着如果你从其它域名引入脚本，他们必须有一个有效的 CORS 头允许跨站点加载（像 Access-Control-Allow-Origin: *）。 不支持模块的浏览器怎么办？结合使用 type=module 和 nomodule： 12&lt;script type="module" src="module.js"&gt;&lt;/script&gt;&lt;script nomodule src="fallback.js"&gt;&lt;/script&gt; 总结ES模块是现代浏览器中引入的最大功能之一。 他们是ES6的一部分，但实现它们的过程还很漫长。 我们现在可以使用它们了！ 但我们还必须记住，拥有多个模块会对我们的页面产生性能影响，因为这是浏览器必须在运行时执行的一步。 即使 ES 模块已经在浏览器中可用， webpack依然扮演者重要的角色 ，但是直接用语言构建这样的功能对于统一模块在客户端和 Node.js 上的工作方式来说是巨大的挑战。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（33）：Math对象]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8833%EF%BC%89%EF%BC%9AMath%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Math 对象包含许多与数学相关的实用工具。我们在这里看看都有哪些。 常量 相目 描述 Math.E 常数e，自然对数的基数（表示~2.71828） Math.LN10 表示 10 的自然对数，约为 2.302 Math.LN2 表示 2 的自然对数，约为 0.693 Math.LOG10E 表示以 10 为底数，e 的对数，约为 0.434 Math.LOG2E 表示以 2 为底数，e 的对数，约为 1.442 Math.PI 表示一个圆的周长与直径的比例，约为 3.14159 Math.SQRT1_2 表示 1/2 的平方根，约为 0.707 Math.SQRT2 表示 2 的平方根，约为 1.414 函数所有这些函数方法都是静态的，Math 不能被实例化。 Math.abs()返回数字的绝对值 12Math.abs(2.5) //2.5Math.abs(-2.5) //2.5 Math.acos()返回反余弦值，参数必须在 -1 到 1 之间。 1Math.acos(0.8) //0.6435011087932843 Math.asin()返回反正弦值，参数必须在 -1 到 1 之间。 1Math.asin(0.8) //0.9272952180016123 Math.atan()返回反正切值 1Math.atan(30) //1.5374753309166493 Math.atan2()返回其参数商的反正切值 1Math.atan2(30, 20) //0.982793723247329 Math.ceil()向上取整 1234Math.ceil(2.5) //3Math.ceil(2) //2Math.ceil(2.1) //3Math.ceil(2.99999) //3 Math.cos()用弧度表示角度的余弦值 12Math.cos(0) //1Math.cos(Math.PI) //-1 Math.exp()返回 Math.E 的参数次方 123Math.exp(1) //2.718281828459045Math.exp(2) //7.38905609893065Math.exp(5) //148.4131591025766 Math.floor()向下取整 1234Math.ceil(2.5) //2Math.ceil(2) //2Math.ceil(2.1) //2Math.ceil(2.99999) //2 Math.log()返回基数 e 的自然对数 12Math.log(10) //2.302585092994046Math.log(Math.E) //1 Math.max()返回传入的一系列数字中的最大值 12Math.max(1,2,3,4,5) //5Math.max(1) //1 Math.min()返回传入的一系列数字中的最小值 12Math.min(1,2,3,4,5) //1Math.min(1) //1 Math.pow()返回第一个参数的第二参数次方 1234Math.pow(1, 2) //1Math.pow(2, 1) //2Math.pow(2, 2) //4Math.pow(2, 4) //16 Math.random()返回 0.0 到 1.0 之间的伪随机值 12Math.random() //0.9318168241227056Math.random() //0.35268950194094395 Math.round()四舍五入 12Math.round(1.2) //1Math.round(1.6) //2 Math.sin()用弧度计算角度的正弦值 12Math.sin(0) //0Math.sin(Math.PI) //1.2246467991473532e-16) Math.sqrt()开方 123Math.sqrt(4) //2Math.sqrt(16) //4Math.sqrt(5) //2.23606797749979 Math.tan()用弧度计算角度的正切值 12Math.tan(0) //0Math.tan(Math.PI) //-1.2246467991473532e-16]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（32）：数学运算符]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8832%EF%BC%89%EF%BC%9A%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[对任何编程语言执行数学运算都是很常见的事情。JavaScript 提供了几个操作符来帮助我们处理数字。 算术运算符相加 (+)12const three = 1 + 2const four = three + 1 如果你使用字符串，+ 运算符也可以作为字符串连接，所以要注意： 123const three = 1 + 2three + 1 // 4'three' + 1 // three1 相减(-)1const two = 4 - 2 除法(/)返回第一个数字和第二个数字之间商： 12const result = 20 / 5 //result === 4const result = 20 / 7 //result === 2.857142857142857 如果除以 0，JavaScript 不会抛出任何错误，而是返回 Infinity（如果是负值返回 -Infinity）。 121 / 0 //Infinity-1 / 0 //-Infinity 取余(%)取余在很多情况下都很有用： 12const result = 20 % 5 //result === 0const result = 20 % 7 //result === 6 对 0 取余始终是 NaN，一个特殊值，意思是“不是一个数字”： 121 % 0 //NaN-1 % 0 //NaN 乘法 (*)121 * 2 //2-1 * 2 //-2 求幂(**)将第一个操作数乘第二个操作数次数： 123451 ** 2 //12 ** 1 //22 ** 2 //42 ** 8 //2568 ** 2 //64 一元运算符递增 (++)递增数字。这是一个一元运算符，如果放在数字之前，则返回递增后的值。 如果放在数字后面，它将返回原始值，然后递增。 1234let x = 0x++ //0x //1++x //2 递减(–)和递增运算符相似，不过它递减值。 1234let x = 0x-- //0x //-1--x //-2 一元负号(-)返回操作数的负值 123let x = 2-x //-2x //2 一元正号(+)如果操作数不是数字，它会尝试将操作数转换数字。如果操作数已经是一个数字，它什么都不做。 12345678let x = 2+x //2x = '2'+x //2x = '2a'+x //NaN 快速赋值常规的赋值操作符 = 对所有的数学运算符都有一个快捷方式让你能组合赋值，将第一个操作数和第二个操作数的结果赋值给第一个操作数。 它们是： +=：加法赋值-=：除法赋值*=：乘法赋值/=：除法赋值%=：取余赋值**=：求幂赋值 例子： 123456const a = 0a += 5 //a === 5a -= 2 //a === 3a *= 2 //a === 6a /= 2 //a === 3a %= 2 //a === 1 优先级每个复杂的表达式都会引入优先级问题。 看这个： 1const a = 1 * 2 + 5 / 2 % 2 结果等于 2.5。但是为什么呢？哪个运算先执行，哪个后执行？ 有些运算符的优先级比其它的高。优先级规则如下： - + ++ -- 一元运算符，递增，递减 * / % 乘法/除法 + - 加法/减法 = += -= *= /= %= **= 赋值运算 同一级别的运算符（如 + 和 - ）按找到的顺序执行 按照上面的顺序，我们可以计算这个式子： 12345const a = 1 * 2 + 5 / 2 % 2const a = 1 * 2 + 5 / 2 % 2const a = 2 + 2.5 % 2const a = 2 + 0.5const a = 2.5]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（31）：立即执行的函数表达式]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8831%EF%BC%89%EF%BC%9A%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[立即执行函数表达式(IIFE) 是在创建函数后立即执行函数的方法。 立即执行函数表达式(IIFE) 非常有用，因为它们不会污染全局对象，它们是隔离变量声明的简单方法。 这是定义 IIFE 的语法： 123;(function() &#123; /* */&#125;)() 立即执行函数也可以使用箭头函数定义： 123;(() =&gt; &#123; /* */&#125;)() 基本上，我们在括号内定义了一个函数，然后在后面加上一个括号 () 来执行该函数：(/* function */)()。 包裹函数的括号实际上是使我们的函数在内部被视为表达式。 否则，函数声明将无效，因为我们没有指定任何名称： 函数声明需要一个名称，而函数表达式不需要它。 你也可以将调用括号放在表达式括号内，没有区别，只是写法不同： 1234567(function() &#123; /* */&#125;())(() =&gt; &#123; /* */&#125;()) 使用一元运算符的替代语法你可以使用一些更奇怪的语法来创建 IIFE ，但它在现实世界中很少使用。 123456789101112131415;-(function() &#123; /* */&#125;)()+(function() &#123; /* */&#125;)()~(function() &#123; /* */&#125;)()!(function() &#123; /* */&#125;)() (这种方式在箭头函数上无效) 命名的 IIFEIIFE 也可以是命名的常规函数（不是箭头函数）。 这不会导致函数“泄漏”到全局作用域，并且在执行后也不能再次调用： 123;(function doSomething() &#123; /* */&#125;)() IIFE 前的分号你可能已经注意到 IIFE 前的分号了： 123;(function() &#123; /* */&#125;)() 这是为了防止在盲目合并两个 JavaScript 文件时出现问题。 由于 JavaScript 不强制使用分号，因此你可能会在最后一行中使用某些语句连接一个文件，从而导致语法错误。 这个问题可以通过像 webpack 这样的“聪明”的打包工具来解决。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（30）：严格模式]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8830%EF%BC%89%EF%BC%9A%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[严格模式是一项 ES5 功能，它使 JavaScript 以更好的方式运行，因为启用严格模式会更改 JavaScript 语言的语义。 了解严格模式与普通模式（通常称为草率模式）下 JavaScript 代码之间的主要区别非常重要。 如何开启用格模式严格模式是可选的。 与 JavaScript 中的每一个重大变化一样，我们不能简单地改变语言默认的行为方式，因为这会破坏大量的 JavaScript代码 ，并且 JavaScript 会花费大量精力来确保1996年的JavaScript代码在今天仍然有效。 这是其成功的关键。 因此，我们需要使用 &#39;use strict&#39; 指令来启用严格模式。 你可以将它放在文件的开头，将其应用于文件中包含的所有代码： 123456'use strict'const name = 'Flavio'const hello = () =&gt; 'hey'//... 你还可以通过在函数体的开头的位置添加 &#39;use strict&#39; ，来为该函数单独启用严格模式： 12345function hello() &#123; 'use strict' return 'hey'&#125; 这对操作那些你没有时间测试或者没有信心在整个文件开启严格模式的历史遗留代码中很有用。 严格模式改变了什么意外的全局变量如果为未声明的变量赋值，则默认情况下 JavaScript 会在全局对象上创建该变量： 12345678910;(function() &#123; variable = 'hey'&#125;)()(() =&gt; &#123; name = 'Flavio'&#125;)()variable //'hey'name //'Flavio' 转到严格模式，如果你尝试执行上面的操作，则会出现错误： 123456789;(function() &#123; 'use strict' variable = 'hey' // variable is not defined&#125;)()(() =&gt; &#123; 'use strict' myname = 'Flavio' // myname is not defined&#125;)() 分配错误JavaScript 中默默处理了一些转换错误。 在严格模式下，这些隐式转换会抛出错误： 123456undefined = 1 // 1(() =&gt; &#123; 'use strict' undefined = 1 // Cannot assign to read only property 'undefined' of object '#&lt;Window&gt;'&#125;)() 这同样适用于 Infinity，NaN，eval ，arguments 等。 在 JavaScript 中，可以使用下面代码定义对象属性不可写 123const car = &#123;&#125;Object.defineProperty(car, 'color', &#123; value: 'blue', writable: false &#125;)() 在严格模式下，你不能覆盖这个值，但在非严格模式下可以这么做： 和 getters 的原理一样： 12345678910111213const car = &#123; get color() &#123; return 'blue' &#125;&#125;car.color = 'red'( //ok () =&gt; &#123; 'use strict' car.color = 'yellow' //TypeError: Cannot set property color of # which has only a getter &#125;)() 非严格模式允许扩展一个不可扩展的对象： 12345678910const car = &#123; color: 'blue' &#125;Object.preventExtensions(car)car.model = 'Fiesta'( //ok () =&gt; &#123; 'use strict' car.owner = 'Flavio' //TypeError: Cannot add property owner, object is not extensible &#125;)() 另外，非严格模式允许设置原始值的属性，没有恩和错误提示，但是也不会生效： 12345678true.false = ''( //'' 1).name = 'xxx' //'xxx'var test = 'test' //undefinedtest.testing = true //truetest.testing //undefined 在严格模式下，这些情况都会失败： 123456789;(() =&gt; &#123; 'use strict' true.false = ''( //TypeError: Cannot create property 'false' on boolean 'true' 1 ).name = 'xxx' //TypeError: Cannot create property 'name' on number '1' 'test'.testing = true //TypeError: Cannot create property 'testing' on string 'test'&#125;)() 删除错误在非严格模式，如果你尝试删除无法删除的属性，JavaScript 只返回 false ，而在严格模式下，它会引发 TypeError： 12345678delete Object.prototype( //false () =&gt; &#123; 'use strict' delete Object.prototype //TypeError: Cannot delete property 'prototype' of function Object() &#123; [native code] &#125; &#125;)() 具有相同名称的函数参数在普通函数中，你可以使用重复的参数名称： 12345678910(function(a, a, b) &#123; console.log(a, b)&#125;)(1, 2, 3)//2 3(function(a, a, b) &#123; 'use strict' console.log(a, b)&#125;)(1, 2, 3)//Uncaught SyntaxError: Duplicate parameter name not allowed in this context 请注意，在这种情况下，箭头函数始终引发 SyntaxError： 1234((a, a, b) =&gt; &#123; console.log(a, b)&#125;)(1, 2, 3)//Uncaught SyntaxError: Duplicate parameter name not allowed in this context 八进制八进制语法在严格模式下是禁用的。默认情况下，在数字前加上兼容八进制格式的 0 可以把它解释为八进制数字（有时看起来令人困惑）： 12345678910(() =&gt; &#123; console.log(010)&#125;)()//8(() =&gt; &#123; 'use strict' console.log(010)&#125;)()//Uncaught SyntaxError: Octal literals are not allowed in strict mode. 你仍然可以使用 0oXX 语法在严格模式下启用八进制数字： 12345;(() =&gt; &#123; 'use strict' console.log(0o10)&#125;)()//8 移除了 with严格模式不能使用 with 关键字，移除了一些边界情况，并允许在编译器层面进行更多优化。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（29）：JavaScript中的This]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8829%EF%BC%89%EF%BC%9AJavaScript%E4%B8%AD%E7%9A%84This%2F</url>
    <content type="text"><![CDATA[this 值取决于在哪里使用它。不了解 JavaScript 这个小细节会导致很多头痛的问题，所以花5分钟学习所有技巧是值得的。 严格模式(strict mode) 中的 this严格模式下，在任何对象之外的 this 始终是 undefined （未定义的）。 注意我提到了严格模式。 如果禁用严格模式（如果没有在文件顶部明确添加 &#39;use strict&#39;，则默认为禁用），即草率模式（sloppy mode），也有人称为非严格模式。没有特别说明，下面提到的 this 都指向全局对象。 浏览器的全局对象为 window 。 方法中的 this方法是附加到对象属性的函数。 你可以看到各种形式。 这是其中一种形式： 1234567891011const car = &#123; maker: 'Ford', model: 'Fiesta', drive() &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`) &#125;&#125;car.drive()//Driving a Ford Fiesta car! 在这种情况下，使用常规函数，this 会自动绑定到对象。 注意：上面的方法声明是 drive: function（）{ … 的简写形式，ES6语法，等价于： 12345678const car = &#123; maker: 'Ford', model: 'Fiesta', drive: function() &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`) &#125;&#125; 在这个例子中同样有效： 1234567891011const car = &#123; maker: 'Ford', model: 'Fiesta'&#125;car.drive = function() &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`)&#125;car.drive()//Driving a Ford Fiesta car! 箭头函数不能以相同的方式工作，因为它是词法绑定的： 1234567891011const car = &#123; maker: 'Ford', model: 'Fiesta', drive: () =&gt; &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`) &#125;&#125;car.drive()//Driving a undefined undefined car! 绑定箭头函数你不能像使用普通函数那样将值绑定到箭头函数。 由于他们的工作方式不同。箭头函数中 this 是词法（lexically）绑定的，这意味着 this 的值来自定义它们的上下文。 显式传递要用作 this 的对象JavaScript 提供了一些方法来将 this 映射到你想要的任何对象上。 在 函数声明 阶段使用 bind() ： 1234567891011const car = &#123; maker: 'Ford', model: 'Fiesta'&#125;const drive = function() &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`)&#125;.bind(car)drive()//Driving a Ford Fiesta car! 你也可以重新映射一个已经存在的对象作为 this 值： 12345678910111213141516const car = &#123; maker: 'Ford', model: 'Fiesta', drive() &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!`) &#125;&#125;const anotherCar = &#123; maker: 'Audi', model: 'A4'&#125;car.drive.bind(anotherCar)()//Driving a Audi A4 car! 在 函数调用 阶段使用 call() 或 apply() ： 1234567891011121314const car = &#123; maker: 'Ford', model: 'Fiesta'&#125;const drive = function(kmh) &#123; console.log(`Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car at $&#123;kmh&#125; km/h!`)&#125;drive.call(car, 100)//Driving a Ford Fiesta car at 100 km/h!drive.apply(car, [100])//Driving a Ford Fiesta car at 100 km/h! 传入 call() 或者 apply() 的第一个参数始终绑定 this 。call() 和 apply() 之间的区别在于， apply() 传入一个数组作为参数，而 call() 则可以接受多个参数。 浏览器事件处理程序的特例在事件处理程序回调中，this 指向接收事件的 DOM 元素： 123document.querySelector('#button').addEventListener('click', function(e) &#123; console.log(this) //HTMLElement&#125; 你可以这样绑定： 123456document.querySelector('#button').addEventListener( 'click', function(e) &#123; console.log(this) //这里的 this 指向全局的 Window 对象, 或者你的上下文 &#125;.bind(this))]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（28）：定时器]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8828%EF%BC%89%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[编写 JavaScript 代码时，你可能希望延迟某个函数的执行。我们将讨论如何使用 setTimeout 和 setInterval。 setTimeout()编写 JavaScript 代码时，你可能希望延迟某个函数的执行。 写 JavaScript 代码时，你可能想要延时执行某个函数。这个工作交给 setTimeout。你可以指定一个延时执行的函数和需要的延时时间，以毫秒计： 1234567setTimeout(() =&gt; &#123; // runs after 2 seconds&#125;, 2000)setTimeout(() =&gt; &#123; // runs after 50 milliseconds&#125;, 50) 这个语法定义了一个新函数。你可以在任何位置调用它，你也可以传递一个已经存在的函数名，也可以设置一些参数： 123456const myFunction = (firstParam, secondParam) =&gt; &#123; // do something&#125;// runs after 2 secondssetTimeout(myFunction, 2000, firstParam, secondParam) setTimeout 返回一个定时器 id。通常不会用到它，但是你可以保存这个 id，在需要删除这个定时函数时可以清空它： 123456const id = setTimeout(() =&gt; &#123; // should run after 2 seconds&#125;, 2000)// I changed my mindclearTimeout(id) 零延时如果将定时器延迟时间设置为 0 ，则将尽快执行回调函数，但是必须等当前函数执行完毕： 12345setTimeout(() =&gt; &#123; console.log('after ')&#125;, 0)console.log(' before ') 上面的代码将打印 before after 。 通过对调度程序中的函数进行排序，这对于避免在密集型任务上阻塞 CPU 并在执行繁重计算时让其他函数执行特别有用。 某些浏览器（ IE 和 Edge ）实现了一个 setImmediate() 方法，该方法执行相同的功能，但它不是标准的，并且在其他浏览器上不可用。 但它是 Node.js 中的标准函数。 setInterval()setInterval 类似于 setTimeout ，区别在于：和只运行一次回调函数不同，它能够在指定的特定时间间隔（以毫秒为单位）一直运行它： 123setInterval(() =&gt; &#123; // runs every 2 seconds&#125;, 2000) 上面的函数每 2 秒运行一次，除非你使用 clearInterval 停止它，传递 setInterval 返回的 id： 12345const id = setInterval(() =&gt; &#123; // runs every 2 seconds&#125;, 2000)clearInterval(id) 在 setInterval 回调函数中调用 clearInterval 是很常见的，这让它自己确定它是否需要继续运行。例如，除非 App.somethingIWait 的值等于 arrived ，否则此代码会继续运行： 1234567const interval = setInterval(() =&gt; &#123; if (App.somethingIWait === 'arrived') &#123; clearInterval(interval) return &#125; // otherwise do things&#125;, 100) 递归 setTimeoutsetInterval 每n毫秒启动一个函数，不考虑函数何时执行完毕。 如果一个函数总是花费相同的时间，那关系不大： 但存在执行事件不一致的可能，特别常见的例子，比如 AJAX 请求，具体取决于网络条件，例如： 甚至有可能某个执行时间长的函数与下一个开始执行的函数重叠： 为避免这种情况，你可以在回调函数结束后递归调用 setTimeout： 12345678const myFunction = () =&gt; &#123; // do something setTimeout(myFunction, 1000)&#125;setTimeout( myFunction()&#125;, 1000) 上面的代码可以实现这种情况： setTimeout 和 setInterval 在 Node.js 中的 Timers 模块里可用。 Node.js 也提供了 setImmediate()，和使用 setTimeout(() =&gt; {}, 0) 效果一样，主要用于 Node.js 中的事件循环。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（27）：循环和作用域]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8827%EF%BC%89%EF%BC%9A%E5%BE%AA%E7%8E%AF%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[对开发者来说，JavaScript 的循环作用域可能会让人感到头疼。我们将学习循环作用域中和 var，let 有关的技巧。 举个例子： 1234567891011const operations = []for (var i = 0; i &lt; 5; i++) &#123; operations.push(() =&gt; &#123; console.log(i) &#125;)&#125;for (const operation of operations) &#123; operation()&#125; 它遍历 5 次，每次添加一个函数到 operations 数组。这个函数能够打印出循环时的索引变量 i。稍后运行这些函数。 期望的结果是： 1234501234 但实际上打印的是： 1234555555 为什么会这样呢？ 原因是使用了 var 。 由于 var 声明被提升，上面的代码等于 123456789101112var i;const operations = []for (i = 0; i &lt; 5; i++) &#123; operations.push(() =&gt; &#123; console.log(i) &#125;)&#125;for (const operation of operations) &#123; operation()&#125; 因此，在 for-of 循环中，i 仍然可见，并且始终等于 5，在这个函数中每一次调用 i 都等于 5。 那么我们应该如何让事情按照我们的意愿运行呢？ 最简单的解决方案是使用 let 声明。 在 ES2015 中引入，它可以避免 var 声明带来的一些奇怪的事情。 只需将循环变量 var 声明更改为 let 声明即可正常工作： 123456789const operations = []for (let i = 0; i &lt; 5; i++) &#123; operations.push(() =&gt; &#123; console.log(i) &#125;)&#125;for (const operation of operations) &#123; operation()&#125; 这是输出： 1234501234 这怎么可能呢？ 原因是每一次循环迭代 i 都创建了一个新的作用域，每个添加到 operations 数组的函数都获取当时的 i 副本。 Keep in mind you cannot use const in this case, because there would be an error as for tries to assign a new value in the second iteration. 另一种解决此问题的方法在 ES6 之前的代码中很常见，它被称为立即执行函数表达式（IIFE）。 在这种情况下，你可以包裹整个函数并将 i 绑定到这个函数。 这样每次都创建了一个立即执行的函数，并返回了一个新函数，所以我们可以稍后执行： 123456789const operations = []for (var i = 0; i &lt; 5; i++) &#123; operations.push(((j) =&gt; &#123; return () =&gt; console.log(j) &#125;)(i))&#125;for (const operation of operations) &#123; operation()&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（26）：Async和Await]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8826%EF%BC%89%EF%BC%9AAsync%E5%92%8CAwait%2F</url>
    <content type="text"><![CDATA[现在，我们将探索 JavaScript 中更现代的异步函数方法。 JavaScript 在很短的时间内从回调发展为 Promises ，从 ES2017(ES8) 开始，使用 async/await 语法让异步 JavaScript 变得更简单。 async(异步) 函数是 promises 和 generator 的组合，基本上，它们是对 promises 的更高级别的抽象。让我再说一遍：async/await 基于 promises。 为什么要引入 async/await ？它们降低了 promises 对一些固定语法样板的要求，打破了链式 promise “不能切断链式”的限制。 在 ES2015 中引入 Promise 时，它们旨在解决异步代码的问题，并且他们确实做到了，但在 ES2015 和 ES2017 的两年中，人们发现很明显 promises 不是最终的解决方案。 引入 Promises 来解决著名的回调地狱问题，但是因为Promises自身的复杂性，又因此引入了更复杂的语法。 它们是良好的原语，但是应该有更好的语法供开发者使用，所以当时机成熟时，我们就有了 异步函数(async functions)。它们使代码看起来像是同步的，但其实它们是异步和非阻塞的。 工作原理一个async(异步) 函数返回一个 promise，如下例所示： 12345const doSomethingAsync = () =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125; 你在前面加上 await 然后调用这个函数，这样代码会暂停执行直到这个 promise 变成 resolved 或者 rejected。需要注意的是：委托函数必须定义为 async。这里有一个例子： 123const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync())&#125; 一个简单的例子这是一个使用 async/await 异步运行函数的简单示例： 12345678910111213const doSomethingAsync = () =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125;const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync())&#125;console.log('Before')doSomething()console.log('After') 上面的代码将浏览器控制台中打印以下内容： 123BeforeAfterI did something //after 3s 一切都是 promise将 async 关键字添加到任何函数，意味着该函数将返回一个 promise 。 即使它没有明确的这么写出来，在内部也会使函数返回一个 promise 。 这就是此代码有效的原因： 1234const aFunction = async () =&gt; &#123; return 'test'&#125;aFunction().then(alert) // This will alert 'test' 并且与下面的代码等价： 1234const aFunction = async () =&gt; &#123; return Promise.resolve('test')&#125;aFunction().then(alert) // This will alert 'test' 代码更易于阅读你看我们上面的代码和原生的 promise 链式回调比起来是多么的简单。这仅仅是一个非常简单的例子，代码越复杂，越能凸显它的优势。 例如，你需要获取一个 JSON 资源并且对它进行解析： 12345678const getFirstUserData = () =&gt; &#123; return fetch('/users.json') // get users list .then(response =&gt; response.json()) // parse JSON .then(users =&gt; users[0]) // pick first user .then(user =&gt; fetch(`/users/$&#123;user.name&#125;`)) // get user data .then(userResponse =&gt; response.json()) // parse JSON&#125;getFirstUserData() 以下是使用 async/await 实现的相同功能： 12345678910const getFirstUserData = async () =&gt; &#123; const response = await fetch('/users.json') // get users list const users = await response.json() // parse JSON const user = users[0] // pick first user const userResponse = await fetch(`/users/$&#123;user.name&#125;`) // get user data const userData = await user.json() // parse JSON return userData&#125;getFirstUserData() 串联多个 async(异步) 函数async(异步) 函数可以非常容易地链接起来，并且语法比简单的 promise 更具可读性： 12345678910111213141516const promiseToDoSomething = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 10000) &#125;)&#125;const watchOverSomeoneDoingSomething = async () =&gt; &#123; const something = await promiseToDoSomething() return something + ' and I watched'&#125;const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; &#123; const something = await watchOverSomeoneDoingSomething() return something + ' and I watched as well'&#125;watchOverSomeoneWatchingSomeoneDoingSomething().then((res) =&gt; &#123; console.log(res)&#125;) 将打印： 1I did something and I watched and I watched as well 更容易调试调试 promise 很难，因为调试器不能跳过异步代码。 Async/await 使得调试非常简单，因为对编译器来说它就像同步代码一样。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（25）：Promises]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8825%EF%BC%89%EF%BC%9APromises%2F</url>
    <content type="text"><![CDATA[Promises 是一种 JavaScript 中处理异步代码的方法，无需在代码中编写太多回调。 Promises 通常定义为最终可用的值的代理（a proxy for a value that will eventually become available）。 其实 Promises 已经存在多年，但是直到 ES2015 才被标准化和引入，现在它们已经在 ES2017 中被 async(异步) 函数所取代。 Async functions(异步函数) 使用 promises API 作为构建块，因此理解 Promises 是理解异步函数的基础，即便在你现在写的代码中可能会使用 async(异步) 函数而不是promises 。 一句话，Promises是如何工作的一旦调用了一个 promise ，它就会以 pending(挂起) 状态开始。这意味着调用者会持续执行，同时等待自身处理结果，然后给调用函数一些反馈。 此时，该调用函数等待这个 promise 返回 resolved 状态 或者 rejected 状态，但因为 JavaScript 是异步的，所以这个函数会在 promise 工作时继续执行其它代码。 哪些 JS API使用 promises ？除了你自己的代码和库代码之外，Promises 还被用于标准的现代 Web API，例如： Battery API Fetch API Service Workers 在现代 JavaScript 中你不太可能发现自己没有使用 Promises ，所以让我们开始深入了解它们。 创建 promisePromise API 暴露了一个 Promise 构造函数，你可以使用 new Promise() 进行初始化： 123456789101112let done = trueconst isItDoneYet = new Promise( (resolve, reject) =&gt; &#123; if (done) &#123; const workDone = 'Here is the thing I built' resolve(workDone) &#125; else &#123; const why = 'Still working on something else' reject(why) &#125; &#125;) 正如你所看到的，promise 会检查 done 这个全局常量，如果 done 为 true ，我们将返回 resolved 状态的 promise ，否则将返回 rejected 状态的 promise 。 使用 resolve 和 reject 时，我们可以回传一个值，在上面的例子中我们只是回传了一个字符串，但它也可以是一个对象。 使用 promise现在让我们看看如何使用 promise 。 123456789101112const isItDoneYet = new Promise( //...)const checkIfItsDone = () =&gt; &#123; isItDoneYet .then((ok) =&gt; &#123; console.log(ok) &#125;) .catch((err) =&gt; &#123; console.error(err) &#125;)&#125; 运行 checkIfItsDone() 将执行 isItDoneYet() promise 并使用 then 回调等待该 promise 的 resolve状态。如果有错误，它将在 catch 回调中处理这个错误。 链式调用 promisespromise 可以返回另一个 promise，形成一个链式 promise。 链式调用 promises 的一个很好的例子是 Fetch API，它是XMLHttpRequest API的上层 API，我们可以使用它来获取资源，并用promise链式操作资源。 Fetch API 基于 promise 机制，调用 fetch() 等同于我们通过 new promise() 定义一个我们自己的 promise。 链式调用 promises 例子12345678910111213const status = (response) =&gt; &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return Promise.resolve(response) &#125; return Promise.reject(new Error(response.statusText))&#125;const json = (response) =&gt; response.json()fetch('/todos.json') .then(status) .then(json) .then((data) =&gt; &#123; console.log('Request succeeded with JSON response', data) &#125;) .catch((error) =&gt; &#123; console.log('Request failed', error) &#125;) 在这个例子中，我们调用 fetch() 从根域名中的 todos.json 文件获取一个 TODO 清单，我们创建了一个 promises 链。 运行 fetch() 返回一个包含很多个属性的 response，我们引用了其中的： status，数字值表示的 HTTP 状态代码 statusText，状态消息，请求成功时为 OK response 还有一个 json() 方法，该方法返回一个 resolve 状态的 promise，并且将响应内容转化为 JSON 作为该 promise 的回传值。 在这些前提下，会发生这样的情况:链中的第一个 promise 是我们定义的函数 status() ，它检查响应状态，如果响应不成功(在200到299之间)，则 reject 该 promise 。 此操作将导致 promise 链跳过队列中的所有的 promise ，并将直接跳到底部的 catch() 语句，打印 Request failed 文本以及错误消息。 如果成功，它会调用我们定义的 json() 函数。 前一个 promise 返回 response 对象，作为第二个 promise 的输入。 在这种情况下，我们返回处理过的 JSON 数据 ，因此第三个 promise 直接接收 JSON： 123.then((data) =&gt; &#123; console.log('Request succeeded with JSON response', data)&#125;) 在控制台会打印出这些内容。 处理错误在上面的例子中，promises 链后面有一个额外的 catch 块。当 promises 链有任何错误发生，将 promise 置为 reject ，控制会转到链中最近的 catch() 语句。 1234567891011new Promise((resolve, reject) =&gt; &#123; throw new Error('Error')&#125;) .catch((err) =&gt; &#123; console.error(err) &#125;)// ornew Promise((resolve, reject) =&gt; &#123; reject('Error')&#125;) .catch((err) =&gt; &#123; console.error(err) &#125;) 级联错误如果在 catch() 内部又抛出一个错误，你可以添加第二个 catch() 处理它，以此类推。 12345new Promise((resolve, reject) =&gt; &#123; throw new Error('Error')&#125;) .catch((err) =&gt; &#123; throw new Error('Error') &#125;) .catch((err) =&gt; &#123; console.error(err) &#125;) Promise.prototype.finally()这是 ES2018（ES9）的新特性. 当一个 promise 得到满足（fulfilled）时，它会一个接一个地调用 then() 方法。如果在此期间发生错误，则跳过 then() 方法并执行 catch() 方法。 finally() 允许你运行一些代码，无论 promise 的执行成功或失败： 1234fetch('file.json') .then(data =&gt; data.json()) .catch(error =&gt; console.error(error)) .finally(() =&gt; console.log('finished')) 协调 promisesPromise.all()如果你需要同步处理多个 promises，Promise.all() 可以帮助你定义一组 promises 列表，等待它们全部 resolved 之后再执行某些操作。比如： 123456789const f1 = fetch('/something.json')const f2 = fetch('/something2.json')Promise.all([f1, f2]).then((res) =&gt; &#123; console.log('Array of results', res)&#125;).catch((err) =&gt; &#123; console.error(err)&#125;) ES2015 的解构语法也允许你这么做： 123Promise.all([f1, f2]).then(([res1, res2]) =&gt; &#123; console.log('Results', res1, res2)&#125;) 这不仅限于 fetch，任何 promise 都可以处理。 Promise.race()Promise.race() 会在你传递给它的第一个 promise resolves 时运行，并且它只运行一次附加的回调，并传入首先 resolved 的 promise 返回的结果。 示例： 12345678910const first = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 500, 'first')&#125;)const second = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, 'second')&#125;)Promise.race([first, second]).then((result) =&gt; &#123; console.log(result) // second&#125;) 常见错误Uncaught TypeError: undefined is not a promise如果你在控制台中看到 Uncaught TypeError: undefined is not a promise 错误，请确保使用的是 new Promise() 而不是 Promise()。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（24）：异步编程与回调]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8824%EF%BC%89%EF%BC%9A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%9B%9E%E8%B0%83%2F</url>
    <content type="text"><![CDATA[JavaScript 默认是同步的，并且是单线程的。这意味着代码无法创建新线程并且并行运行。让我们了解一下什么是异步代码以及异步代码长什么样。 编程语言中的异步计算机在设计上是异步的。 异步意味着某些事情可以独立于主程序流而发生。 在当前的消费型计算机中，每个程序都运行在一个特定的时间段，然后它停止执行，以让另一个程序继续执行。这种循环运行进行的如此之快以至于我们无法注意到，我们认为我们的计算机同时运行许多程序，但这是一种幻觉（除了多处理器机器）。 程序内部使用中断，这是一个发送到处理器的信号，用以引起系统的注意。 我不会深入讨论它的内部细节，但请记住，程序是异步的是很正常的，并在需要注意之前停止它们的执行，并且计算机可以在此期间执行其他操作。当程序正在等待来自网络的响应时，它不能在请求完成之前停止运行。 通常，编程语言是同步的，有些语言提供了一种在语言或库中管理异步的方法。 C，Java，C＃，PHP，Go，Ruby，Swift，Python，默认情况下它们都是同步的。其中一些通过使用线程处理异步，产生一个新进程。 JavaScriptJavaScript 默认是同步的，并且是单线程的。这意味着代码无法创建新线程并且并行运行。 代码都是一行接着一行执行的，例如： 12345const a = 1const b = 2const c = a * bconsole.log(c)doSomething() 但是 JavaScript 是为了浏览器而生的，一开始它的主要工作是响应用户的操作，比如 onClick，onMouseOver，onChnage，onSubmit 等等。它怎么能使用异步编程模式呢？ 答案在它的浏览器环境中。 浏览器通过提供一组可以处理这种功能的 API 来解决这个问题。 最近，Node.js 引入了一个非阻塞 I/O 环境，将这个概念扩展到文件访问，网络调用等。 回调函数（Callbacks）你无法知道用户何时要单击按钮，因此你 要为click事件定义事件处理程序。 此事件处理程序接受一个函数，该函数将在事件触发时调用： 123document.getElementById('button').addEventListener('click', () =&gt; &#123; //item clicked&#125;) 这就是所谓的 回调函数。 回调是一个简单的函数，它作为值传递给另一个函数，并且只在事件发生时执行。 我们可以这样做，是因为函数是 JavaScript 的 “一等公民” ，可以分配给变量并传递给其他函数（称为 高阶函数 ） 将所有客户端代码包装在 window 对象上的 load 事件侦听器中是很常见的，这样仅在该页面准备就绪时才运行回调函数： 1234window.addEventListener('load', () =&gt; &#123; //window loaded //do what you want&#125;) 回调在任何地方都使用，而不仅仅在DOM事件中使用。 一个常见的例子是使用定时器： 123setTimeout(() =&gt; &#123; // runs after 2 seconds&#125;, 2000) XHR请求也接受回调。在本示例中，通过将函数分配给属性，该函数在特定事件发生时将被调用(在本例中，请求状态发生了变化)： 12345678const xhr = new XMLHttpRequest()xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; xhr.status === 200 ? console.log(xhr.responseText) : console.error('error') &#125;&#125;xhr.open('GET', 'https://yoursite.com')xhr.send() 在回调中处理错误你如何处理回调错误？ 一个非常常见的策略是使用 Node.js 采用的办法：任何回调函数中的第一个参数是错误对象：error-first callbacks（错误优先回调） 如果没有错误，则该对象为 null。 如果有错误，则包含错误的描述和其他信息。 123456789fs.readFile('/file.json', (err, data) =&gt; &#123; if (err !== null) &#123; //handle error console.log(err) return &#125; //no errors, process data console.log(data)&#125;) 回调带来的问题对于简单的情况，回调非常有用！ 但是每个回调都会增加嵌套层级，当你有很多回调时，代码开始变得非常复杂，也就是大家经常会听到的 “回调地狱” ： 123456789window.addEventListener('load', () =&gt; &#123; document.getElementById('button').addEventListener('click', () =&gt; &#123; setTimeout(() =&gt; &#123; items.forEach(item =&gt; &#123; //your code here &#125;) &#125;, 2000) &#125;)&#125;) 这仅仅是一个简单的四级代码，但是我见过更多层嵌套，这并不有趣。 我们如何解决这个问题呢？ 回调的替代方案从 ES6 开始，JavaScript 引入了一些新功能，可以帮助我们不用回调就能处理异步代码： Promises (ES6) Async/Await (ES8) 这些将在后面的章节中单独介绍。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（23）：事件循环]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8823%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[事件循环是 JavaScript 最重要的内容之一。 我已经使用 JavaScript 编码好多年了，但是仍然没有完全理解它的工作原理。当然不了解这些细枝末节也没有什么关系，但通常来讲，知道它的工作原理是很有帮助的，你可能这方面内容也有点好奇。 本节旨在解释 JavaScript 如何处理单线程以及如何处理异步函数的内在细节。 你的 JavaScript 代码运行是单线程的，同一时间只会发生一件事情。这是一个实际上非常有用的限制，因为它简化了很多程序，而不必担心并发问题。 你只需要注意编写代码的方式，避免任何可能阻塞线程的内容，如同步网络请求或无限循环。 通常，大多数浏览器的每个浏览器标签都有一个独立的事件循环，以使每个进程隔离，避免有无限循环或者繁重处理的页面阻塞整个浏览器。 浏览器管理多个并发事件循环，例如处理API调用。 Web Workers 也在自己的事件循环中运行。 你只要明白你的代码运行在单一事件循环上，并在编写代码时考虑到这一点，以避免阻塞它。 阻塞事件循环任何执行时间过长不能将控制权返回给事件循环的 JavaScript 代码都会阻塞页面内其它代码的执行，甚至阻塞 UI 线程，用户不能单击、滚动页面，等等。 几乎所有 JavaScript 中的 I/O 原语都是非阻塞的，比如网络请求，Node.js 文件系统操作等。 发生阻塞是个例外，这就是为什么 JavaScript 基于回调，以及最近的promises 和 async/await 。 调用堆栈调用堆栈是 LIFO 队列（Last In, First Out）。 事件循环不断检查调用堆栈里是否仍有函数需要运行。与此同时，它将找到的任何函数调用添加到调用堆栈，并按顺序执行每个调用。 你了解调试器或者浏览器控制台里的错误堆栈跟踪信息吗？ 浏览器在调用堆栈中查找函数名称，然后通知你当前调用由哪个函数触发： 一个简单的事件循环说明我们来举一个例子： 1234567891011const bar = () =&gt; console.log('bar')const baz = () =&gt; console.log('baz')const foo = () =&gt; &#123; console.log('foo') bar() baz()&#125;foo() 此代码打印: 123foobarbaz 正如大家所料，和预期一样。 当此代码运行时，首先调用 foo() 。在 foo()里面我们先调用 bar()，然后调用 baz()。 此时调用堆栈如下所示： 每次迭代的事件循环都会查看调用堆栈中是否还存在某些内容，并执行它： 直到调用堆栈为空。 函数执行队列上面的例子看起来很正常，没有什么特别之处：JavaScript 找到要执行的东西，按顺序运行它们。 让我们看看如何推迟一个函数的执行，直到堆栈清空。 setTimeout(() =&gt; {}), 0) 用例是调用一个函数，会在代码中其他函数都已执行完毕那一刻再执行这个函数。 举个例子： 1234567891011const bar = () =&gt; console.log('bar')const baz = () =&gt; console.log('baz')const foo = () =&gt; &#123; console.log('foo') setTimeout(bar, 0) baz()&#125;foo() 这段代码打印出来，结果是： 123foobazbar 当此代码运行时，首先调用 foo() 。 在 foo() 里面我们首先调用 setTimeout ，将 bar 作为参数传入定时器，然后我们传入0，意思是让它立即执行。 然后调用 baz()。 此时调用堆栈如下所示： 以下是我们程序中所有函数的执行顺序： 为什么会这样？ 消息队列当调用 setTimeout() 时，浏览器或者 Node.js 就会启动计时器。 在这个例子中，当我们将 0 作为超时时间，时间一到，回调函数立即被放入 消息队列 中。 消息队列也包含用户发起的事件，如单击事件、键盘事件，或者在代码有机会对 fetch 响应作出响应之前，fetch 响应就已经进入队列了，再或者像 onLoad 这样的 DOM 事件。 循环会优先进行调用堆栈，它会先处理调用堆栈里找到的所有内容，一旦没有内容，它就会在事件队列中查找要执行的内容。 我们不必等待 setTimeout ，fetch 或其他函数来完成它们自己的工作，因为它们是由浏览器提供的，并且它们依赖于自己的线程。例如，如果您将 setTimeout 超时设置为2秒，那么你不必等待 2 秒 — 等待在其他地方发生。 ES6 工作队列(Job Queue)ECMASciprt 2015 引入了工作队列概念，用在 Promises（同样在 ES6/ES2015 中引入）中。这是一种尽快执行异步函数的方法，而不是放在调用堆栈的末尾。 在当前函数结束之前resolve的 Promises 将在当前函数之后立即执行。 我发现在游乐园里乘坐过山车的情况可以很好地解释 ES6 工作队列(Job Queue)：消息队列将你放在其他游客队列之后，而工作队列(Job Queue)相当于是快速通行票，能让你插队提前坐上过山车。 例如： 1234567891011121314const bar = () =&gt; console.log('bar')const baz = () =&gt; console.log('baz')const foo = () =&gt; &#123; console.log('foo') setTimeout(bar, 0) new Promise((resolve, reject) =&gt; resolve('should be right after baz, before bar') ).then(resolve =&gt; console.log(resolve)) baz()&#125;foo() 此代码打印: 1234foobazshould be right after baz, before barbar 这是 Promises（包括基于 promises 的 Async/await）和原生的旧异步函数（通过 setTimeout() 或其他平台 API ）之间的最大的不同。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（22）：事件]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8822%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[浏览器中的JavaScript使用事件驱动的编程模型。 一切都始于事件。 本节介绍 JavaScript 事件以及事件处理的工作原理。 事件可能是 DOM 已加载，或者是异步请求完成，或用户单击元素或滚动页面，或用户按下键盘。 有很多不同类型的事件。 事件处理器（Event handlers）你可以使用事件处理程序响应任何事件，事件处理程序是在事件发生时调用的函数。 你可以为同一事件注册多个处理程序，并在事件发生时调用它们。 JavaScript 提供了三种注册事件处理程序的方法： 内联事件处理程序这种方法由于自身限制现在已经很少使用，但在早期的JavaScript中是唯一的方法： 1&lt;a href="site.com" onclick="dosomething();"&gt;A link&lt;/a&gt; DOM 事件处理器当一个对象只有一个事件处理器时这种方法很常用，因为在这种情况下无法添加多个处理程序： 123window.onload = () =&gt; &#123; //window loaded&#125; 它在处理XHR请求时最常用： 1234const xhr = new XMLHttpRequest()xhr.onreadystatechange = () =&gt; &#123; //.. do something&#125; 你可以使用 if (&#39;onsomething&#39; in window) {} 检查是否已将处理程序分配给某个属性。 使用 addEventListener()这是 现代 方式。这种方法允许我们按需注册多个处理程序，你会发现它是绑定处理程序最受欢迎的方式： 123window.addEventListener('load', () =&gt; &#123; //window loaded&#125;) 注意：IE8 及以下版本不支持这个方法，可以使用 attachEvent() 代替。如果你需要支持旧浏览器，请记住这一点。 监听不同的元素你可以监听 window 来拦截“全局”事件，比如键盘的使用，你也可以监听特定元素上发生的事件，比如鼠标点击了某个按钮。 这也是为什么 addEventListener 有时候在 window 上调用，有时候在某个 DOM 元素上调用。 Event 对象事件处理器会获得一个 Event 对象作为第一个参数： 1234const link = document.getElementById('my-link')link.addEventListener('click', event =&gt; &#123; // link clicked&#125;) 这个对象包含很多有用的属性和方法，比如： target，事件发生的目标 DOM 元素 type，事件类型 stopPropagation()，调用以阻止 DOM 事件传播 (查看完整清单) 其它属性提供给特定的事件，Event 只是不同事件的一个接口： MouseEvent KeyboardEvent DragEvent FetchEvent 等等 上面的每一个都链接到了 MDN 页面，你可以在那查看它们所有的属性。 例如，当一个键盘事件发生时，你可以通过 key 属性检查哪个键被按下（Escape, Enter 等等）： 1234window.addEventListener('keydown', event =&gt; &#123; // key pressed console.log(event.key)&#125;) 在鼠标事件中，我们可以检查哪个鼠标按钮被按下： 12345const link = document.getElementById('my-link')link.addEventListener('mousedown', event =&gt; &#123; // mouse button pressed console.log(event.button) //0=left, 2=right&#125;) 事件冒泡和事件捕获事件冒泡和事件捕获是事件传播的两个模型。 假设你的 DOM结构是这样的： 123&lt;div id="container"&gt; &lt;button&gt;Click me&lt;/button&gt;&lt;/div&gt; 你希望跟踪用户何时单击该按钮，并且你有两个事件侦听器，一个在 button 上，另一个在 #container上。 请记住，单击子元素将始终传播到其父元素，除非你停止事件传播（我们稍后会看到）。 这些事件侦听器会按照顺序调用，这个顺序通过事件冒泡/事件捕捉模型决定。 冒泡 意味着事件从被点击的元素（子元素）一直向上传播到所有祖先元素，从最近的一个开始。 在我们的例子中，button 上的处理器会在 #container 之前发生。 捕获 恰恰相反：最外部的事件会在特定处理器之前发生，比如 button 的处理程序。 默认采用事件冒泡模型。 你也可以选择使用事件捕获，通过将 addEventListener 的第三个参数设为 true： 1234567document.getElementById('container').addEventListener( 'click', () =&gt; &#123; //window loaded &#125;, true) 注意：首先运行所有捕获事件处理程序，然后才是所有冒泡的事件处理程序。 这个顺序遵循这个原则：DOM从 Window 对象开始遍历所有元素，直到找到被点击的元素项。执行点击操作时，调用与事件关联的任何事件处理程序（捕获阶段）。 一旦找到目标元素，它会重复这个过程直到回到 Window 对象，此时调用相应的事件处理器（冒泡阶段）。 这个图可以帮助你理解这个过程： 阻止传播DOM 元素上的事件将传播到其所有父元素上，除非手动阻止传播： 1234&lt;html&gt; &lt;body&gt; &lt;section&gt; &lt;a id="my-link" ...&gt; a 上的 click 事件会传播到 section 然后是 body 。 你可以调用 Event 的 stopPropagation() 方法来阻止事件传播，通常放在事件处理程序的末尾（注：我个人喜好放在事件处理程序的开始处）： 1234567const link = document.getElementById('my-link')link.addEventListener('mousedown', event =&gt; &#123; // process the event // ... event.stopPropagation()&#125;) 常见事件以下可能是你会处理的最常见事件的列表。 load页面加载完成后，在window 和 body 元素上触发 load 事件。 鼠标事件单击鼠标按钮时 click 事件触发。 单击鼠标两次时触发 dbclick 事件。 当然，在这种情况下，会先触发click事件。mousedown，mousemove 和 mouseup 可以和拖动事件结合在一起。小心使用 mousemove，因为它会在鼠标移动过程中触发很多次（稍后会看到节流）。 键盘事件当按下键盘时keydown 事件就会触发(并在处于按下状态时持续触发)。当松开键盘时，将触发keyup 事件。 滚动(Scroll)每次滚动页面时都会在 window 上触发 scroll 事件。在事件处理程序中，你可以通过检查 window.scrollY（Y轴）(注：我个人喜好用 document.documentElement.scrollTop)来检查当前的滚动位置。 请记住，此事件不是一次性的事件。它在滚动期间会发生很多次，而不仅仅是在滚动的结尾或开始时，所以不要在处理程序中进行任何频繁的计算或操作 – 而是使用节流代替。 节流(Throttling)如上所述，mousemove 和 scroll 这两个事件都不是一次性事件，而是在操作发生期间连续调用事件处理程序。这是因为它们提供坐标，因此你可以跟踪正在发生的事件。 如果你在这些事件处理器中进行复杂的操作，则会影响性能并导致站点用户体验不佳。 像 Lodash 这样的库提供了 100 行代码实现的节流函数就来处理这个问题的。一个简单易懂的实现是使用 setTimeout 每隔 100ms 缓存一次滚动事件： 12345678910let cached = nullwindow.addEventListener('scroll', event =&gt; &#123; if (!cached) &#123; setTimeout(() =&gt; &#123; //you can access the original event at `cached` cached = null &#125;, 100) &#125; cached = event&#125;)]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（21）：循环]]></title>
    <url>%2F2019%2F03%2F27%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8821%EF%BC%89%EF%BC%9A%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[JavaScript提供了许多迭代循环的方法。本节通过小例子解释现代 JavaScript 中的各种循环方法。 for12345const list = ['a', 'b', 'c']for (let i = 0; i &lt; list.length; i++) &#123; console.log(list[i]) //value console.log(i) //index&#125; 可以使用 break 中断 for 循环 可以通过 continue 跳过当前 for 循环 forEach在ES5中引入。给定一个数组，你可以使用 list.forEach() 迭代其属性： 1234567const list = ['a', 'b', 'c']list.forEach((item, index) =&gt; &#123; console.log(item) //value console.log(index) //index&#125;)//index is optionallist.forEach(item =&gt; console.log(item)) 不幸的是，你无法中断 forEach 循环。 do…while1234567const list = ['a', 'b', 'c']let i = 0do &#123; console.log(list[i]) //value console.log(i) //index i = i + 1&#125; while (i &lt; list.length) 可以通过 break 中断 do...while 循环： 123do &#123; if (something) break&#125; while (true) 可以使用 continue 跳过当前do...while循环： 1234do &#123; if (something) continue //do something else&#125; while (true) while1234567const list = ['a', 'b', 'c']let i = 0while (i &lt; list.length) &#123; console.log(list[i]) //value console.log(i) //index i = i + 1&#125; 你可以使用 break 中断 while 循环： 123while (true) &#123; if (something) break&#125; 可以通过continue 跳过当前while循环： 1234while (true) &#123; if (something) continue //do something else&#125; while 与do...while 的区别在于 do...while 至少会执行一次循环。 for…in迭代对象所有可枚举属性。 1234for (let property in object) &#123; console.log(property) //property name console.log(object[property]) //property value&#125; for…ofES2015 中引入了 for...of 循环，它结合了 forEach 的简洁性，并且for...of 循环具有可以中断循环特性： 123456789// 迭代值for (const value of ['a', 'b', 'c']) &#123; console.log(value) //value&#125;//使用 `entries()`,获取索引for (const [index, value] of ['a', 'b', 'c'].entries()) &#123; console.log(index) //index console.log(value) //value&#125; 注意使用 const 。这个循环在每次迭代都创建了一个新的作用域，所以我们可以安全的使用它替代 let 。 for…in vs for…of和 for...in 不同的是： for...of 迭代属性值 for...in 迭代属性名]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（20）：数组]]></title>
    <url>%2F2019%2F03%2F20%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8820%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[随着时间的推移，JavaScript 数组有了越来越多的功能，有时候想知道何时应该使用何种方法是个很棘手的问题。本节旨在解释截至2018年你应该使用什么。 初始化数组1234const a = []const a = [1, 2, 3]const a = Array.of(1, 2, 3)const a = Array(6).fill(1) // 初始化一个包含6项元素的数组，每项使用 1 填充，即：[1, 1, 1, 1, 1, 1] 不要使用旧语法（只用来做类型化数组） 12const a = new Array() //never useconst a = new Array(1, 2, 3) //never use 获取数组长度1const l = a.length 使用 every 迭代数组1a.every(f) 迭代 a 直到 f() 返回 false。 使用 some 迭代数组1a.some(f) 迭代 a 直到 f() 返回 true。 遍历数组并返回函数结果组成的新数组1const b = a.map(f) 遍历 a，返回每一个 a 元素执行 f() 产生的结果数组。 过滤数组1const b = a.filter(f) 遍历 a，返回每一个 a 元素执行 f() 都为 true 的新数组。 Reduce123a.reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; //...&#125;, initialValue) reduce() 对数组中每一项都调用回调函数，并逐步计算结果。如果 initaiValue 存在，accumulator在第一次迭代时等于这个值。 示例： 12345678910;[1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator * currentValue&#125;, 1)// iteration 1: 1 * 1 =&gt; return 1// iteration 2: 1 * 2 =&gt; return 2// iteration 3: 2 * 3 =&gt; return 6// iteration 4: 6 * 4 =&gt; return 24// return value is 24 forEachES6 新增。 1a.forEach(f) 遍历 a 执行 f，中途不能停止。 示例： 123a.forEach(v =&gt; &#123; console.log(v)&#125;) for..ofES6 新增。 123for (let v of a) &#123; console.log(v)&#125; for123for (let i = 0; i &lt; a.length; i += 1) &#123; //a[i]&#125; 遍历 a，可以通过 return 或者 break 中止循环，通过 continue 跳出循环。 @@iteratorES6 新增。 获取数组迭代器的值： 123456const a = [1, 2, 3]let it = a[Symbol.iterator]()console.log(it.next().value) //1console.log(it.next().value) //2console.log(it.next().value) //3 .entries() 返回一个键值对的迭代器： 12345let it = a.entries()console.log(it.next().value) //[0, 1]console.log(it.next().value) //[1, 2]console.log(it.next().value) //[2, 3] .keys() 返回包含所有键名的迭代器： 1234let it = a.keys()console.log(it.next().value) //0console.log(it.next().value) //1console.log(it.next().value) //2 数组结束时 .next() 返回 undefined。你也可以通过 it.next() 返回的 value, done 值检测迭代是否结束。当迭代到最后一个元素时 done 的值始终为 true 。 在数组末尾追加值1a.push(4) 在数组开头添加值12a.unshift(0)a.unshift(-2, -1) 移除数组中的值删除末尾的值1a.pop() 删除开头的值1a.shift() 删除任意位置的值12a.splice(0, 2) // 删除前2项元素a.splice(3, 2) // 删除从索引 3 开始的 2 个元素 不要使用 remove() ，因为它会留下未定义的值。 移除并插入值123a.splice(2, 3, 2, 'a', 'b') // 删除从索引 2 开始的 3 个元素, // 并且从索引 2 开始添加 2 元素（'a', 'b'） 合并多个数组123const a = [1, 2]const b = [3, 4]a.concat(b) // 1, 2, 3, 4 查找数组中特定元素ES5 写法：1a.indexOf() 返回匹配到的第一个元素的索引，元素不存在返回 -1。 1a.lastIndexOf() 返回匹配到的最后一个元素的索引，元素不存在返回 -1。 ES6 写法：123a.find((element, index, array) =&gt; &#123; //return true or false&#125;) 返回符合条件的第一个元素，如果不存在则返回 undefined。 通常这么用： 1a.find(x =&gt; x.id === my_id) 上面的例子会返回数组中 id === my_id 的第一个元素。 findIndex 返回符合条件的第一个元素的索引，如果不存在则返回 undefined： 123a.findIndex((element, index, array) =&gt; &#123; //return true or false&#125;) ES7 写法：1a.includes(value) 如果 a 包含 value 则返回 true。 1a.includes(value, i) 如果 a 从位置 i 后包含 value 返回 true。 获取数组的一部分1a.slice() 数组排序按字母顺序排序（按照 ASCII 值 – 0-9A-Za-z）： 12345const a = [1, 2, 3, 10, 11]a.sort() //1, 10, 11, 2, 3const b = [1, 'a', 'Z', 3, 2, 11]b = a.sort() //1, 11, 2, 3, Z, a 自定义排序 12const a = [1, 10, 3, 2, 11]a.sort((a, b) =&gt; a - b) //1, 2, 3, 10, 11 数组逆序 1a.reverse() 数组转字符串1a.toString() 返回字符串类型的值 1a.join() 返回数组元素拼接的字符串。传递参数以自定义分隔符： 1a.join(',') 复制所有值12const b = Array.from(a)const b = Array.of(...a) 复制部分值1const b = Array.from(a, x =&gt; x % 2 == 0) 将数组的一部分复制到该数组其它位置123456789const a = [1, 2, 3, 4]a.copyWithin(0, 2) // [3, 4, 3, 4]const b = [1, 2, 3, 4, 5]b.copyWithin(0, 2) // [3, 4, 5, 4, 5]// 0 是拷贝的值插到哪里// 2 从哪里开始拷贝const c = [1, 2, 3, 4, 5]c.copyWithin(0, 2, 4) // [3, 4, 3, 4, 5]//4 是结束索引 拷贝几个元素，就从插入位置开始替换几个元素。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（19）：闭包]]></title>
    <url>%2F2019%2F03%2F20%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8819%EF%BC%89%EF%BC%9A%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[这是对闭包主题的一个简单介绍，闭包是理解 JavaScript 函数如何工作的关键。 如果你曾经用 JavaScript 编写过函数，那么你已经使用了闭包。 这是一个需要理解的关键主题。 When a function is run, it’s executed with the scope that was in place when it was defined, and not with the state that’s in place when it is executed. 作用域基本上可以理解为可见的变量集合。函数会记住其词法作用域，并且能够访问在父作用域中定义的变量。 简而言之，函数有一整套可以访问的变量。 让我举一个例子来验证这一点。 123456const bark = dog =&gt; &#123; const say = `$&#123;dog&#125; barked!` ;(() =&gt; console.log(say))()&#125;bark(`Roger`) 按照预期在控制台中打印 Roger barked! 如果您想要返回操作，这样做： 12345678const prepareBark = dog =&gt; &#123; const say = `$&#123;dog&#125; barked!` return () =&gt; console.log(say)&#125;const bark = prepareBark(`Roger`)bark() 这段代码还是在控制台中打印 Roger barked! 让我们举最后一个例子，它将 prepareBark函数重用于两只不同的 dog： 123456789101112const prepareBark = dog =&gt; &#123; const say = `$&#123;dog&#125; barked!` return () =&gt; &#123; console.log(say) &#125;&#125;const rogerBark = prepareBark(`Roger`)const sydBark = prepareBark(`Syd`)rogerBark()sydBark() 打印结果： 12Roger barked!Syd barked! 如你所见，变量 say 的结果与从 prepareBark() 返回的函数相关联。 还要注意我们第二次调用 prepareBark() 时重新定义一个新的 say 变量，但这不会影响第一个 prepareBark() 作用域的状态。 这就是闭包的工作原理：返回的函数将保持作用域里的初始状态。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（18）：ES6箭头函数]]></title>
    <url>%2F2019%2F03%2F20%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8818%EF%BC%89%EF%BC%9AES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[箭头函数是 ES6/ES2015 中最具影响力的变化之一，现在被广泛使用。它们和常规函数略有不同，下面我们来了解一下。 在上面我已经介绍了箭头函数，但是因为它们很重要，所以需要再重点介绍一下。 在 ES6/ECMAScript2015 中引入了箭头函数，它们的引入彻底改变了 JavaScript 代码写法（和工作方式）。 在我看来，这种变化非常受欢迎，你现在很少在现代代码库中看到 function 关键字。 在视觉上，这是一个简单而受欢迎的变化，你可以使用更短的语法编写函数，从： 123const myFunction = function foo() &#123; //...&#125; 变成： 123const myFunction = () =&gt; &#123; //...&#125; 如果函数体只包含一条语句，则可以忽略花括号，然后把所有内容写在一行： 1const myFunction = () =&gt; doSomething() 在圆括号中传递参数： 1const myFunction = (param1, param2) =&gt; doSomething(param1, param2) 如果只有一个参数，你甚至可以忽略圆括号： 1const myFunction = param =&gt; doSomething(param) 因为这种简短的语法，箭头函数鼓励使用短函数。 隐式返回箭头函数隐式返回值：即返回值不必使用return关键字。 它在函数体只有一个语句时有效： 123const myFunction = () =&gt; 'test'myFunction() //'test' 另一个例子，返回一个对象（记住用圆括号包裹返回值，避免解释器把它看作函数体）： 123const myFunction = () =&gt; (&#123;value: 'test'&#125;)myFunction() //&#123;value: 'test'&#125; 箭头函数中 this 如何工作this概念可能很难理解，因为它根据上下文的不同而变化，同时也受到JavaScript的模式(严格模式/非严格模式)的影响。 理清这个概念很重要，因为和常规函数相比，this在箭头函数的表现有很大的不同。 当定义为对象的方法时，在常规函数中，this 指的是对象，因此你可以： 1234567const car = &#123; model: 'Fiesta', manufacturer: 'Ford', fullName: function() &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125;&#125; 调用 car.fullname() 将返回 Ford Fiesta。 箭头函数的 this 继承自执行上下文。箭头函数根本不会绑定 this，所以它的值将会在调用栈里查找，所以在以下这段代码里 car.fullName()将不起作用，并返回字符串 undefined undefined： 1234567const car = &#123; model: 'Fiesta', manufacturer: 'Ford', fullName: () =&gt; &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125;&#125; 因此，箭头函数不适合作为对象方法使用。 在实例化对象时，箭头函数也不能用作构造函数。 它会引发 TypeError 。 当不需要动态上下文，应该使用常规函数。 处理事件时也会有类似问题。DOM 事件监听器将 this设置为目标元素，如果你在事件处理程序中依赖于 this ，则需要使用常规函数： 123456789const link = document.querySelector('#link')link.addEventListener('click', () =&gt; &#123; // this === window&#125;)const link = document.querySelector('#link')link.addEventListener('click', function() &#123; // this === link&#125;)]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（17）：函数]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8817%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[现在我们将学习JavaScript中所有关于函数的知识，从概述到小细节，帮助你更好地使用函数。 JavaScript中的所有内容都在函数中执行。 函数是一个自包含的代码块，可以定义一次，并运行任意多次。 函数可以选择接受参数，并返回一个值。 JavaScript 里的函数是对象，一个特殊的对象：函数对象。 另外，函数在JavaScript中被称为一等公民（first class functions），因为它们可以被赋给一个值，可以作为参数传递，还可以作为返回值。 让我们先从ES6/ES2015 之前的语法开始。这是一个函数声明： 123function dosomething(foo) &#123; // do something&#125; 在ES6/ES2015流行的当下，简称为常规函数。 函数可以绑定给一个变量（这叫做函数表达式）： 123const dosomething = function(foo) &#123; // do something&#125; 命名函数表达式与之类似，但在堆栈调用跟踪中更好用，当错误发生时，它会显示函数的名字： 123const dosomething = function dosomething(foo) &#123; // do something&#125; ES6 / ES2015 引入了箭头函数，在使用内联函数时，它们特别适合用作参数或回调函数： 123const dosomething = foo =&gt; &#123; //do something&#125; 内联函数：匿名函数作为另一个函数的实参 箭头函数与上面的其他函数定义有很大的不同，我们会在后面的章节中详细介绍。 参数一个函数可以有一个或多个参数。 1234567891011const dosomething = () =&gt; &#123; //do something&#125;const dosomethingElse = foo =&gt; &#123; //do something&#125;const dosomethingElseAgain = (foo, bar) =&gt; &#123; //do something&#125; ES6/ES2015 开始，函数参数可以有默认值： 123const dosomething = (foo = 1, bar = 'hey') =&gt; &#123; //do something&#125; 这允许你在不填充所有参数的情况下调用函数： 12dosomething(3)dosomething() ES2017引入了参数的尾随逗号，这个功能有助于减少因移动参数时丢失逗号而导致的错误（例如，移动中间的最后一个）： 1234const dosomething = (foo = 1, bar = 'hey') =&gt; &#123; //do something&#125;dosomething(2, 'ho!') 你可以用数组包裹所有参数，然后在调用时用展开运算符展开： 12345const dosomething = (foo = 1, bar = 'hey') =&gt; &#123; //do something&#125;const args = [2, 'ho!']dosomething(...args) 记住：函数参数是有序的。使用对象作为参数，可以获得参数的名字： 1234567const dosomething = (&#123; foo = 1, bar = 'hey' &#125;) =&gt; &#123; //do something console.log(foo) // 2 console.log(bar) // 'ho!'&#125;const args = &#123; foo: 2, bar: 'ho!' &#125;dosomething(args) 注意这里用的是 { foo = 1, bar = &#39;hey&#39; }，用的是等号 ,不是 { foo : 1, bar : &#39;hey&#39; } 返回值每个函数都会返回一个值，默认情况下是 undefined。 1234const dosomething = (foo = 1,bar = 'hey') =&gt; &#123; // dosomething&#125;dosomething() // undefined 任何函数在其代码行结束时或执行流找到 return 关键字时终止执行。当 JavaScript 遇到return关键字时会自动终止函数执行，并把控制权交给调用者。 如果return后面跟一个值，这个值就会作为函数的返回值。 1234const dosomething = () =&gt; &#123; return 'test'&#125;const result = dosomething() // result === 'test' 你只能返回一个值。 要模拟返回多个值，你可以返回一个对象字面量或一个数组，并在调用函数时使用解构赋值。 使用数组： 123456const dosomething = () =&gt; &#123; return ['Roger',6]&#125;const [name,age] = dosomething()console.log(name) // Rogerconsole.log(age) // 6 使用对象： 123456const dosomething = () =&gt;&#123; return &#123;name:'Roger',age:6&#125;&#125;const &#123;name,age&#125; = dosomething()console.log(name) // Rogerconsole.log(age) // 6 嵌套函数函数可以定义在另一个函数内部： 12345const dosomething = () =&gt; &#123; const dosomethingelse = () =&gt; &#123;&#125; dosomethingelse() return 'test'&#125; 被嵌套函数的作用域是嵌套它的函数，不能从外部调用。 对象方法作为对象属性时，函数被称为方法： 12345678const car = &#123; brand: 'Ford', model: 'Fiesta', start: function() &#123; console.log(`Started`) &#125;&#125;car.start() 箭头函数中的“this”当箭头函数与常规函数用作对象方法时，有一个重要的行为区别。看看这个例子： 12345678910const car = &#123; brand: 'Ford', model: 'Fiesta', start: function() &#123; console.log(`Started $&#123;this.brand&#125; $&#123;this.model&#125;`) &#125;, stop: () =&gt; &#123; console.log(`Stopped $&#123;this.brand&#125; $&#123;this.model&#125;`) &#125;&#125; 这个 stop() 方法无法正常工作。 123456789101112const car = &#123; brand:'Ford', model:'Fiesta', start:function()&#123; console.log(`Started $&#123;this.brand&#125; $&#123;this.model&#125;`) // Started Ford Fiesta &#125;, stop:() =&gt; &#123; console.log(`Stopped $&#123;this.brand&#125; $&#123;this.model&#125;`) // Stopped undefined undefined &#125;&#125;car.start()car.stop() 这是因为两种函数风格中的 处理this 的方式是不一样的。箭头函数中的 this 指向封闭的上下文，在以下例子中是 window 对象： 123456789101112const car = &#123; brand:'Ford', model:'Fiesta', start:function()&#123; console.log(this) // &#123;brand:"Ford",model:"Fiesta",start:f,stop:f&#125; console.log(`Started $&#123;this.brand&#125; $&#123;this.model&#125;`) // Started Ford Fiesta &#125;, stop:() =&gt; &#123; console.log(this) // Window &#123;postMessage:f,blur:f,focus:f,close:f,...&#125; console.log(`Stopped $&#123;this.brand&#125; $&#123;this.model&#125;`) // Stopped undefined undefined &#125;&#125; this，是指使用 function() 的宿主对象。 这意味着箭头函数不适合用于对象方法和构造函数（箭头函数、构造函数实际上会在调用中引发 TypeError错误）。 IIFE, 立即执行函数表达式IIFE 是一个在声明后立即执行的函数： 123;(function dosomething() &#123; console.log('executed')&#125;)() 你可以将结果赋值给变量： 123const something = (function dosomething() &#123; return 'something'&#125;)() 它们非常方便，因为你无需在定义后单独调用该函数。 函数提升在执行代码之前，JavaScript 会根据规则将其重新排序。 比如将函数移动到作用域的顶部。这就是这样写合法的原因： 1234dosomething()function dosomething() &#123; console.log('did something') // did something&#125; 在底层，JavaScript 在调用之前移动函数，以及在同一作用域内找到的所有其他函数： 1234function dosomething() &#123; console.log('did something')&#125;dosomething() 看下面的代码，如果你使用命名函数表达式，因为你正在使用 JavaScript 变量，所以会发生不同的事情。我们说的变量提升，其实是变量声明被提升，但不是值被提升，因此下面的代码中不是那个函数被提升。 1234dosomething()const dosomething = function dosomething() &#123; console.log('did something') // Uncaught ReferenceError:dosomething is not defined at &lt;anonymous&gt;:1:1&#125; 这是因为内部变成了： 12345const dosomethingdosomething()dosomething = function dosomething() &#123; console.log('did something')&#125; 这在 let 声明，var 声明也一样不会工作，但是抛出的错误不同： 12345678dosomething()const dosomething = function dosomething() &#123; console.log('did something') // Uncaught ReferenceError:dosomething is not defined at &lt;anonymous&gt;:1:1&#125;dosomething2()var dosomething2 = function dosomething()&#123; console.log('did something') // Uncaught TypeError: dosomething2 is not a function at &lt;anonymous&gt;:1:1&#125; 这是因为 var 声明被提升并初始化值为 undefined，而const 和 let 仅仅只会被提升。 关于 const 和 let 是否被 hoisting（提升）的问题争论了好几年了至今没有定论，主要原因是 hoisting（提升）和 TDZ (temporal dead zone，暂时性死区)都是非官方的解释，只是帮助大家理解 JavaScript 机制的说法。 本文最后说到的示例有两种解释： 第一种解释： const 和 let 声明的变量是不会提升，因为没有提升，所以报 not defined 错误，var提升了，初始值为 undefined ，但是被当做了函数运算，undefined不是函数，所以说变量不是函数。 第二种解释：JavaScript 中所有的声明 (var, let, const, function, function, class) 都会被 hoisting（提升）。var / function / function声明和 let / const / class 声明之间的区别是初始化。const 和 let 有一个TDZ，初始化被推迟，也就是变量保持未初始化。 所以访问它时会引发ReferenceError 异常。 只有在碰到 let / const / class语句时，才会初始化变量，这叫临时死区。和变量提升是两码事。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（16）：ES6模板字面量]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8816%EF%BC%89%EF%BC%9AES6%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%2F</url>
    <content type="text"><![CDATA[模板字面量是ES2015/ES6的新功能，与 ES5 及更低版本相比，模板字面量功能允许你用更新颖的方式处理字符串。 乍一看语法非常简单，只需使用反引号而不是单引号或双引号： 1const a_string = `something` 它们和用引号构建的普通字符串相比提供了更多的功能： 提供了优秀的语法定义多行字符串 它们提供了一种在字符串中插入变量和表达式的简便方法 它们允许通过模板标签创建 DSL 让我们仔细看看这些功能。 多行字符串在 ES6 之前，创建多行字符串需要在每行行尾添加 \ 字符： 12const string = 'first part \second part' 这样看是两行字符串，但是渲染时会变成一行： 1"first part second part" 为了能够渲染多行字符串，你需要在每行末尾添加 \n： 12const string = 'first line\n \second line' 或者 12const string = 'first line\n' + 'second line' 模板字面量使创建多行字符串变得很简单： 使用模板字面量，你只用按下回车键就能创建一个新行，并按原样渲染，不用什么特别的字符，像这样： 12345const string = `Heythisstringis awesome!` 注意：空格也是有意义的，所以如果这样做： 12const string = `First Second` 将会创建一个这样的字符串： 12First Second 解决这个问题的一个简单方法是使第一行空掉，并在关闭反引号后立即跟随 trim() 方法，这将消除第一个字符前的任何空格： 123const string = `FirstSecond`.trim() 插值模板字面量提供了一个在字符串中插入变量和表达式的简单方法。 你可以使用 ${...} 语法： 12const var = 'test'const string = `something $&#123;var&#125;` //something test 在 ${} 里你可以添加任何东西，甚至是表达式： 12const string = `something $&#123;1 + 2 + 3&#125;`const string2 = `something $&#123;foo() ? 'x' : 'y' &#125;` 模板标签模板标签是一个最初听起来可能不那么有用的功能，但实际上，它被很多流行库所使用，比如Styled Components、Apollo、GraphQL客户端/服务端库，所以理解它的原理很重要。 在 Styled Components 中，模板标签被用来定义 CSS字符串： 12345const Button = styled.button` font-size: 1.5em; background-color: black; color: white;`; 在 Apollo 中，模板标签被用来定义 GraphQL 查询模式： 12345const query = gql` query &#123; ... &#125;` 这些例子中 styled button 和 gql 模板标签都是 函数： 123function gql(literals, ...expressions) &#123; &#125; 这个函数返回一个字符串，该字符串可以是任何计算结果。 literals 是一个数组，包含由表达式插值标记的字面量模板内容。 expressions 包含所有的插值。 比如上面的例子： 1const string = `something $&#123;1 + 2 + 3&#125;` literals 是一个包含两个项的数组。第一个是 something ，直到第一个插值的字符串，第二个是空字符串，第一个插值的结尾（我们只有一个）和字符串的结尾之间的空格。 一个更复杂的例子是： 1234const string = `somethinganother $&#123;'x'&#125;new line $&#123;1 + 2 + 3&#125;test` 在这个例子中，literals 数组中第一项是： 12`somethinganother ` 第二项是： 12`new line ` 第三项是： 12`test` expressions 是包含 x 和 6 的数组。 传递这些值的函数可以对它们进行任何操作，这也是这个功能的强大之处。 最简单的例子是通过简单地连接 literals 和 expressions 来复制字符串插值的作用： 1const interpolated = interpolate`I paid $&#123;10&#125;€` interpolate 是这样工作的： 12345678function interpolate(literals, ...expressions) &#123; let string = `` for (const [i, val] of expressions) &#123; string += literals[i] + val &#125; string += literals[literals.length - 1] return string&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（15）：在JavaScript中使用引号]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8815%EF%BC%89%EF%BC%9A%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BC%95%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[现在我们将谈谈 JavaScript 里的引号及其特性。 JavaScript 允许三种形式的引号： 单引号 双引号 反引号 前两种差不多： 12const test = 'test'const bike = "bike" 使用其中一种没有什么大的差别。唯一的不同在于必须转义用于分隔字符串的引号字符： 12345const test = 'test'const test = 'te\'st'const test = 'te"st'const test = "te\"st"const test = "te'st" 有很多不同的风格指南，建议始终使用其中一种。 我个人一直都用单引号，只在 HTML 中使用双引号。 反引号是JavaScript新增特性，在 2015 年的 ES6 中引入。 它们具有独特的功能 - 允许多行字符串。 使用转义字符，常规字符串也可以转换为多行字符串： 1const multilineString = 'A string\non multiple lines' 使用反引号（键盘左上角的数字 1 键），你可以不用转义字符： 12const multilineString = `A stringon multiple lines` 不仅如此。你可以用 ${} 插入变量或表达式： 12const multilineString = `A stringon $&#123;1+1&#125; lines` 这也叫做模板字符串。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（14）：在JavaScript中使用分号]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8814%EF%BC%89%EF%BC%9A%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%86%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[JavaScript 分号是可选的，我个人倾向于不写分号，但是很多人喜欢带上分号。 分号的使用在 JavaScript 社区中产生了很大的分歧。一些人不论在什么情况都很喜欢用它，而另一部分则相反。 在用了几年分号之后，2017 年秋天我决定尝试避免使用分号，我通过 Prettier 自动移除代码中的分号，除非有特定的代码结构需要它。 现在我很自然就会避免使用分号，我认为代码看起来更好，也更易读了。 因为 JavaScript 不强制要求使用分号。当一个位置需要分号，它会自动添加。 执行此操作的过程称为自动插入分号。 了解使用分号的规则非常重要，可以避免编写与预期行为不一致的错误代码。 JavaScript 自动插入分号规则在解析代码期间，出现以下特定情况，JavaScript 解释器会自动添加分号： 当下一行的起始代码打断了当前行（JavaScript 代码可以写在多行中）。如果一条语句以(、[、/、+或-开始，那么它极有可能和前面一条语句合在一起解析。 当下一行代码以 } 开头，或者以 } 闭合当前代码块时 当执行到代码末尾 当前行有 return 语句 当前行有 break 语句 当前行有 throw 语句 当前行有 continue 语句 代码行为不一致的例子基于上面的规则，这有一些例子，比如： 1234const hey = 'hey'const you = 'hey'const heyYou = hey + ' ' + you['h', 'e', 'y'].forEach((letter) =&gt; console.log(letter)) 你会看到错误 Uncaught TypeError: Cannot read property &#39;forEach&#39; of undefined，因为规则 1 尝试把代码解释为： 123const hey = 'hey';const you = 'hey';const heyYou = hey + ' ' + you['h', 'e', 'y'].forEach((letter) =&gt; console.log(letter)) 还有： 1(1 + 2).toString() // 3 1234const a = 1const b = 2const c = a + b(a + b).toString() 相反，上面的代码抛出 TypeError: b is not a function 异常，因为 JavaScript 尝试把它解释为： 123const a = 1const b = 2const c = a + b(a + b).toString() 另一个关于规则 4 的例子： 123456(() =&gt; &#123; return &#123; color: 'white' &#125;&#125;)() 你希望这个立即执行函数可以返回一个包含 color 属性的对象，但是没有。它返回的是 undefined，因为 JavaScript 会在 return 后插入一个分号。 正确的做法是把花括号放在 return 的后面： 12345(() =&gt; &#123; return &#123; color: 'white' &#125;&#125;)() 你认为这个代码会弹出 0： 121 + 1-1 + 1 === 0 ? alert(0) : alert(2) 但是它显示的是 2，因为规则 1 把它解释成： 11 + 1 -1 + 1 === 0 ? alert(0) : alert(2) 小心点。有些人对待分号很偏执，我是无所谓，这个工具既然给了我们不用分号的选项，我们就应该避免使用分号。我不是在推荐什么，你自己选择。 我们只需要稍微注意一些特殊情况，即使它们很少会出现在你的代码中。 记住这些规则： 小心使用 return 语句。如果你想返回一些东西，应该和 return 放在同一行（break, throw, continue 同理） 永远不要用圆括号开头，这可能会和上一行连接形成函数调用或者数组元素引用 最后，始终测试你的代码，确保它是你想要的。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（13）：异常处理]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8813%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[当代码发生异常问题时，JavaScript 习惯通过 exceptions 处理错误。 创建异常通过关键字 throw 创建异常： 1throw value value 可以是任意的 JavaScript 值，包括字符串，数字或者一个对象。 当 JavaScript 代码执行到这一行时，就会暂停正常的程序流，跳转到最近的异常处理器。 处理异常异常处理程序是 try/catch 语句。 try 代码块内抛出的异常都会在相应的 catch块 中处理： 12345try &#123; //lines of code&#125; catch (e) &#123; &#125; 在这个例子中，e 代表异常值。 你可以添加多个处理器，它们可以捕捉不同的错误。 finally要完成整个语句，JavaScript 有另一个语句，finally，不管程序流如何、异常是否被处理、是否产生异常，其中的代码都会执行： 1234567try &#123; //lines of code&#125; catch (e) &#123; &#125; finally &#123; &#125; 你也可以在没有 catch 的情况下使用 finally，以清除可能在 try语句中打开的任何资源，比如文件或者网络请求： 1234try &#123; //lines of code&#125; finally &#123;&#125; 嵌套 try 代码块try 可以被嵌套使用，异常始终在最近的 catch 块中被处理： 12345678910try &#123; //lines of code try &#123; //other lines of code &#125; finally &#123; //other lines of code &#125;&#125; catch (e) &#123; &#125; 如果在内部的 try中发现异常，它会在外部的 catch中被处理。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（12）：JavaScript中的Classes]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8812%EF%BC%89%EF%BC%9AJavaScript%E4%B8%AD%E7%9A%84Classes%2F</url>
    <content type="text"><![CDATA[发布于2015年的 ECMAScript 6 (ES6) 标准引入了类。 在那之前，JavaScript 只能通过一种非常独特的方法实现继承，那就是原型继承。虽然我认为这种实现很棒，但和其它的流行编程语言都不同。 使用Java 或者 Python 或者其它语言的开发者很难理解原型继承的复杂性，因此，ECMAScript 委员会决定引入语法糖，类似于其它语言基于类的继承的实现方法。 这很重要：JavaScript 底层实现仍然和之前一样，你可以用平常方法访问对象原型。 定义一个class(类)类看起来是这样的： 12345678class Person &#123; constructor(name) &#123; this.name = name &#125; hello() &#123; return 'Hello, I am ' + this.name + '.' &#125;&#125; 类有一个标识符，可以让我们通过 new ClassIdentifier() 创建一个对象实例。上述例子中你可以使用 new Person(&#39;&#39;) 来创建。 初始化对象时，将调用 constructor (构造)方法，并传递一些参数。 一个类也可以有很多方法，在这个例子中 hello 是一个方法，所有从这个类派生的对象实例都可以调用它： 12const flavio = new Person('Flavio')flavio.hello() 类的继承类可以扩展另一个类，使用该类初始化的对象继承这两个类的所有方法。 如果继承的类和更高一级的类有同名的方法，则按最近优先的原则调用： 1234567class Programmer extends Person &#123; hello() &#123; return super.hello() + ' I am a programmer.' &#125;&#125;const flavio = new Programmer('Flavio')flavio.hello() 上面的程序会打印出：“Hello, I am Flavio. I am a programmer.”。 类没有显式地声明变量，但是你必须在构造函数中初始化变量。 在一个类中，你可以通过调用 super() 引用父类。 静态方法通常来讲，方法定义在实例上，而不是类上。 静态方法能在类上执行： 123456class Person &#123; static genericHello() &#123; return 'Hello' &#125;&#125;Person.genericHello() //Hello 私有方法JavaScript 没有内置的方法来定义私有或受保护的方法。也有解决方法，但是这里将不再赘述。 Getters 和 Setters你可以添加 get 或者 set 前缀创建一个 getter 和 setter，用哪一种方法取决于你想做什么：访问变量或者修改变量的值。 1234567891011class Person &#123; constructor(name) &#123; this.name = name &#125; set name(value) &#123; this.name = value &#125; get name() &#123; return this.name &#125;&#125; 如果属性只有一个 getter，这个属性就不能被设置，所有的修改都会被忽略： 12345678class Person &#123; constructor(name) &#123; this.name = name &#125; get name() &#123; return this.name &#125;&#125; 如果属性只有一个 setter，你可以随意修改它的值，但是不能从外部访问它： 12345678class Person &#123; constructor(name) &#123; this.name = name &#125; set name(value) &#123; this.name = value &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（11）：原型继承]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8811%EF%BC%89%EF%BC%9A%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[JavaScript 在流行的编程语言中非常独特，因为它使用了原型继承。让我们看看这意味着什么。 大多数面向对象语言使用基于类的继承模式，JavaScript 基于原型继承。 这是什么意思？ 每一个 JavaScript 对象都有名为prototype的属性，它指向不同的对象。 这个不同的对象就是对象原型。 我们的对象会继承该对象原型的属性和方法。 假设你通过对象字面量语法创建了一个对象： 1const car = &#123;&#125; 或者通过 new Object 语法创建： 1const car = new Object() 无论哪一种方法，car 的原型都是 Object。 如果初始化一个数组，数组其实也是一个对象： 123const list = []//orconst list = new Array() 这里的list的原型是 Array。 你可以通过使用Object.getPrototypeOf()方法和Object.prototype.isPrototypeOf()方法来验证： 123456const car = &#123;&#125;const list = []Object.getPrototypeOf(car) === Object.prototype // trueObject.prototype.isPrototypeOf(car) // trueObject.getPrototypeOf(list) === Array.prototype // trueArray.prototype.isPrototypeOf(list) // true 你也可以通过 __proto__ 属性验证： 12345car.__proto__ == Object.prototype //truecar.__proto__ == new Object().__proto__ //truelist.__proto__ == Object.prototype //falselist.__proto__ == Array.prototype //truelist.__proto__ == new Array().__proto__ //true 这里的 __proto__ 属性不是标准的但是在浏览器里被广泛实现。更可靠的获得原型的方法是 Object.getPrototypeOf(new Object())。 你可以在控制台中看到，它们的constructor属性分别是Object()和Array()： 原型上所有的属性和方法对于拥有该原型的对象都是可用的： Object.prototype 是所有对象的原型。 1Array.prototype.__proto__ == Object.prototype // true 如果你想知道 Object.prototype 的原型是什么，那就是没有原型(null)。 上面的例子是原型链的示例。 I can make an object that extends Array and any object I instantiate using it, will have Array and Object in its prototype chain and inherit properties and methods from all the ancestors. 除了用 new 创建一个对象，或者用对象和数组的字面量语法，你还可以用 Object.create() 实例化一个对象。 传递的第一个参数作为对象的原型： 12const car = Object.create(&#123;&#125;)const list = Object.create(Array) 你可以用 isPrototypeOf() 方法检查这个对象的原型： 12Array.isPrototypeOf(list) //trueObject.isPrototypeOf(list) //false 注意，因为你可以这样实例化一个数组： 1const list = Object.create(Array.prototype) 在这种情况下，Array.isPrototypeOf(list) 等于 false，而 Array.prototype.isPrototypeOf(list) 等于 true。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（10）：表达式]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[表达式是可以计算并解析为值的代码单元。JS 中的表达式可以分为几类。 算术表达式这个分类下所有表达式对数字进行求值： 12341 / 2i++i -= 2i * 2 字符串表达式对字符串求值： 12'A ' + 'string''A ' += 'string' 原始表达式这个分类下有变量引用，字面量和常量： 1234567820.02'something'truefalsethis //the current objectundefinedi //where i is a variable or a constant 也有一些语言关键字： 123456789functionclassfunction* //the generator functionyield //the generator pauser/resumeryield* //delegate to another generator or iteratorasync function* //async function expressionawait //async function pause/resume/wait for completion/pattern/i //regex() // grouping 数组和对象初始化表达式12345[] //array literal&#123;&#125; //object literal[1,2,3]&#123;a: 1, b: 2&#125;&#123;a: &#123;b: 1&#125;&#125; 逻辑表达式逻辑表达式使用逻辑运算符，获得一个布尔值： 123a &amp;&amp; ba || b!a Left-hand-side 表达式123new //create an instance of a constructorsuper //calls the parent constructor...obj //expression using the spread operator 属性访问表达式123object.property //reference a property (or method) of an objectobject[property]object['property'] 对象创建表达式123new object()new a(1)new MyRectangle('name', 2, &#123;a: 4&#125;) 函数定义表达式12345function() &#123;&#125;function(a, b) &#123; return a * b &#125;(a, b) =&gt; a * ba =&gt; a * 2() =&gt; &#123; return 2 &#125; 调用表达式调用函数或方法的语法 12a.x(2)window.resize()]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（9）：数据类型]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%889%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[你可能有时候会读到 JS 是无类型的，但是这并不正确。你确实可以为一个变量绑定各种不同的类型，但是 JavaScript 是有类型的。它提供了基本类型和对象类型。 基本类型基本类型有： Numbers(数字) Strings(字符串) Booleans(布尔) 还有两个特别类型： null(空值) undefined(未定义) 让我们在接下来深入了解它们。 Numbers(数字)本质上，JavaScript 只有一种数字类型：所有数字都是浮点型。 一个数字字面量是代码里表示的数字，取决于你如何去写它，它可以是整型字面量也可以是浮点型字面量。 整型： 1231053545767673210xCC //hex 浮点型： 1233.14.12345.2e4 //5.2 * 10^4 strings(字符串)字符串类型是一系列字符。在代码中它被定义成字符串字面量，用单引号或者双引号包裹。 12'A string'"Another string" 字符串可以通过反斜杠跨越多行： 12"A \string" 字符串可在被打印时解析转义序列，例如 \n 以创建一个新行。当你需要在引号括起的字符串中输入引号时，反斜杠可以用来防止将字符解释为结束引号： 1'I\'m a developer' 字符串可以用 + 操作符拼接： 1"A " + "string" 模板字符串在 ES2015中引入，模板字符串是字符串字面量，允许用更强大的方法定义一个字符串。 1`a string` 你可以在模板字符串中嵌入变量： 123`a string with $&#123;something&#125;``a string with $&#123;something+somethingElse&#125;``a string with $&#123;obj.something()&#125;` 你可以很容易的获得多行字符串： 123`a stringwith$&#123;something&#125;` Booleans(布尔)对于布尔型，JavaScript 有两个保留字：true 和 false。大多数比较运算符 == === &gt; &lt; 等等都返回其中的一个。 if，while 语句和其它控制结构使用布尔值决定程序的流程。 他们不仅接受 true 和 fasle，也会接受 truthy 和 falsy 的值。 Falsy，值被解释为 false： 1234560-0NaNundefinednull'' //empty string 其余的都属于 truthy。 null(空值)null 是一个特殊值，表示没有值。这在其它语言里也是普遍的观念，比如 nil 或者 Python 里的 None。 undefined(未定义)undefined 表示变量还没有初始化。 函数里没有 return 值时函数就会返回 undefined。当函数参数没有被调用者赋值时，函数参数也是 undefined。 检测一个值是否为 undefined，你可以用这个方法： 1typeof variable === 'undefined' 对象类型所有不属于基本类型的都是对象类型。 函数，数组和我们称之为对象的都是对象类型。它们本身是特殊的，但是它们继承了对象的很多特点，比如具有属性，并且还有对这些属性起作用的方法。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（8）：变量]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%888%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[JavaScript 变量简介变量是分配给标识符的字面量，所以你可以在后续的代码里引用和使用它。我们将会学习如果在 JavaScript 里声明一个变量。 JavaScript中的变量没有绑定任何类型。即使你为一个变量绑定了一个特定的类型，你也可以在后面重新绑定其它任何类型，这不会造成类型错误或者其它问题。 这也是为什么有时候JavaScript 会被认为是 “无类型的”。 在使用变量前必须先声明变量。有三种声明方法：使用 var, let 或者 const。这三种方式的不同在于后续你如何和这个变量进行交互。 使用 var在ES2015以前, var 是定义变量的唯一方法。 1var a = 0 如果你忘了加 var，你将给未声明的变量分配值，结果可能会有所不同：在现代环境里，开启严格模式，这样会报错。在旧环境里（或者关闭严格模式），这样会简单地初始化一个变量并把它绑定到全局对象。 如果你声明变量时没有初始化，则在为其赋值之前，它的值为 undefined (未定义)。 1var a //typeof a === 'undefined' 你可以多次重新声明变量，用以覆盖它： 12var a = 1var a = 2 你可以在同一个语句中一次性声明多个变量： 1var a = 1, b = 2 作用域是指代码中变量的可见性。 在任何函数外部通过 var 初始化的变量会绑定到全局对象，具有全局作用域并且在任何位置都可用。在函数内部通过 var 初始化的变量会绑定在这个函数内，它被称为本地作用域或者函数作用域，仅在函数内部可用，就和函数的参数一样。 Any variable defined into a function with the same name of a global variable takes precedence over the global variable, shadowing it. 重要的是要了解一个block(块)（用一对花括号区分）没有定义一个新的作用域。新作用域只会随着函数的创建被创建，因为 var 没有块级作用域，只有函数作用域。 在函数内部，其中定义的任何变量在函数代码里都是可见的，即使是定义在尾部的变量也会在函数头部被引入，这是因为 JavaScript 会自动将所有变量移动到顶部（即变量提升）。为了避免造成困扰，应该始终在函数头部声明变量。 使用 letlet 是 ES2015 里引入的新特性，本质上是拥有块级作用域的 var。它的作用域被限制在定义它的块，语句或者表达式，以及所有包含的内部块。 现代 JavaScript 开发者可能会只用 let 而完全放弃使用 var。 如果 let 看起来是个模糊的术语，就看看 let color = &#39;red&#39;，让颜色变成红色，这样容易明白得多。 在函数外部使用 let，和 var 相反，不会创建一个全局变量。 使用 const使用 var 或者 let 声明的变量可以在后面进行更改和重绑定。一旦 const 被初始化，它的值将不能被修改，也不能绑定其它的值。 1const a = 'test' 我们不能为 a 绑定不同的值。然而，如果 a 是一个提供改变方法的对象，我们仍然可以改变它。 const 不提供不可变性，只能确保不会更改引用。 const 和 let 一样，提供块级作用域。 现代 JavaScript 开发者可能会总是选择 const 作为声明将来不需要重新绑定的变量的标识符。 为什么？因为我们应该始终使用最简单的构造变量避免发生错误。 使用 const 声明的变量不能被改变，但是如果这个变量是数组或者对象的话，它里面持有的内容可以被更新。它里面持有的内容不是不可改变的。 12345// allowedconst helloWorld = &#123;text: 'Welcome to the Road to learn React'&#125;;helloWorld.text = 'Bye Bye React'; 但是，不同的声明方式应该在什么时候使用呢？有很多的选择。我的建议是在任何你可以使用 const 的时候使用它。这表示尽管对象和数组的内容是可以被修改的，你仍希望保持该数据结构不可变。而如果你想要改变你的变量，就使用 let 去声明它。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（7）：词法结构]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89%EF%BC%9A%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[现在我们将深入探讨JavaScript的构建块：unicode，分号，空格，大小写敏感，注释，字面量，标识符和保留字。 UnicodeJavaScript 是用 Unicode 编写的。这意味着你可以用 Emojis 作为变量名。😃 😧 😲 更重要的是，你可以用任何语言书写标识符，比如日文或者中文，相关规则。 分号JavaScript 语法和 C 语言类似，你可能会在很多示例代码里看到每行代码末尾都有分号。 分号不是强制性的，JavaScript 不使用分号没有任何问题。现在很多开发者，特别是从不需要分号的语言转过来的那部分开发者开始避免使用分号。 你需要避免一些奇怪的做法，比如将一条语句拆分成多行： 12returnvariable 或者一行代码以括号（[ 或者 (）开始，你的代码在 99.9% 的时间里都是安全的（你的 linter(检查器) 也会警告你）。 这取决于个人喜好，最近我决定再也不加无用的分号，所以在这篇文章里你看不到任何分号。 空格JavaScript 不认为空格有意义。理论上，可以以你喜欢的任何方式添加空格和换行符。 在实践中，你很可能会遵守良好定义的编码风格和人们习以为常的规则，强制使用 linter 或者 Prettier 这样的工具。 比如，我喜欢缩进两个字符。 大小写敏感JavaScript 是大小写敏感的。变量 something 和 Something 是不同的。任何标识符都是如此。 注释在 JavaScript 里，有两种注释方式： 12/* */// 第一个可以进行多行注释并且需要闭合。 第二个会注释掉当前行位于其右侧的所有内容。 字面量和标识符我们将源码中编写的值定义为字面量，例如数字，字符串，布尔值或者更高级的构造，像对象字面量或者数组字面量： 123455'Test'true['a', 'b']&#123;color: 'red', shape: 'Rectangle'&#125; 标识符是可用于标识变量，函数，对象的字符序列。它可以用字母、美元符号 $或者一个下划线 _ 开头，它也可以包含数字。使用 Unicode，字母可以是任何被允许的字符，比如emoji 😃。 123456TesttestTEST_testTest1$test 美元符号通常被用来引用 DOM 元素。 保留字你不能使用下列任何单词作为标识符，因为他们是JavaScript保留字。 123456789101112131415161718192021222324252627282930313233343536373839404142breakdoinstanceoftypeofcaseelsenewvarcatchfinallyreturnvoidcontinueforswitchwhiledebuggerfunctionthiswithdefaultifthrowdeleteintryclassenumextendssuperconstexportimportimplementsletprivatepublicinterfacepackageprotectedstaticyield]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（6）：编码风格]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%EF%BC%9A%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[JavaScript 编码风格指南有很多，其中有两个在JavaScript社区最为常见： The Google JavaScript Style Guide The AirBnb JavaScript Style Guide 你可以选择使用其中一种或者制定自己的代码风格。 编码风格与你的项目保持一致即使你有自己更喜欢的代码风格，在团队协作中你也要遵守团队项目风格。 Github 上的每个开源项目都可能会有一系列规则，你参与的另一个项目可能会有完全不同的规则。 Prettier 是格式化代码的强大工具，你应该试试它。 本指南的编码规则我们一直使用最新的 ES 版本，在旧版本的浏览器中使用 Babel。 缩进：用空格代替 tabs，缩进两个空格。 分号：不要使用分号。 每行长度：如果可能，尽力保证每行不超过 80 个字符。 行内注释：在代码中使用内联注释。 仅将块注释用于文档。 不要有无用代码：不要遗留旧的代码注释，仅仅是为了防止它将来还有用。保证只有现在需要的代码，版本控制或者你的笔记应用就是为此而生的。 只在需要时注释：不要添加不能帮助理解的注释。如果代码自身有良好的变量、函数命名和 JSDoc 函数注释，不要添加注释。 变量声明：避免污染全局变量，永远不要使用 var。默认使用 const，只在需要重新分配变量时使用 let。 常量：用大写字母声明所有常量，用 _ 分割 VARIABLE_NAME(变量名)中的单词。 函数：使用箭头函数，除非你有使用常规函数的理由，比如在对象方法或者构造函数中，需要确定 this 的指向。用 const 声明函数，并尽可能隐式返回。可以随意使用嵌套函数将辅助函数隐藏到其他代码中。 译注：辅助函数是降低其他函数内复杂性的一种方法。例如，如果你需要在其他函数中频繁进行计算，则可以创建一个辅助函数，该函数返回该计算并将该函数嵌入到你需要的任何位置。从本质上讲，辅助函数的结构与其他函数之间几乎没有区别，尽管它们应该是小而通用的。 12const test = (a, b) =&gt; a + bconst another = a =&gt; a + 2 命名：函数命，变量名和方法名始终以小写字母开始（除非他们是私有的，后面会有这方面的详细介绍)，并且使用驼峰命名(camelCased)，只有构造函数和类名应该以大写字母开始。如果你使用的框架有特别约定，请根据需求改变你的习惯。文件名应全部小写，用 - 分割。 特定语句的格式和规则： if：始终使用{}。 123456789101112131415if (condition) &#123; statements&#125;if (condition) &#123; statements&#125; else &#123; statements&#125;if (condition) &#123; statements&#125; else if (condition) &#123; statements&#125; else &#123; statements&#125; for：始终在初始化时缓存遍历对象的长度，不要把它插入到条件语句中。避免使用 for in 表达式，除了和 .hasOwnProperty() 配合使用，首选 for of： 123for (initialization; condition; update) &#123; statements&#125; while 123while (condition) &#123; statements&#125; do 123do &#123; statements&#125; while (condition); switch 123456switch (expression) &#123; case expression: statements default: statements&#125; try 123456789101112try &#123; statements&#125; catch (variable) &#123; statements&#125;try &#123; statements&#125; catch (variable) &#123; statements&#125; finally &#123; statements&#125; 空格：明智地使用空格来提高代码可读性： 在关键字之后加一个空格，再后跟一个 ( ; 在二进制运算符（+, -, / ,*, &amp;&amp; …）前面和后面插入一个空格； 在for语句之后，每个 ; 后插入一个空格将每个语句分开； 在每个 , 后插入一个空格。 空白行(New Lines)：使用空白行分隔执行逻辑相关操作的代码块。 引号：使用单引号 &#39; 代替双引号 &quot;。双引号是 HTML 标准中的属性，所以使用单引号可以避免在处理 HTML 字符串时出现的问题。适当的时候使用模板字符串而不是变量插值。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（5）：ES2018（ES9）新增特性]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%EF%BC%9AES2018%EF%BC%88ES9%EF%BC%89%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[ES2018 是最新的 ECMAScript 标准（译注：现在不是了）。 它引入了哪些新东西呢？ Rest(剩余)/Spread(展开) 属性ES6 在处理数组解构时,引入了 rest(剩余)元素的概念： 12const numbers = [1, 2, 3, 4, 5][first, second, ...others] = numbers 还有展开元素： 123const numbers = [1, 2, 3, 4, 5]const sum = (a, b, c, d, e) =&gt; a + b + c + d + econst sum = sum(...numbers) // 勘误：此处不能对 sum 重新赋值。 ES2018 为对象引入了同样的功能。 rest(剩余)属性： 1234const &#123; first, second, ...others &#125; = &#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;first // 1second // 2others // &#123; third: 3, fourth: 4, fifth: 5 &#125; 展开属性允许通过组合展开运算符 ... 之后传递的对象属性来创建新对象： 12const items = &#123; first, second, ...others &#125;items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125; 异步迭代新的构造函数 for-await-of 允许你使用异步可迭代对象作为循环迭代： 123for await (const line of readLines(filePath)) &#123; console.log(line)&#125; 因为这里用了 await ，所以你只能在 async 函数内部使用它，就像一个普通的 await（参考 async/await）。 Promise.prototype.finally()当一个 promise 完成（fulfilled），它会一个接一个的调用 then() 方法。 如果在这个过程中出现了任何错误，then() 方法会被跳过，并执行 catch() 方法。 无论 promise 执行成功还是失败，finally() 都会运行其中的代码： 1234fetch('file.json') .then(data =&gt; data.json()) .catch(error =&gt; console.error(error)) .finally(() =&gt; console.log('finished')) 正则表达式改进先行断言(lookahead) 和 后行断言(lookbehind)正则表达式后行断言(lookbehind)：根据前面的内容匹配字符串。 下面是一个先行断言：你可以使用 ?= 匹配一个字符串，该字符串后面跟着一个特定的子字符串： 123/Roger(?=Waters)//Roger(?= Waters)/.test('Roger is my dog') //false/Roger(?= Waters)/.test('Roger is my dog and Roger Waters is a famous musician') //true ?! 执行相反的操作，匹配一个字符串，该字符串后面没有一个特定的子字符串： 123/Roger(?!Waters)//Roger(?! Waters)/.test('Roger is my dog') //true/Roger(?! Waters)/.test('Roger Waters is a famous musician') //false 先行断言使用 ?= 标识符，它们已经可用了。 后行断言，是一个新功能，使用 ?&lt;=。 123/(?&lt;=Roger) Waters//(?&lt;=Roger) Waters/.test('Pink Waters is my dog') //false/(?&lt;=Roger) Waters/.test('Roger is my dog and Roger Waters is a famous musician') //true 后行断言(lookbehind) 逆操作，使用 ?&lt; !。 123/(?&lt;!Roger) Waters//(?&lt;!Roger) Waters/.test('Pink Waters is my dog') //true/(?&lt;!Roger) Waters/.test('Roger is my dog and Roger Waters is a famous musician') //false Unicode 属性转义 \p{…} 和 \P{…}在一个正则表达式里，你可以使用 \d 匹配任意数字， \s 匹配不包括空格的任意字符，\w 匹配任意字母数字字符等等。 这个新功能通过引入 \p{} 和 \P{} 将此概念扩展到所有 Unicode 字符。 任何 unicode 字符都有一组特定的属性。举个例子，Script 决定了语言家族，ASCII 是一个布尔值， 对于 ASCII 字符，值为 true，依此类推。你可以把这个属性放到大括号中，正则表达式会检查是否为真： 123/^\p&#123;ASCII&#125;+$/u.test('abc') //✅/^\p&#123;ASCII&#125;+$/u.test('ABC@') //✅/^\p&#123;ASCII&#125;+$/u.test('ABC🙃') //❌ ASCII_Hex_Digit 是另一个布尔属性，它会检查字符串是否仅包含有效的十六进制数字： 12/^\p&#123;ASCII_Hex_Digit&#125;+$/u.test('0123456789ABCDEF') //✅/^\p&#123;ASCII_Hex_Digit&#125;+$/u.test('h') //❌ 还有很多布尔属性，你只用把他们的名字放在大括号中就可以用了，比如：Uppercase, Lowercase, White_Space, Alphabatic, Emoji 等等： 1234/^\p&#123;Lowercase&#125;$/u.test('h') //✅/^\p&#123;Uppercase&#125;$/u.test('H') //✅/^\p&#123;Emoji&#125;+$/u.test('H') //❌/^\p&#123;Emoji&#125;+$/u.test('🙃🙃') //✅ 除了这些二进制属性之外，你还可以检查任意 unicode 字符是否匹配特定的值。在这个例子中，我检查了字符串是希腊语还是拉丁字母写的： 12/^\p&#123;Script=Greek&#125;+$/u.test('ελληνικά') //✅/^\p&#123;Script=Latin&#125;+$/u.test('hey') //✅ 了解更多内容可以阅读提案。 命名捕获组在 ES2018中，可以为捕获组分配一个名称，而不是仅在结果数组中绑定一个插槽(slot)： 12345const re = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/const result = re.exec('2015-01-02')// result.groups.year === '2015';// result.groups.month === '01';// result.groups.day === '02'; 正则表达式 ‘s’s 是单行(single line)的缩写，它可以和 . 一起匹配新行。如果没有它，点标识符将匹配普通字符，而不是新行： 12/hi.welcome/.test('hi\nwelcome') // false/hi.welcome/s.test('hi\nwelcome') // true]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（4）：ES2017（ES8）新增特性]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%EF%BC%9AES2017%EF%BC%88ES8%EF%BC%89%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[ECMAScript 2017，ECMA-262 标准的第八版（又称 ES2017 或者 ES8），于2017年6月发布。 和 ES6 相比，ES8仍然是一个JavaScript小版本， 但该版本仍然引入了非常有用的功能： 字符串补全长度(padStart()和 padEnd()) Object.values Object.entries Object.getOwnPropertyDescriptors() 函数参数的尾逗号 异步函数(Async functions) Shared memory and atomics 字符串补全长度(padStart()和 padEnd())String padding 的目的是为一个字符串添加字符，让它可以和声明的长度一致。 ES2017 引入了两个 String 上的方法：padStart() 和 padEnd()。 12padStart(targetLength [, padString])padEnd(targetLength [, padString]) 例子： padStart() 输出 ‘test’.padStart(4) ‘test’ ‘test’.padStart(5) ‘ test’(注：test前有1个空格) ‘test’.padStart(8) ‘ test’(注：test前有4个空格) ‘test’.padStart(8, ‘abcd’) ‘abcdtest’ padEnd() 输出 ‘test’.padEnd(4) ‘test’ ‘test’.padEnd(5) ‘test ‘(注：test后有1个空格) ‘test’.padEnd(8) ‘test ‘(注：test后有4个空格) ‘test’.padEnd(8, ‘abcd’) ‘testabcd’ Object.values()这个方法返回一个包含所有对象自身属性值的数组。用法： 12const person = &#123; name: 'Fred', age: 87 &#125;Object.values(person) // ['Fred', 87] Object.values() 也可以用于数组： 12const people = ['Fred', 'Tony']Object.values(people) // ['Fred', 'Tony'] Object.entries()这个方法返回一个 [key, value] 形式的包含对象自身所有属性及值的数组。用法： 12const person = &#123; name: 'Fred', age: 87 &#125;Object.entries(person) // [['name', 'Fred'], ['age', 87]] Object.entries() 也可以用于数组： 12const people = ['Fred', 'Tony']Object.entries(people) // [['0', 'Fred'], ['1', 'Tony']] getOwnPropertyDescriptors()这个方法返回对象的所有自有（非继承的）属性描述符。 JavaScript 中的所有对象都有一个属性集合，每个属性都有一个描述符。 描述符是属性(property) 的一组特性(attributes)，它包括下面这些子集： value：属性的值 writable：为 true 时属性可以被重写 get：属性的 getter 函数，当读取属性时被调用 set：属性的 setter 函数，当设置属性值时被调用 configurable：当且仅当指定对象的属性描述可以被改变或者属性可被删除时，为true enumerable：为 true 时，属性可枚举 Object.getOwnPropertyDescriptors(obj) 接受对象作为参数，返回一个包含描述符集的对象。 这个方法有什么用？ES2015 给我们带来了 Object.assign()方法，它从一个或多个对象复制所有可枚举的属性，并返回一个新对象。 然而这样操作有个问题，它无法正确复制没有默认特性(attributes) 的属性。举个例子，如果一个对象只有一个 setter，就无法使用 Object.assign() 正确地复制到一个新对象。例如： 12345const person1 = &#123; set name(newName) &#123; console.log(newName) &#125;&#125; 这样不会工作： 12const person2 = &#123;&#125;Object.assign(person2, person1) 但是这样可以： 123const person3 = &#123;&#125;Object.defineProperties(person3,Object.getOwnPropertyDescriptors(person1)) 你可以通过控制台简单测试一下： 123456person1.name = 'x'"x"person2.name = 'x'person3.name = 'x'"x" person2 没有 setter，它不能被正确复制。 使用 Object.create() 对对象浅克隆也有同样的限制。 函数参数的尾逗号这个功能允许在函数声明和函数调用中使用尾随逗号： 1234const doSomething = (var1, var2,) =&gt; &#123; //...&#125;doSomething('test2', 'test2',) 这个改变将鼓励开发者停止使用丑陋的“行首逗号”的习惯。 异步函数ES2017 引入了异步函数的概念，它也是这个 ECMAScript 版本里最重要的变化。 异步函数是 promises 和 generators 的结合，用以简化promises调用，在不打破promises链式调用的同时提高代码的可读性。 为什么异步函数有用异步函数是对 promises更高层次的抽象。 ES2015引入 Promises是为了解决异步代码的问题，并且的确做到了。但是从ES2015发布到 ES2017 发布的两年里，人们清楚的认识到promises并不是解决这个问题的最终方案。 引入 Promises 是为了解决著名的回调地狱问题，但它们同时也引入了自身的复杂性和语法复杂性。他们是很好的原语，在此基础上可以让开发者使用更好的语法：那就是异步函数。 一个简短的例子使用异步函数的代码可以像这样： 1234567891011function doSomethingAsync() &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125;async function doSomething() &#123; console.log(await doSomethingAsync())&#125;console.log('Before')doSomething()console.log('After') 上面的代码会在浏览器控制台里打印出： 123BeforeAfterI did something //after 3s 链式调用多个异步函数链式调用异步函数很简单，而且比原始的 promises 更易读： 12345678910111213141516function promiseToDoSomething() &#123; return new Promise((resolve)=&gt;&#123; setTimeout(() =&gt; resolve('I did something'), 10000) &#125;)&#125;async function watchOverSomeoneDoingSomething() &#123; const something = await promiseToDoSomething() return something + ' and I watched'&#125;async function watchOverSomeoneWatchingSomeoneDoingSomething() &#123; const something = await watchOverSomeoneDoingSomething() return something + ' and I watched as well'&#125;watchOverSomeoneWatchingSomeoneDoingSomething().then((res) =&gt; &#123; console.log(res)&#125;) 共享内存和AtomicsWebWorkers 用来在浏览器里构建多线程程序。 他们通过事件（events）提供一种通信协议。从 ES2017 开始，你可以通过 SharedArrayBuffer 在 web workers 及其创建者之间创建一个共享内存数组。 由于我们不知道向共享内存部分写入要花费多少时间来传播，因此Atomics是一种在读取值时执行该操作的方法，并且完成了所有类型的写入操作。 更多内容可以在这个提案中找到，该提案已经被实现。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（3）：ES2016（ES7）新增特性]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%EF%BC%9AES2016%EF%BC%88ES7%EF%BC%89%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[ES7，正式名称为ECMAScript 2016，发布于2016年6月。 与ES6相比，ES7是JavaScript的一个小版本，仅包括两个新特性： Array.prototype.includes 指数运算符 Array.prototype.includes()这个功能引入了更易读的语法来检查一个数组是否包括某个元素。 在 ES6 以及更低版本中，检查某个元素是否在数组中你不得不使用 indexOf检查数组的索引，如果返回 -1 元素则不在数组中。 因为 -1 被认为是个真值，所以你无法判断下面这个例子： 123if (![1,2].indexOf(3)) &#123; console.log('Not found')&#125; 用 ES7 的新语法可以得到我们预期的结果： 123if (![1,2].includes(3)) &#123; console.log('Not found') // ![1,2].includes(3)为true&#125; 指数运算符指数运算符 ** 等价于Math.pow() ，但是引入的是个语言特性，而不是一个库函数。 1Math.pow(4, 2) === 4 ** 2 这个功能是一个对那些包含大量数学计算的 JavaScript 应用的很好的补充。** 运算符在很多语言中都已经标准化，比如 Python，Ruby，MATLAB，Lua，Perl 等等。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记]]></title>
    <url>%2F2019%2F03%2F16%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第(1)节 Java变量在 Java 中，我们通过三个元素描述变量：变量类型、变量名以及变量值。 12String myname = "tom";int age = 20; 第(2)节 Java数据类型Java 语言是一种强类型语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型。 Java 中有两类数据类型： 基本数据类型 数值型：包含整数类型(byte、short、int、long)，浮点类型(float、double)； 字符型(char)、布尔型(boolean) 数据类型 说明 字节 应用 int 整型 4 用于存储整数如年龄、个数 double 双精度浮点型 8 用于存储小数，如商品价格、成绩平均分 float 单精度浮点型 4 用于存储小数，如身高 char 字符型 2 用于存储单个字符，如性别“男”、“女” boolean 布尔型 1 表示“真”或“假”，取值只能是true或false 你可能已经注意到了： 12float height = 175.2f; // 为float变量赋值时在数值后面添加字母f，否则默认浮点数是doube型char level = 'A'; // 为char变量赋值时使用单引号引起来 引用数据类型 类(class)、接口(interface)、数组 在 Java 的领域里，基本数据类型变量存的是数据本身，而引用类型变量存的是保存数据的空间地址。说白了，基本数据类型变量里存储的是直接放在抽屉里的东西，而引用数据类型变量里存储的是这个抽屉的钥匙，钥匙和抽屉一一对应。 Java中的自动类型转换 在 Java 程序中，不同的基本数据类型的数据之间经常需要进行相互转换。例如： 123int score1 = 82；double score2 = score1；System.out.println(score2); // 82.0 自动类型转换需要满足特定的条件： 1、目标类型能与源类型兼容，如 double 型兼容 int 型，但是 char 型不能兼容 int 型 123int age= 19；char sex = '女'；char result = age + sex; // 报错，int类型不能自动转换为char类型 2、目标类型大于源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以了 12double avg1 = 75.5;int avg2 = avg1; // 报错，double类型不能自动转换为int类型 Java中的强制类型转换 语法：( 数据类型 ) 数值 1234double avg1 = 75.8；int avg2 = (int)avg1; // 将double类型强制转换为int类型System.out.println(avg1); // 75.8System.out.println(avg2); // 75 强制类型转换可能会造成数据的丢失，在应用时一定要慎重！ 第(3)节 Java常量的应用所谓常量，我们可以理解为是一种特殊的变量，它的值被设定后，在程序运行过程中不允许改变。 语法：final 常量名 = 值; 12final String LOVE = "KANGJIAN";final double PI = 3.14; 程序中使用常量可以提高代码的可维护性。例如，在项目开发时，我们需要指定用户的性别，此时可以定义一个常量 SEX，赋值为 “男”，在需要指定用户性别的地方直接调用此常量即可，避免了由于用户的不规范赋值导致程序出错的情况。 注意：常量名一般使用大写字符 第(4)节 如何在Java中使用注释Java 中注释有三种类型：单行注释、多行注释、文档注释 12345678910111213141516package com.eclipse;/** * 这是文档注释 * @author kangjian * @version v1.0 */public class Demo &#123; /* * 这是多行注释 * 可以包括多行内容 */ public static void main(String[] args) &#123; // 这是单行注释 System.out.println("Hello World!") &#125;&#125; 使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息： @author 标明开发该类模块的作者 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @param 对方法中某参数的说明 @return 对方法返回值的说明 @exception 对方法可能抛出的异常进行说明 第(5)节 Java运算符算数运算符 自增(++)和自减(–)既可以出现在操作数左边，也可以出现在操作数右边，但结果不同。 例1： 1234int a = 5;int b = ++a; // 出现在左边。让a先执行自增，然后将值赋给变量bSystem.out.println("a:" + a); // a:6System.out.println("b:" + b); // b:6 例2： 1234int a = 5;int b = a++; // 出现在右边。将a的值赋给变量b，然后再执行自增。System.out.println("a:" + a); // a:6System.out.println("b:" + b); // b:5 注意：自增和自减运算符只能用于操作变量，不能直接用于操作数值或常量！例如 5++ 、 8– 等写法都是错误的。 逻辑运算符 逻辑运算符 名称 举例 结果 ^ 异或 a^b 如果a与b有且只有一个为true，则返回true 运算符优先级 级别为1的优先级最高，级别11的优先级最低。 优先级 运算符 1 () 2 !、 +(正)、 -(负)、 ++、 – 3 *、 / 、% 4 +(加)、 -(减) 5 &lt;、 &lt;= 、&gt; 、&gt;= 6 ==、 != 7 ^ 8 &amp;&amp; 9 或 10 ?: 11 =、 +=、 -= 、*= 、/=、 %= 不需要死记硬背优先级。 实际开发中，一般会使用小括号辅助进行优先级管理，因为()的优先级最高。 第(6)节 Java语句Java条件语句之switch 当需要对选项进行等值判断时，使用 switch 语句更加简洁明了。 12345678910111213switch(表达式) &#123; case 值1： 执行代码块1 break； case 值2： 执行代码块2 break； case 值n： 执行代码块n break； default: 默认执行代码 &#125; 执行过程：当 switch 后表达式的值和 case 语句后的值相同时，从该位置开始向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码。 需要注意的地方： 1、 switch 后面小括号中表达式的值必须是整型或字符型； 2、 case 后面的值可以是常量数值，如 1、2；也可以是一个常量表达式，如 2+2 ；但不能是变量或带有变量的表达式，如 a * 2； 3、 case 匹配后，执行匹配块里的程序代码，如果没有遇见 break 会继续执行下一个的 case 块的内容，直到遇到 break 语句或者 switch 语句块结束； 4、可以把功能相同的case语句合并起来： 123case 1:case 2: System.out.println("do something.") 5、default块可以出现在任意位置，也可以忽略。 Java循环语句之for循环 语法： 123for(循环变量初始化；循环条件；循环变量变化) &#123; 循环操作&#125; 需要注意的地方： 1、 for 关键字后面括号中的三个表达式必须用 “;” 隔开，三个表达式都可以省略，但 “;” 不能省略。 a. 省略“循环变量初始化”，可以在 for 语句之前由赋值语句进行变量初始化操作，如: 1234int i = 0；// 循环变量i在for语句之前赋值for(;i&lt;10;i++) &#123; // 省略初始化变量 System.out.println("hello world!")&#125; b. 省略“循环条件”，可能会造成循环将一直执行下去，也就是我们常说的“死循环”现象，如: 123for(int i = 0;;i++) &#123; // 省略循环条件 System.out.println("hello world!")&#125; 在编程过程中要避免“死循环”的出现，因此，对于上面的代码可以在循环体中使用 break 强制跳出循环。 c. 省略“循环变量变化”，可以在循环体中进行循环变量的变化，如： 1234for(int i = 0;i &lt; 10;) &#123; // 省略循环条件 System.out.println("hello world!"); i++; // 在循环体中改变变量i的值&#125; 2、 for 循环变量初始化和循环变量变化部分，可以是使用 “,” 同时初始化或改变多个循环变量的值，如： 123for(int i = 1,j = 5;i&lt;=5;i++,j--)&#123; System.out.println(i+"+"+j+"="+(i+j));&#125; 代码中，初始化变量部分同时对两个变量 i 和 j 赋初值，循环变量变化部分也同时对两个变量进行变化，运行结果： 123451+5=62+4=63+3=64+2=65+1=6 3、 循环条件部分可以使用逻辑运算符组合的表达式，表示复杂判断条件，但一定注意运算的优先级，如： 123for(int 1 = 1; i&lt;10 &amp;&amp; i!=5;i++) &#123; System.out.println(i); // 必须同时满足i&lt;10并且i不等于5才会进行循环，输出i的值。&#125; Java语句循环之多重循环 循环体中包含循环语句的结构称为多重循环。三种循环语句可以自身嵌套，也可以相互嵌套，最常见的就是二重循环。在二重循环中，外层循环每执行一次，内层循环要执行一圈。 123456789101112131415161718192021222324252627while(循环条件1)&#123; 循环操作1 // 外层循环 while(循环条件2)&#123; 循环操作2 // 内层循环 &#125; &#125;do&#123; 循环操作1 do&#123; 循环操作2 &#125;while(循环条件2)； &#125;while(循环条件1)；for(;循环条件1;)&#123; 循环操作1 for(;循环条件2;)&#123; 循环操作2 &#125;&#125;while(循环条件1)&#123; 循环操作1 // 各种循环可以相互嵌套 for(;循环条件2;)&#123; 循环操作2 &#125;&#125; 例如：使用*打印长方形 123456789// 外层循环控制打印的行数for(int 1 = 1;i &lt;=3;i++)&#123; // 内层循环控制每行打印的*号数 for(int j = 1;j&lt;=8;j++) &#123; System.out.println("*") &#125; // 每行打印完毕换行 System.out.println();&#125; 执行流程：当 i = 1 时，外层循环条件成立，进入内层循环，开始打印第一行内容。此时， j 从 1 开始，循环 8 次，内层循环结束后换行，实现第一行 8 个 * 的输出。接下来返回外层循环 i 变为 2 ，准备打印下一行，依此类推，直到完成长方形的打印。 第(7)节 使用eclipse调试程序在IDE中可能出现问题的代码所在的位置添加断点，程序在运行到断点的时候会停止，我们可以在此处一步一步地执行，进行调试。 (1)添加断点:双击可能出现问题的代码 (2)点击debug按钮或右键-Debug As-Debug Configurations:eclipse会自动打开调试视图，此时你的程序会迅速执行到你设置的第一个断点 (3)利用好F6与F7/F8，配合右上方的内存变量查看器，找出问题所在 (4)调试完毕，按右上角的Java切回原来写代码的界面进行修改 第(8)节 数组数组的所有元素的类型必须是相同的。 如何使用Java中的数组 Java 中操作数组只需要四个步骤： 1、 声明数组 语法： 数据类型[ ] 数组名； 或者 数据类型 数组名[ ]； 其中，数组名可以是任意合法的变量名，如： 123int[] scores;double height[];String[] names; 2、 分配空间 简单地说，就是指定数组中最多可存储多少个元素 语法： 数组名 = new 数据类型 [ 数组长度 ]; 其中，数组长度就是数组中能存放元素的个数，如： 1scores = new int[5]; 我们也可以将上面的两个步骤合并，在声明数组的同时为它分配空间： 1int[] scores = new int[5]; 3、 赋值 分配空间后就可以向数组中放数据了，数组中元素都是通过下标来访问的，例如向 scores 数组中存放学生成绩： 1scores[0] = 89; 4、 处理数组中数据 我们可以对赋值后的数组进行操作和处理，如获取并输出数组中元素的值等。 在 Java 中还提供了另外一种直接创建数组的方式，它将声明数组、分配空间和赋值合并完成，如 1int[] scores = &#123;78,91,84,68&#125;; 它等价于： 1int[] scores = new int[]&#123;78,91,84,68&#125;; 使用Array类操作Java中的数组 Arrays 类是 Java 中提供的一个工具类，在 java.util 包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等。 Arrays 中常用的方法： 1、 排序 语法： Arrays.sort(数组名); 可以使用 sort( ) 方法实现对数组的排序，只要将数组名放在 sort( ) 方法的括号中，就可以完成对该数组的排序（按升序排列），如： 1234567891011121314import java.util.Arrays; // 使用Arrays类时必须添加此行，导入包public class HelloWorld &#123; public static void main(String[] args)&#123; // 定义一个整型数组 int[] scores = &#123;78,93,97,84,63&#125;; // 使用Arrays类的sort()方法对数组进行排序 Arrays.sort(scores); System.out.println("排序后数组中的元素的值：")； // 循环遍历数组数组中元素的值 for(int i = 0;i&lt;scores.length;i++)&#123; System.out.println(scores[i])； &#125; &#125;&#125; 2、 将数组转换为字符串 语法： Arrays.toString(数组名); 可以使用 toString( ) 方法将一个数组转换成字符串，该方法按顺序把多个数组元素连接在一起，多个元素之间使用逗号和空格隔开。 3、使用foreach操作数组 foreach 并不是 Java 中的关键字，是 for 语句的特殊简化版本，在遍历数组、集合时， foreach 更简单便捷。 语法： 123for(元素类型 元素变量：遍历对象)&#123; 执行的代码；&#125; 我们分别使用 for 和 foreach 语句来遍历数组： 123456789101112public static void main(String[] args)&#123; // 定义一个字符串数组 int[] hobbys = &#123;"足球","篮球","编程"&#125;; // 使用for循环输出数组中的元素 for(int i = 0;i&lt;hobbys.length;i++)&#123; System.out.println(hobbys[i])； &#125; // 使用foreach循环输出数组中的元素 for(String hobby : hobbys) &#123; System.out.println(hobby); &#125;&#125; Java中的二维数组 所谓二维数组，可以简单的理解为是一种“特殊”的一维数组，它的每个数组空间中保存的是一个一维数组。 那么如何使用二维数组呢，步骤如下： 1、声明数组并分配空间 1数据类型[][] 数组名 = new 数据类型[行的个数][列的个数]; 或者： 12数据类型[][] 数组名;数组名 = new 数据类型[行的个数][列的个数]; 如： 12// 定义一个两行三列的二维数组int[][] num = new int[2][3]; 2、赋值 二维数组的赋值，和一维数组类似，可以通过下标来逐个赋值，注意索引从 0 开始 1数组名[行的索引][列的索引] = 值； 也可以在声明数组的同时为其赋值： 1数据类型[][] 数组名 = &#123;&#123;值1，值2...&#125;，&#123;值11，值22...&#125;，&#123;值21，值22...&#125;&#125;; 3、处理数组 二维数组的访问和输出同一维数组一样，只是多了一个下标而已。在循环输出时，需要里面再内嵌一个循环，即使用二重循环来输出二维数组中的每一个元素。如： 123456789101112// 定义一个两行三列的二维数组并赋值int[][] num = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;// 定位行for(int i = 0;i&lt; num.length;i++) &#123; // 定位每行的元素 for(int j = 0;j&lt;num[i].length;i++)&#123; // 依次输出每个元素 System.out.print(num[i][j]); &#125; // 实现换行 System.out.println();&#125; 需要了解的：在定义二维数组时也可以只指定行的个数，然后再为每一行分别指定列的个数。如果每行的列数不同，则创建的是不规则的二维数组，如下所示： 1234567int[][] num = new int[3][]; // 定义一个三行的二维数组num[0] = new int[2]; //为第一行分配两列num[1] = new int[3]; // 为第二行分配三列num[2] = new int[4]; // 为第三行分配四列num[0][0] = 1; // 第一行第一列赋值为1num[1][1] = 2; // 第二行第二列赋值为2num[2][3] = 3; // 第三行第四列赋值为3 第(9)节 方法所谓方法，就是用来解决一类问题的代码的有序组合，是一个功能模块。 一般情况下，定义一个方法的语法是： 123访问修饰符 返回值类型 方法名(参数列表)&#123; 方法体&#125; 其中： 1、 访问修饰符：方法允许被访问的权限范围， 可以是 public、protected、private 甚至可以省略 ，其中 public 表示该方法可以被其他任何代码调用，其他几种修饰符的使用在后面章节中会详解。 2、 返回值类型：方法返回值的类型，如果方法不返回任何值，则返回值类型指定为 void ；如果方法具有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。 3、 方法名：定义的方法的名字，必须使用合法的标识符。 4、 参数列表：传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开 。 根据方法是否带参、是否带返回值，可将方法分为四类： 无参无返回值方法 无参带返回值方法 带参无返回值方法 带参带返回值方法 Java中无参无返回值方法的使用 如果方法不包含参数，且没有返回值，我们称为无参无返回值的方法。 方法的使用分两步： 第一步，定义方法： 123public void show() &#123; System.out.println("kangjian")&#125; 第二步，调用方法 当需要调用方法执行某个操作时，可以先创建类的对象，然后通过 对象名.方法名(); 来实现。 Java中无参带返回值方法的使用 如果方法不包含参数，但有返回值，我们称为无参带返回值的方法。 123456public int calcSum() &#123; int a = 5; int b = 12; int sum = a + b; return sum;&#125; 在 calSum( ) 方法中，返回值类型为 int 类型，因此在方法体中必须使用 return 返回一个整数值。 调用带返回值的方法时需要注意，由于方法执行后会返回一个结果，因此在调用带返回值方法时一般都会接收其返回值并进行处理。 注意： 1、 如果方法的返回类型为 void ，则方法中不能使用 return 返回值！ 123public void showInfo()&#123; return "Java"； // 报错&#125; 2、 方法的返回值最多只能有一个，不能返回多个值 12345public int getInfo() &#123; int score1 = 94; int score2 = 87; return score1,score2; // 报错&#125; 3、 方法返回值的类型必须兼容，例如，如果返回值类型为 int ，则不能返回 String 型值 1234public int getInfo() &#123; String name = "kangjian"; return name; // 报错&#125; Java中带参无返回值方法的使用 有时方法的执行需要依赖于某些条件，换句话说，要想通过方法完成特定的功能，需要为其提供额外的信息才行。我们可以通过在方法中加入参数列表接收外部传入的数据信息，参数可以是任意的基本类型数据或引用类型数据。 很多时候，我们把定义方法时的参数称为形参，目的是用来定义方法需要传入的参数的个数和类型；把调用方法时的参数称为实参，是传递给方法真正被处理的值。 注意： 1、调用带参方法时，必须保证实参的数量、类型、顺序与形参一一对应 123456789public class HelloWorld &#123; public static void main(String[] args)&#123; HelloWorld hello = new HelloWorld(); hello.show(25.6); // 报错，实参与形参类型不一致 &#125; public String show(String name)&#123; return "欢迎你， " + name + "!"; &#125;&#125; 2、 调用方法时，实参不需要指定数据类型，如 1hello.show("kangjian") 3、方法的参数可以是基本数据类型，如 int、double 等，也可以是引用数据类型，如 String、数组等 4、 当方法参数有多个时，多个参数间以逗号分隔。 Java中带参带返回值方法的使用 Java中方法的重载 重载定义：如果同一个类中包含了两个或两个以上方法名相同、方法参数的个数、顺序或类型不同的方法，则称为方法的重载，也可称该方法被重载了。 1234567891011121314public void show() &#123; System.out.println("kangjian");&#125;public void show(String name)&#123; System.out.println("Welcome" + name);&#125;public void show(String name,int age)&#123; System.out.println("Welcome" + name); System.out.println("age" + age);&#125;public void show(int age,String name)&#123; System.out.println("Welcome2" + name); System.out.println("age2" + age);&#125; 当调用被重载的方法时， Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行。 第(10)节 面向对象相关概念 对象：万事皆对象，客观存在的事物皆为对象 面向对象：关注/处理具体事物的信息 类：类是模子，确定对象将会拥有的特征(属性)和行为(方法)。类是对象的类型；类是具有相同属性和方法的一组对象的集合 对象的属性：对象具有的各种特征，每个对象的每个属性都拥有特定值 对象的方法：对象执行的操作 类和对象的关系与区别：类是抽象的概念，仅仅是模板；对象是一个能看得到、摸得着的具体实体。 定义类 1、类的重要性：所有java程序都以类class为组织单元 2、定义一个类的步骤： 定义类名 编写类的属性 编写类的方法 12345678910111213public class 类名 &#123; // 定义属性部分(成员变量) 属性1的类型 属性1； 属性2的类型 属性2； ... 属性n的类型 属性n; // 定义方法部分 方法1； 方法2； ... 方法m;&#125; java对象 使用对象的步骤： 创建对象： 类名 对象名 = new 类名(); 使用对象：引用对象的属性：对象名.属性；引用对象的方法：对象名.方法名() 123Telphone phone = new Telephone()phone.screen = 5 // 给screen属性赋值5phone.sendMessage(); // 调用sendMessage()方法 java中的成员变量和局部变量 定义： (1)成员变量：在类中定义，用来描述对象将要有什么。 (2)局部变量：在类的方法中定义，在方法中临时保存数据。 区别： (1)作用域不同：局部变量的作用域仅限于定义它的方法，成员变量的作用域在整个类内部都是可见的 (2)初始值不同：java会给成员变量一个初始值，不会给局部变量赋予初始值 (3)在同一个方法中，不允许有同名局部变量；在不同的方法中，可以有同名局部变量 (4)成员变量和局部变量同名时，局部变量具有更高的优先级(就近原则) java中的构造方法 (1)构造方法的定义与特征 使用new+构造方法，创建一个新的对象 构造方法是定义在java类中的一个用来初始化对象的方法 构造方法与类同名且没有返回值 当没有指定构造方法时，系统会自动添加无参的构造方法 当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法 构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法 构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值 (2)构造方法的语句格式 123public 构造方法名()&#123; // 初始化代码&#125; Java中的static使用之静态变量 大家都知道，我们可以基于一个类创建多个该类的对象，每个对象都拥有自己的成员，互相独立。然而在某些时候，我们更希望该类所有的对象共享同一个成员。此时就是 static 大显身手的时候了！！ Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问~~ 使用 static 可以修饰变量、方法和代码块。 12345678910111213141516public class HelloWorld &#123; // static修饰的变量为静态变量，所有类的对象共享hobby static String hobby = "kangjian"; public static void main(String[] args) &#123; // 静态变量可以直接使用类名来访问，无需创建类的对象 System.out.println("通过类名访问hobby："+ HelloWorld.hobby); // 创建类的对象 HelloWorld hello = new HelloWorld(); // 使用对象名来访问静态变量 System.out.println("通过对象名访问hobby：" + hello.hobby); // 使用对象名的形式修改静态变量的值 hello.hobby = "nanmei"; // 再次使用类名访问静态变量，值已被修改 System.out.println("通过类名访问hobby：" + HelloWorld.hobby) &#125;&#125; 注意：静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！ Java中的static使用之静态方法 与静态变量一样，我们也可以使用 static 修饰方法，称为静态方法或类方法。其实之前我们一直写的 main 方法就是静态方法。静态方法的使用如： 12345678910111213public class HelloWorld &#123; // 使用static关键字声明静态方法 public static void print() &#123; System.out.println("欢迎您，Hertz!") &#125; public static void main(String[] args) &#123; // 直接使用类名调用静态方法 HelloWorld.print(); // 也可以通过对象名调用，当然更推荐使用类名调用的方式 HelloWorld demo = new HelloWorld(); demo.print(); &#125;&#125; 需要注意： 1、静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。如： 123456789public class HelloWorld &#123; String name = "kangjian"; // 非静态变量name static String hobby = "nanmei"; // 静态变量hobby // 在静态方法调用非静态变量 public static void print() &#123; System.out.println("欢迎您：" + name); // 报错 不能直接调用非静态变量 System.out.println("爱好：" + hobby); // 可以直接调用静态变量 &#125;&#125; 如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。如： 12345678// 在静态方法调用非静态变量public static void print() &#123; // 创建类的对象 HelloWorld hello = new HelloWorld(); // 通过对象来实现在静态方法调用非静态变量 System.out.println("欢迎您：" + hello.name); System.out.println("爱好：" + hobby);&#125; 2、 在普通成员方法中，则可以直接访问同类的非静态变量和静态变量，如下所示： 1234567String name = "kangjian"; // 非静态变量namestatic String hobby = "nanmei"; // 静态变量hobby// 普通成员方法可以直接访问非静态变量和静态变量public void show() &#123; System.out.println("欢迎您：" + name); System.out.println("爱好：" + hobby);&#125; 3、 静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。如： 123456789101112131415// 普通成员方法public void show() &#123; System.out.println("welcome!")&#125;// 静态方法public static void print() &#123; System.out.println("欢迎!")&#125;public static void main(String[] args) &#123; // 普通成员方法必须通过对象来调用 HelloWorld hello = new HelloWorld(); hello.show(); // 可以直接调用静态方法 print();&#125; Java中的static使用之静态初始化块 Java中可以通过初始化块进行数据赋值，如： 1234567public class HelloWorld &#123; String name; // 定义一个成员变量 // 通过初始化块为成员变量赋值 &#123; name = "kangjian"; &#125;&#125; 在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。 需要特别注意：静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。 123456789101112131415161718192021222324public class HelloWorld &#123; int num1; // 声明变量num1 int num2；// 声明变量num2 static int num3； // 声明静态变量num3 public HelloWorld() &#123; // 构造方法 num1 = 91； System.out.println("通过构造方法为变量num1赋值")； &#125; &#123;// 初始化块 num2 = 74； System.out.println("通过初始化块为变量num2赋值")； &#125; static &#123; // 静态初始化块 num3 = 83； System.out.println("通过静态初始化块为静态变量num3赋值")； &#125; public static void main(String[] args) &#123; HelloWorld hello = new HelloWorld(); // 创建类的对象hello System.out.println("num1：" + hello.num1)； System.out.println("num2：" + hello.num1)； System.out.println("num3：" + num3)； HelloWorld hello2 = new HelloWorld(); // 再创建类的对象hello2 &#125;&#125; 运行结果： 12345678通过静态初始化块为静态变量num3赋值通过初始化块为变量num2赋值通过构造方法为变量num1赋值num1:91num2:74num3:83通过初始化块为变量num2赋值通过构造方法为变量num1赋值 通过输出结果，我们可以看到，程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 hello2 时并未执行静态初始化块。]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang学习笔记]]></title>
    <url>%2F2019%2F03%2F16%2FGolang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第(1)节 Go语言简介：历史背景、发展现状及语言特性软件开发的新挑战1、多核硬件架构的广泛应用 2、超大规模分布式计算集群 3、Web模式导致的前所未有的开发规模和更新速度 go语言的特点1、简单：Go 只有 25 个关键字；特别是对于一些复杂编程任务如：并发编程、内存管理、Go语言有内置的并发支持及GC 2、高效：Go是编译的静态类型语言，并且可以通过指针进行直接内存访问 3、生产力：简单清晰的依赖管理，简洁清晰的语法以及独特的接口类型 第(2)节 编写第一个Go程序开发环境构建GOPATH 1、在 1.8 版本前必须设置这个环境变量 2、1.8版本后（含1.8)如果没有设置使用默认值 在Unix上默认为$HOME/go，在Windows上默认为%USERPROFILE%/go 在Mac上GOPATH可以通过修改~/.bash_profile来设置 检查当前安装的go语言的版本：go version 构建工程目录 1、创建目录:mkdir go_learning 2、打开IDEA(需先安装go插件),进入该目录，新建src文件夹作为源码路径 3、src文件夹下新建第1章教程文件夹ch1以区分课程目录，在ch1文件夹下新建main文件夹作为package包，在main文件夹内新建hello_world.go文件 基本程序结构1、编写hello world 123456789package main // 包，表明代码所在的模块(包)import "fmt" // 引入代码依赖// 注：教程后面的示例代码将默认引入相应的包和依赖，不再重复添加//功能实现func main()&#123; fmt.Println("hello world")&#125; 2、使用命令行进入main文件夹后，执行命令：go run hello_world.go即可在命令行中输出hello world 3、如果想编译源码，执行命令：go build hello_world.go，即可在main文件夹内生成一个二进制文件 应用程序入口1、必须是main包：package main(但是目录名不一定要命名为main，这一点与Java不同) 2、必须是main方法：func main() 3、文件名不一定是main.go 退出返回值与其他主要编程语言的差异 1、Go中main函数不支持任何返回值 2、通过os.Exit来返回状态 正常退出： 1234func main()&#123; fmt.Println("hello world") os.Exit(0) // hello world&#125; 异常退出： 1234func main()&#123; fmt.Println("hello world") os.Exit(-1) // hello world exit status 4294967295&#125; 获取命令行参数与其他主要编程语言的差异 1、main函数不支持传入参数 1func main(arg []string) 2、在程序中直接通过os.Args获取命令行参数 运行命令：go run hello_world.go chao (其中chao即为命令行参数) 12345func main()&#123; if len(os.Args)&gt;1&#123; fmt.Println("hello world",os.Args[1]) // hello world chao &#125;&#125; 第(3)节 变量、常量以及与其他语言的差异编写测试程序1、源码文件以_test结尾：xxx_test.go 2、测试方法名以Test开头：func TestXXX(t *testing.T){…} 123func TestFirstTry(t *testing.T)&#123; t.Log("My first try!")&#125; 在IDEA中点击运行按钮，即可输出测试结果(快捷键：CTRL + SHIRT +F10) 测试用例：斐波纳契数列 123456789101112131415161718192021func TestFibList(t *testing.T)&#123; // 变量初始化并赋值的三种方式 //var a int = 1 //var b int = 1 // 变量赋值简写 // var ( // a int = 1 // b int = 1 // ) // 无需赋值关键字，通过使用类型推断初始化变量并赋值 a := 1 b := 1 fmt.Print(a) for i := 0;i &lt;5; i++ &#123; fmt.Print(" ",b) tmp :=a a = b b = tmp + a &#125; fmt.Println() &#125; 运行结果：1 1 2 3 5 8 变量赋值与其他主要编程语言的差异 赋值可以进行自动类型推断 在一个赋值语句中可以对多个变量进行同时赋值 12345678910111213// 交换两个变量的值func TestExchange(t *testing.T)&#123; a := 1 b := 2 // 方式1 通过中间变量 // tmp := a // a = b // b = tmp // 方式2 直接交换 a,b = b,a t.Log(a,b) // 2 1 &#125; 常量定义与其他主要编程语言的差异 快速设置连续值 1234567891011121314151617181920212223242526// 连续常量const( Monday = iota + 1 Tuesday Wednesday Thursday Friday Saturday Sunday)// 连续位的常量const( Readable = 1 &lt;&lt; iota Writable Executable)func TestConstantTry(t *testing.T)&#123; t.Log(Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday) // 1 2 3 4 5 6 7&#125;func TestConstantTry1(t *testing.T)&#123; a := 7 // 0111 t.Log(a&amp;Readable==Readable,a&amp;Writable==Writable,a&amp;Executable==Executable) // true true true&#125; 第(4)节 数据类型基本数据类型 12345678boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // alias for uint8rune // alias for int32,represents a Unicode code pointfloat32 float64complex64 complex128 类型转化 与其他主要编程语言的差异 1、Go语言不允许隐式类型转换 2、别名和原有类型也不能进行隐式类型转换 1234567//隐式类型转换func TestImplicit(t *testing.T) &#123; var a int = 1 var b int64 b = a // 报错 cannot use a (type int32) as type int64 in assignment t.Log(a,b)&#125; 12345678910type MyInt int64// 别名与原有类型隐式类型转换func TestImplicit(t *testing.T) &#123; var a int32 = 1 var b int64 b = int64(a) var c MyInt c = b // 报错 cannot use b (type int64) as type MyInt in assignment t.Log(a,b,c)&#125; 1234567//显式类型转换func TestImplicit(t *testing.T) &#123; var a int = 1 var b int64 b = int64(a) t.Log(a,b) // 1 1&#125; 12345678910type MyInt int64// 别名与原有类型显式类型转换func TestImplicit(t *testing.T) &#123; var a int32 = 1 var b int64 b = int64(a) var c MyInt c = MyInt(b) t.Log(a,b,c) // 1 1 1&#125; 类型的预定义值 1、math.MaxInt64 最大能表示的整型 2、math.MaxFloat64 最大能表示的浮点型 3、math.MaxUint32 最大能表示的32位的无符号整型 指针类型 与其他主要编程语言的差异 1、不支持指针运算 2、string是值类型，其默认的初始化值为空字符串，而不是nil 12345678// 不支持指针运算func TestPoint(t *testing.T)&#123; a:=1 aPtr := &amp;a aPtr = aPtr + 1 // 报错 invalid operation: aPtr + 1 (mismatched types *int and int) t.Log(a,aPtr) // 1 0xc00004c290 a的值以及存放a的值的地址 t.Logf("%T %T",a,aPtr) // int *int a为int型，aPtr为int型的指针&#125; 123456// string默认为空字符串func TestString(t *testing.T) &#123; var s string t.Log("*" + s + "*") // ** t.Log(len(s)) // 0&#125; 第(5)节 运算符算数运算符 go语言的算数运算符包括+、-、*、/、%、++、–。 go语言中的算数运算符与其他主流语言的算数运算符并没有太多不同，唯一需要注意的是go语言支持后置++和后置–，但是不支持前置++和前置–，即++a,–a这种写法是错误的。 比较运算符 go语言的比较运算符包括==、!=、&gt;、&lt;、&gt;=、&lt;= 从语义上来说，go语言与其他主流语言的比较运算符是没有差别的。但是对于某些类型是不是能够比较和比较的结果如何，go语言有特殊规定。 a、用==比较数组 相同维数且含有相同个数元素的数组才可以比较 每个元素都相同的才相等 123456789func TestCompareArray(t *testing.T)&#123; a := [...]int&#123;1,2,3,4&#125; b := [...]int&#123;1,3,4,5&#125; c := [...]int&#123;1,2,3,4,5&#125; d := [...]int&#123;1,2,3,4&#125; t.Log(a==b) // false t.Log(a==c) // invalid operation: a == c (mismatched types [4]int and [5]int)数组长度不同进行比较，会导致编译错误 t.Log(a==d) // true&#125; 逻辑运算符 go语言的逻辑运算符包括&amp;&amp;、||、! 位运算符 go语言的位预算符与其他主流语言的位运算符没有太多差别。其差异主要是go语言多出来一个运算符： &amp;^ 按位置零运算符 意为：对于左右两个操作数来说，只要是右边的操作数的位上为1，那么无论左边对应的位上是0还是1，其结果都是0. 12341 &amp;^ 0 -- 11 &amp;^ 1 -- 00 &amp;^ 1 -- 00 &amp;^ 0 -- 0 1234567891011const( Readable = 1 &lt;&lt; iota Writable Executable)func TestBitClear(t *testing.T)&#123; a := 7 // 0111 a = a&amp;^Readable t.Log(a&amp;Readable==Readable,a&amp;Writable==Writable,a&amp;Executable==Executable) // false true true&#125; 第(6)节 条件和循环循环 与其他主要编程语言的差异 Go语言仅支持循环关键字for 123456789101112131415161718// 用for表示while条件循环// while (n&lt;5)func TestWhileLoop1(t *testing.T) &#123; n := 0 for n &lt; 5 &#123; t.Log(n) // 0 1 2 3 4 n++ &#125;&#125;// 无线循环// while(true)func TestWhileLoop2(t *testing.T) &#123; n := 0 for &#123; ... &#125;&#125; if条件 12345678910111213if condition &#123; // code to be executed if condition is true&#125; else &#123; // code to be executed if condition is false&#125;if condition-1 &#123; // code to be executed if conditon-1 is true&#125; else if condition-2 &#123; // code to be executed if condition-2 is true&#125; else &#123; // code to be executed if both conditon-1 and condition2 is are false&#125; 与其他主要编程语言的差异 1、condition表达式结果必须为布尔值 2、支持变量赋值： 1234// 伪代码if var declaration; conditon &#123; // code to be executed if condition is true&#125; 1234567// 测试用例func TestIfMultiSec(t *testing.T) &#123; if a := 1 == 1; a &#123; t.Log("1==1") // 1==1 &#125;&#125; switch条件 与其他主要编程语言的差异：1、条件表达式不限制为常量或者整数； 2、单个case中，可以出现多个结果选项，使用逗号分隔； 3、与C语言等规则相反，Go语言不需要用break来明确退出一个case； 4、可以不设定switch之后的条件表达式，在此种情况下，整个switch结构与多个if…else…的逻辑作用等同 123456789101112131415161718192021222324252627func TestSwitchMultiCase(t *testing.T) &#123; for i := 0;i&lt;5;i++ &#123; switch i &#123; case 0,2: // case支持多个结果选项，只要命中了其中一项，就会执行该项的逻辑 t.Log("even") case 1,3: t.Log("odd") default: t.Log("it is not 0-3") &#125; &#125;&#125;// 通过switch简化复杂的if...else...// 不加break也可以正常运行，因为go语言默认有break，在一个case被命中之后，自动中断结果func TestSwitchCaseCondition(t *testing.T) &#123; for i := 0; i&lt;5;i++&#123; switch &#123; case i%2 == 0: t.Log("even") case i%2 == 1: t.Log("odd") default: t.Log("unknown") &#125; &#125;&#125; TestSwitchMultiCase输出结果为： 12345evenoddevenoddit is not 0-3 TestSwitchCaseCondition输出结果为： 12345evenoddevenoddeven 第(7)节 数组和切片数组的声明 1234var a [3]int //声明并初始化为默认零值a[0] = 1 // 赋值b := [3]int&#123;1,2,3&#125; // 声明同时初始化c :=[2][2]int&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125; // 多维数组初始化 声明及遍历用例： 12345678910111213141516171819202122func TestArrayInit(t *testing.T) &#123; var arr [3]int arr1 := [4]int&#123;1,2,3,4&#125; // 在声明的同时完成初始化操作 arr3 := [...]int&#123;1,3,4,5&#125; // 当不指定元素个数时，可以使用...来自动初始化元素个数的长度 arr[1] = 5 // 赋值 t.Log(arr[1],arr[2]) // 0 0 声明数组后被默认初始化为0 t.Log(arr1,arr3) // [1,2,3,4] [1,3,4,5]&#125;// 数组的遍历，有两种方法func TestArrayTravel1(t *testing.T) &#123; arr3 := [...]int&#123;1,3,4,5&#125; for i := 0;i &lt; len(arr3);i++ &#123; t.Log(arr3[i]) // 1,3,4,5 &#125;&#125;// idx为数组下标，e为数组元素func TestArrayTravel2(t *testing.T) &#123; arr3 := [...]int&#123;1,3,4,5&#125; for idx,e := range arr3 &#123; t.Log(idx,e) // 0 1 ; 1 3 ; 2 4 &#125;&#125; 1234567891011121314// go语言是一个有严格编程约束的语言，当我们遍历数组，只想打印数组元素而不打印数组下标时，如下是无法编译通过的func TestArrayTravel2(t *testing.T) &#123; arr3 := [...]int&#123;1,3,4,5&#125; for idx,e := range arr3 &#123; t.Log(e) // idx declared and not used &#125;&#125;// 为了解决这个问题，我们使用_做占位符,代表不需要打印的值的结果，即可正常编译func TestArrayTravel3(t *testing.T) &#123; arr3 := [...]int&#123;1,3,4,5&#125; for _,e := range arr3 &#123; t.Log(e) // 1,3,4,5 &#125;&#125; 数组截取 a[开始索引(包含):结束索引(不包含)] 1234567891011func TestArraySection(t *testing.T) &#123; arr3 := [...]int&#123;1,2,3,4,5&#125; arr3_sec1 := arr3[:3] arr3_sec2 := arr3[3:] arr3_sec3 := arr3[:] arr3_sec4 := arr3[-1:] t.Log(arr3_sec1) // [1,2,3] t.Log(arr3_sec2) //[4,5] t.Log(arr3_sec3) // [1,2,3,4,5] 不填索引值则选中所有元素 t.Log(arr3_sec4) // 编译错误，go不支持负数index&#125;]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（2）：ES6带来的重大特性]]></title>
    <url>%2F2019%2F03%2F10%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%EF%BC%9AES6%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%87%8D%E5%A4%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[ECMAScript 2015，即ES6， 是 ECMAScript 标准的基础版本，该版本距离上个版本 ECMAScript 5.1 发布有四年之久，也是从这个版本开始将版本改为以年命名。所以它不应该叫做 ES6（尽管每个人都这么叫），而是 ES2015。 ES5 从 1999 年到2009年花费了十年时间完善，尽管对于这个语言来讲，它也是一个重要版本，但是太长时间过去了，已经不值得我们讨论 ES5 之前的代码是如何工作的。 从 ES5.1 到 ES6，JavaScript 语言有了重要的新特性以及在更好的实践中的关键更新。要了解 ES2015 的基本功能，请参阅规范文档的250页到600页。 ES2015 中的重要更新包括： 箭头函数 Promises 生成器函数(Generators) let 和 const 类(Classes) 模块 多行字符串 模板字面量 默认参数 扩展运算符 解构赋值 增强的对象字面量 for..of 循环 Map 和 Set 在这篇指南中，我将在每个章节中专门介绍它们。让我们开始吧！ 箭头函数箭头函数改变了大多数 JavaScript 代码的书写习惯和工作方式。 从视觉上来讲，它更简单了，因此也很受欢迎，比如： 123const foo = function foo() &#123; // ...&#125; 变成： 123const foo = () =&gt; &#123; // ...&#125; 如果这个函数体只有一行，可以是这样： 1const foo = () =&gt; doSomething() 如果只有一个参数，可以这样写： 1const foo = param =&gt; doSomething(param) 这不是一个破坏性的改变，因为常规函数可以继续像以前一样正常工作。 新的 this 作用域箭头函数的 this 作用域继承自执行上下文(the context)。 常规函数中，this 总是指最近的函数。然而在箭头函数中这个问题不存在了，你不再需要重写一遍 var that = this。 PromisesPromises 帮我们解决了著名的“回调地狱”问题，虽然它引入了更复杂的问题（已经可以在 ES2017 中通过更高级的构造函数 asnyc 解决 ）。 在 ES2015 之前，JavaScript 开发者就可以通过使用不同的库（jQuery，q，deferred.js，vow…）实现类似 Promises 的功能。该标准制定了更通用的方法。 通过使用 promises，你可以重构以下代码： 123456setTimeout(function() &#123; console.log('I promised to run after 1s') setTimeout(function() &#123; console.log('I promised to run after 2s') &#125;, 1000)&#125;, 1000) 等同于： 12345678const wait = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000)&#125;)wait().then(() =&gt; &#123; console.log('I promised to run after 1s') return wait()&#125;).then(() =&gt; console.log('I promised to run after 2s')) 生成器函数(Generators)生成器是一种特殊的函数，能够暂停输出，稍后恢复，而且允许其它代码在此期间运行。 代码本身决定了它必须等待，以便让其它代码“按照队列”顺序运行，并保持 “当它正在等待的东西” 完成时恢复其操作的权利。所有的这些都通过一个简单的关键字 yield 来完成。当一个生成器包含该关键字，代码将暂停执行。生成器可以包含很多个 yield 关键字，因此可以暂停很多次，并且通过 *function 关键字标识，不要与 C 语言，C++ 或者 Go 等底层语言的指针反向引用操作符混淆。 生成器在JavaScript中开启了全新的编程范例，比如： 生成器运行时的双向通信 持久的 while 循环，不会冻结程序 这里有个例子可以解释生成器是如何工作的： 12345function *calculator(input) &#123; var doubleThat = 2 * (yield (input / 2)) var another = yield (doubleThat) return (input * doubleThat * another)&#125; 我们用下面的代码初始化这个 Generator(生成器)函数： 1const calc = calculator(10) 然后我们在生成器上启动迭代器： 1calc.next() 第一次迭代，代码返回了 this 对象： 1234&#123; done: false value: 5&#125; 发生了什么呢？函数开始运行时，input = 10 作为参数传入了生成器的构造函数中，直到遇到 yield，返回了 yeild 的内容：input / 2 = 5。所以我们得到了一个值为 5，并且告诉我们迭代没有完成（仅仅是函数暂停了）。 在第二次迭代中，我们传入 7： 1calc.next(7) 然后我们会得到： 1234&#123; done: false value: 14&#125; 第二个 next 方法带有参数 7，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 doubleThat 所在的表达式接收。 注意：你可能会认为 input / 2 是这个参数，但是它仅仅是第一次迭代的返回值，这次我们跳过了这一步，使用新的输入值 7 和 2 相乘。 我们继续第二次迭代，它返回了 doubleThat，值为 14。 在下一个和最后一个迭代，我们传入100： 1calc.next(100) 返回： 1234&#123; done: true value: 14000&#125; 整个迭代结束（没有 yeild 关键字了），我们得到了 (input * doubleThat * another) 的值：10 * 14 * 100。 let 和 constvar 是传统的函数作用域。 let 是新的声明变量的方法，拥有块级作用域。这意味着在 for 循环中，if 语句内或者普通块中使用 let 声明的变量不会“逃出”所在的块，而 var变量则会被提升。 const 和 let 相似，但是不可更改。 展望 JavaScript 的发展，var 声明会逐渐消失，只剩下 let 和 const。 更特别的是，由于不可变的特性，const 在今天已经出人意料的被广泛使用。 类(Classes)传统上，JavaScript 是唯一一个基于原型继承的主流语言。从基于类的语言转向使用 JavaScript 的程序员会觉得困惑，但是 ES2015 引入了 classes，作为 JavaScript 内部运行的语法糖，它改变了我们编写 JavaScript 程序的方式。 现在，继承变得非常简单，和其他面向对象的编程语言类似： 123456789101112131415class Person &#123; constructor(name) &#123; this.name = name &#125; hello() &#123; return 'Hello, I am ' + this.name + '.' &#125;&#125;class Actor extends Person &#123; hello() &#123; return super.hello() + ' I am an actor.' &#125;&#125;var tomCruise = new Actor('Tom Cruise')tomCruise.hello() 上面的代码会打印出：“Hello, I am Tom Cruise. I am an actor.” Classes 没有显式声明类变量，你必须在构造函数（constructor）中初始化所有变量。 ConstructorClasses 拥有一个特殊的方法 constructor，在使用 new 实例化类时被调用。 Super可以使用 super() 引用父类。 Getters 和 Setters可以像这样声明一个 getter 属性： 12345class Person &#123; get fullName() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;` &#125;&#125; 用同样的方式声明 setter 属性： 12345class Person &#123; set age(years) &#123; this.theAge = years &#125;&#125; 模块化ES2015 之前，至少有三个主要的模块化标准，这分裂了整个社区： AMD RequireJS CommonJS ES2015 制定了统一的模块化标准。 导入模块通过 import ... from ... 导入模块： 1234import * from 'mymodule'import React from 'react'import &#123; React, Component &#125; from 'react'import React as MyLibrary from 'react' 导出模块你可以使用关键字 export 将编写的模块内容导出到其它模块里： 12export var foo = 2export function bar() &#123; /* ... */ &#125; 模板字符串模板字符串是创建字符串的新方法： 1const aString = `A string` 使用 ${a_variable} 语法可以方便地将表达式的值插到字符串里： 12const var = 'test'const string = `something $&#123;var&#125;` //something test 你还可以执行更复杂的表达式，像这样： 12const string = `something $&#123;1 + 2 + 3&#125;`const string2 = `something $&#123;foo() ? 'x' : 'y' &#125;` 字符串可以是多行的： 1234const string3 = `Heythisstringis awesome!` 对比一下 ES2015 之前的多行字符串的写法： 123var str = 'One\n' +'Two\n' +'Three' 默认参数函数现在支持使用默认参数值： 12const foo = function(index = 0, testing = true) &#123; /* ... */ &#125;foo() 扩展运算符你可以通过扩展运算符 ... 扩展数组，对象或者是字符串。 让我们用数组举个例子： 1const a = [1, 2, 3] 你可以这样创建一个新数组： 1const b = [...a, 4, 5, 6] 你可以复制一个数组： 1const c = [...a] 这对对象同样奏效，这样复制一个对象： 1const newObj = &#123; ...oldObj &#125; 对于字符串，扩展运算符会生成一个对应每个字符的数组： 12const hey = 'hey'const arrayized = [...hey] // ['h', 'e', 'y'] 这个运算符非常有用。最重要的就是可以以一种十分简单的方式为一个函数传递数组形式的参数： 123const f = (foo, bar) =&gt; &#123;&#125;const a = [1, 2]f(...a) 以前你可以使用 f.apply(null, a) 达到同样的效果，但是它可读性不太好。 解构赋值给定一个对象，你可以只提取一些值并将它们放入命名变量中： 123456789const person = &#123; firstName: 'Tom', lastName: 'Cruise', actor: true, age: 54, //made up&#125;const &#123;firstName: name, age&#125; = personconsole.log(name) // "Tom"console.log(age) // 54 name 和 age 包含这些值。 这个语法也可以用在数组中： 12const a = [1,2,3,4,5][first, second, , , fifth] = a 加强的对象字面量ES2015 中对象字面量更加强大。 声明变量的简单语法以前： 1234const something = 'y'const x = &#123; something: something&#125; 现在你可以： 12345const something = 'y'const x = &#123; something&#125;console.log(x) // &#123;something: "y"&#125; 原型可以像这样为变量指定原型： 1234const anObject = &#123; y: 'y' &#125;const x = &#123; __proto__: anObject&#125; super()12345678const anObject = &#123; y: 'y', test: () =&gt; 'zoo' &#125;const x = &#123; __proto__: anObject, test() &#123; return super.test() + 'x' &#125;&#125;x.test() //zoox 动态属性1234const x = &#123; ['a' + '_' + 'b']: 'z'&#125;x.a_b //z for-of 循环2009年的 ES5 引入了 forEach() 循环。虽然很好，但是不能像 for 那样中途跳出循环(比如使用 break 语句或使用 return 语句)。 ES2015 引入了 for-of 循环，结合了 forEach 的简洁和跳出循环的能力。 12345678//iterate over the valuefor (const v of ['a', 'b', 'c']) &#123; console.log(v); // a b c&#125;//get the index as well, using `entries()`for (const [i, v] of ['a', 'b', 'c'].entries()) &#123; console.log(i, v); // 0 "a" ;1 "b"; 2 "c"&#125; Map 和 SetMap 和 Set（以及各自的弱引用类型 WeakMap 和 WeakSet）是官方实现的两种非常流行的数据结构（稍后介绍）。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册系列（1）：ECMASCRIPT的发展史与现状]]></title>
    <url>%2F2019%2F03%2F10%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9AECMASCRIPT%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E4%B8%8E%E7%8E%B0%E7%8A%B6%2F</url>
    <content type="text"><![CDATA[每当你阅读有关JavaScript的内容时，你都会不可避免地看到以下这些术语： ES3 ES5 ES6 ES7 ES8 ES2015 ES2016 ES2017 ECMA2017 ECMA2016 ECMA2015 它们是什么意思？它们都是指一个名为ECMAScript的JavaScript标准。ECMAScript是JavaScript实现所基于的标准，通常被简称为ES。除了JavaScript，其他实现了ECMA标准的语言还包括： ActionScript（Flash 脚本语言），自从官方决定从 2020 年起不再维护 Flash 该语言便不再流行。 JScript（微软实现的脚本语言），一开始只有 Netscape 支持 JavaScript，随着浏览器大战愈演愈烈，微软便实现了仅 IE 浏览器支持的语言版本。 但是毫无疑问，JavaScript是最为流行和使用最为广泛的ES实现。 为什么是这么一个奇怪的名字？Ecma International是瑞士标准协会，负责制定国际标准。 JavaScript 被创建后，它被 Netscape 和 Sun Microsystems 提交到 Ecma，Ecma将之命名为 ECMA-262，又叫做 ECMAScript。根据维基百科的解释，Netscapte 和 Sun Microsystems（Java 制造商）联合发布的新闻稿可能会帮助我们了解如此命名的原因，其中可能涉及到微软在该委员会中的法律和品牌问题。 IE9之后，微软停止在浏览器中将ES实现称为JScript，并开始将其称为JavaScript（至少，我再也找不到对JScript的引用了）。 所以，从201x年起，唯一一个支持 ECMAScript 标准的流行语言就只有 JavaScript 了。 ECMAScript最新版本ECMAScript最新版本是ES2018，即ES9，发布于2018年6月。 何时发布下一个版本？通常，JavaScript 会在每年夏天发布标准版本，所以我们可以在 2019 年夏天见到 ECMAScript 2019（即 ES2019 或者 ES10），但这一切只是推测。 何为TC39?TC39 是 JavaScript 发展委员会。 TC39 成员涉及 JavaScript 和浏览器供应商，包括火狐，谷歌，Facebook，Apple，微软，英特尔，PayPal，SalesForce 等等。 每一个标准版本的发布都必须通过不同阶段的提案。 ES版本我发现 ES 版本有时候通过版本号指代，有时候通过年份指代，这让人困惑。 在 ES2015 之前，ECMAScript 标准通常按照版本号命名，所以 ES5 是2009年更新的 ECMAScript 标准官方命名。 为什么会这样？在 ES2015 发布时，名字从 ES6 变成了 ES2015，但是为时已晚，人们仍然习惯性地称之为 ES6，社区也没有抛弃这个名字 - 大家仍然按照版本号的方式指代 ES 版本。 这个表格可以帮助理清思路： 版本 官方名称 发布日期 ES9 ES2018 2018年6月 ES8 ES2017 2017年6月 ES7 ES2016 2016年6月 ES6 ES2015 2015年6月 ES5.1 ES5.1 2011年6月 ES5 ES5 2009年12月 ES4 ES4 废弃 ES3 ES3 1999年12月 ES2 ES2 1998年6月 ES1 ES1 1997年6月 ES.Next 始终指 JavaScript 未来版本。在撰写本文时，ES9 已经发布，ES.Next 是 ES10。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vendor.js和app.js文件过大问题处理方案]]></title>
    <url>%2F2019%2F03%2F09%2Fvendor-js%E5%92%8Capp-js%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[背景webpack的出现，极大地简化了前端开发的复杂度：作为一种模块化的解决方案，它可以将项目当做一个整体，通过一个给定的主文件（如index.js）,进而从这个主文件中找到项目的所有依赖文件，使用loaders来处理它们，最后打包成浏览器可识别的JavaScript文件。 但是在实际的开发中，我们经常发现由于npm run build命令默认把dependencies中的依赖统一打包，导致打包后的vendor.js文件过大，出现首屏加载过于缓慢的问题，严重影响到了上线后的项目性能。如何处理它们呢？ 分析要解决这个问题，需要前后端一齐发力：后端做缓存，前端则需要做如下几项工作： A.去除不必要的插件，删除不必要的代码 B.分离业务代码和第三方库 C.按需加载 具体实施去除不必要的插件，删除不必要的代码比如babel-polyfill、vuex、less等（当然，我指的是当前还没有必要使用的情况。如果需要使用，自然不能删除），还有一些开发过程中用于测试的代码等等，这种是釜底抽薪式的解决方案——减少依赖，自然打包文件就变小了；删除无用代码，可以减少解析引擎的工作量。 开启gzip压缩开启gzip压缩，对打包优化有很大帮助。方法步骤如下： a.安装插件 compression-webpack-plugin 1npm install --save-dev compression-webpack-plugin b.设置config/index.js中productionGzip: true 1productionGzip: true 注意，此时如果compression-webpack-plugin版本过高，可能会压缩失败。解决方法是，安装1.1.12版本，同时将webpack.prod.conf.js中的asset字段名改为filename。 npm run build执行后会发现每个js和css文件会压缩一个gz后缀的文件夹，浏览器如果支持g-zip 会自动查找有没有gz文件，找到了就加载gz然后本地解压执行。 12345678910111213141516if (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; filename: '[path].gz[query]', // 将asset改为filename algorithm: 'gzip', test: new RegExp( '\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 &#125;) )&#125; 打包的时候不生成map文件webpack最终打包的文件中会出现一些map文件，map文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。有了map文件，就可以准确地输出错误信息。为了减小打包体积，我们可以设置不生成map文件： 设置config/index.js中productionSourceMap: false 分离vendorapp.js 包含了我们的第三方库 vue 和 axios ，以及业务代码 src ，我们可以将之分离开。 最简单方法就是：加一个 entry： 1234567// webpack.config.jsmodule.exports = &#123; entry: &#123; app: './src/main.js', vendor: ['vue', 'axios'], &#125;,&#125; 路由懒加载vue-router官网原文：当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 具体的方案如下： 原来的路由配置文件index.js 1import index from '@/components/home/index' 更改后的路由配置文件index.js 1const index = () =&gt; import('@/components/home/index') 做了路由懒加载后，我们可以看到app.js这个文件明显减小的同时多出了几个js文件，那是我们的另外几个路由页面的js文件。这些文件会在我们需要的时候，通过异步的方式加载进来，因此它们不会为首屏的加载增加负担。 组件懒加载组件懒加载的套路和路由懒加载是一样的，代码如下： 原来的组件引入方法 1import myHeader from '../header/myHeader' 更改后的组件引入方法 1const myheader = () =&gt; import('../header/myHeader') 此时，工程打包后我们可以看到app.js又变小了，同时又多出了几个js，这些js是自定义组件的js，我们可以用异步加载的方式加载进来的。 当然，组件懒加载有提升加载速度的一面，也有不总是“真香”的一面：如果网络慢，那么就有可能会出现白屏问题。这个时候就要做出判断了：哪些组件适合做懒加载，哪些不适合做懒加载。通常的建议如下： 对于路由页面，最好进行懒加载; 对于路由页面中的各个组件实行按需进行懒加载; 如果组件不大并且使用不多，可直接在路由页面中导入，若组件较大或者使用比较频繁，建议使用组件懒加载 使用CDN导入CDN的工作原理不多做介绍，个人认为使用CDN导入工具和库可以作为一种选项，但并不能保证100%的安全：谁知道这些服务会在什么时候突然挂掉呢，即使是那些号称最为稳定的服务？ 使用CDN导入的基本方法如下： a.在项目根目录index.html使用cdn节点导入 123456789&lt;div id="app"&gt;&lt;/div&gt;&lt;!-- 先引入 Vue --&gt;&lt;!--开发环境--&gt;&lt;script src="https://cdn.bootcss.com/vue/2.5.3/vue.js"&gt;&lt;/script&gt;&lt;!--生产环境--&gt;&lt;!--&lt;script src="https://cdn.bootcss.com/vue/2.5.3/vue.min.js"&gt;&lt;/script&gt;--&gt;&lt;!-- 引入组件库 --&gt;&lt;script src="https://cdn.bootcss.com/axios/0.17.1/axios.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/element-ui/1.4.10/index.js"&gt;&lt;/script&gt; b.项目根目录下build/webpack.base.config.js中添加externals 12345678// externals中的key是后面需要require的名字，value是第三方库暴露出来的方法名module.exports = &#123; externals: &#123; 'vue': 'Vue', 'axios': 'axios', 'element-ui': 'Element' &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目IE浏览器兼容性问题]]></title>
    <url>%2F2019%2F03%2F09%2Fvue%E9%A1%B9%E7%9B%AEIE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景介绍vue框架的核心思想——数据的双向绑定，是建立在从ES5才支持的对象方法Object.defineProperty()之上的，由此决定了vue天生不支持IE9以下浏览器，即针对IE浏览器版本，至少需要IE9浏览器才能正常运行vue项目。 通常来说，项目都需要对IE浏览器进行一定程度上的兼容，但同时即便是版本最高的IE11，也无法完全兼容ES6语法，更遑论IE9浏览器。在具体的项目实践中，笔者又发现，虽然vue核心组件都能正常支持IE9，但围绕vue生态圈打造的某些开发工具仍然无法100%支持IE9，再加上vue在IE9上低概率出现的诡异的组件变形问题，使得笔者最终决定将IE浏览器最低兼容到IE10。 技术选用幸运的是，JavaScript社区也在蓬勃发展，针对IE浏览器兼容这个开发痛点，不断地有人给出解决方案。接下来，笔者将列出解决IE浏览器兼容性问题需要使用到的相关技术。 A.babel-polyfill作用：将 es6 的代码翻译成低版本浏览器可以识别的 es5 代码； 安装：npm install –save babel-polyfill 使用： 在main.js最前面引入： 1import 'babel-polyfill'; 在webpack.base.conf.js中修改如下： 123entry: &#123; app:['babel-polyfill','./src/main.js'] &#125; 在 babel 配置文件.babelrc中修改如下： 作用是根据浏览器版本的支持，将 polyfill 需求拆分引入，仅引入有浏览器不支持的polyfill 1"useBuiltIns": "entry" B.header标签设置（非必须）作用： 强制ie浏览器以最新的edge引擎渲染页面，或自动激活双核浏览器的Chrome极速模式 使用： 在index.html的header标签中引入 1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; C.es6-promise作用：如果你用到了 axios对 promise进行兼容，可以只用 es6-promise 安装：npm install es6-promise –save 使用： 在main.js中加入如下内容： 12import promise from 'es6-promise'promise.polyfill() 具体实现 在index.vue中加入浏览器判断逻辑并执行该逻辑 123456789101112131415161718mounted () &#123; this.ieVersion()&#125;,methods: &#123; var userAgent = navigator.userAgent var isOpera = userAgent.indexOf('Opera') &gt; -1 var isIE = userAgent.indexOf('compatible') &gt; -1 &amp;&amp; userAgent.indexOf('MSIE') &gt; -1 &amp;&amp; !isOpera if (isIE) &#123; var reIE = new RegExp('MSIE (\\d+\\.\\d+);') reIE.test(userAgent) var fIEVersion = parseFloat(RegExp['$1']) if (fIEVersion &lt; 10) &#123; this.$alert('系统检测到您的IE浏览器版本过低，部分功能无法正常使用，推荐使用&lt;a style="color:#647eef" target="_blank" href="https://www.baidu.com/s?ie=UTF-8&amp;wd=Chrome"&gt;Chrome浏览器&lt;/a&gt;、&lt;a style="color:#647eef" target="_blank" href="https://www.baidu.com/s?ie=UTF-8&amp;wd=Firefox"&gt;Firefox浏览器&lt;/a&gt;或IE10及以上版本以获取最佳体验！', '温馨提示', &#123; dangerouslyUseHTMLString: true &#125;) &#125; &#125; &#125; 提升系统性能（关于性能问题，可另开一文详解）项目上线后，发现打包后的vendor.js和app.js体积过大，严重影响了系统的运行速度，为了解决这个问题，决定删除对babel-polyfill的依赖，使用MDN提供的poly-fill。 在index.html中引入对String对象的includes方法的es5版本实现(具体添加什么可视实际情况而定) 12345678910111213if (!String.prototype.includes) &#123; String.prototype.includes = function(search, start) &#123; 'use strict'; if (typeof start !== 'number') &#123; start = 0; &#125; if (start + search.length &gt; this.length) &#123; return false; &#125; else &#123; return this.indexOf(search, start) !== -1; &#125; &#125;; &#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用try...catch处理代码中的错误]]></title>
    <url>%2F2019%2F03%2F03%2F%E4%BD%BF%E7%94%A8try-catch%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[try…catch 语句是什么？try…catch 可以测试代码中的错误。try 部分包含需要运行的代码，而 catch 部分包含错误发生时运行的代码。 try…catch语法123456try &#123; //在此运行代码&#125;catch(err)&#123; //在此处理错误&#125; 运行流程：try{…}包含块中的代码有错误，则运行catch(err){…}内的代码，否则不运行catch(err){…}内的代码。 try…catch案例1234567var array = null;try &#123; document.write(array[0]);&#125; catch(err) &#123; document.writeln("Error name: " + err.name + ""); document.writeln("Error message: " + err.message);&#125; try…catch…finally 语句提供了一种方法来处理可能发生在给定代码块中的某些或全部错误，同时仍保持代码的运行。如果发生了程序员没有处理的错误，JS只给用户提供它的普通错误信息，就好象没有错误处理一样。 try…catch…finally语法123456789try &#123; tryStatements&#125; catch(exception)&#123; catchStatements&#125; finally &#123; finallyStatements&#125; 参数 tryStatement 必选项，可能发生错误的语句。 exception 必选项，任何变量名。exception的初始化值是扔出的错误的值。 catchStatement 可选项。处理在相关联的tryStatement中发生的错误的语句。 finallyStatements 可选项。在所有其他过程发生之后无条件执行的语句。 try…catch…finally案例12345678910var array = null;try &#123; document.write(array[0]);&#125; catch(err) &#123; document.writeln("Error name: " + err.name + ""); document.writeln("Error message: " + err.message);&#125;finally&#123; alert("object is null");&#125; 程序执行过程 array[0]的时候由于没有创建array数组,array是个空对象，程序中调用array[0]就会产生object is null的异常 catch(err)语句捕获到这个异常通过err.name打印了错误类型,err.message打印了错误的详细信息. finally类似于java的finally,无论有无异常都会执行. 现总结Error.name的六种值对应的信息 EvalError：eval()的使用与定义不一致 RangeError：数值越界 ReferenceError：非法或不能识别的引用数值 SyntaxError：发生语法解析错误 TypeError：操作数类型错误 URIError：URI处理函数使用不当 转自 https://www.jianshu.com/p/5874036e6710]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将vue-resource改为axios]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%B0%86vue-resource%E6%94%B9%E4%B8%BAaxios%2F</url>
    <content type="text"><![CDATA[背景接手的项目之前的http请求库用的是vue-resource,在一般使用过程中没有什么问题，但想要做ie浏览器兼容的时候却出现了很多意想不到的问题。其实vue-resource官方早已经停止维护，所以就想花点时间，改为使用官方推荐的axios库。 实施步骤安装axiosnpm安装就不多说了，需要注意的是在main.js里面需要添加一些配置： 123import axios from 'axios'axios.defaults.withCredentials = trueVue.prototype.$http = axios 使用axios完成axios的安装和配置之后，就可以在各组件内使用了。 因为我在vue-resource中使用了Vue.http.options.emulateJSON = true;，这种请求在发送头信息时会将Content-Type改为application/x-www-form-urlencoded。为了在使用axios时达到相同的效果，需要在组件内先引入qs 1234567import qs from 'qs'login () &#123; this.$http.post(process.env.BASE_URL + '/user/login', qs.stringify(this.login_data)).then(res =&gt; &#123; console.log(response.data) //这个打印出来的就是返回的结果 &#125;)&#125; post请求必须将发送的请求参数使用qs.stringify进行包裹，用以解决axios发送x-www-form-urlencoded的需求 qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接 同时需要注意，在vue-resource中正文是response.body，而在axios中正文则是response.data]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何获取访问者的ip地址并写入header]]></title>
    <url>%2F2019%2F01%2F20%2F%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%AE%BF%E9%97%AE%E8%80%85%E7%9A%84ip%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%86%99%E5%85%A5header%2F</url>
    <content type="text"><![CDATA[背景最近的一个项目，新增了一项需求：获取访问者的ip地址，并将ip地址写到header中，后端获取ip地址后写入日志进行记录。 由于js本身不具备获取访问者ip地址的能力，所以必须借助于第三方服务才能达到这个目的。网上查找了相关资料，最终确定使用搜狐的ip接口服务（http://pv.sohu.com/cityjson?ie=utf-8）。 解决方案使用该服务，首先遇到的就是跨域问题，vue项目中解决跨域问题的方法如下： config/index.js 123456789proxyTable: &#123; '/api': &#123; target: 'http://pv.sohu.com/', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125;&#125; 解决了跨域问题之后，就可以进行http拦截了： main.js 访问接口，获取ip地址后，进行拦截并写入header中 123456789101112131415161718Vue.http.get('/api/cityjson?ie=utf-8').then((res) =&gt; &#123; if (res) &#123; console.log(res.data) // 获取需要的ip地址 let ip = JSON.parse(res.data.replace('var returnCitySN = ', '').replace(';', '')).cip Vue.http.interceptors.push((request, next) =&gt; &#123; request.credentials = true // 将ip地址写入header中 request.headers.set('ip', ip) next((response) =&gt; &#123; if (response.body.code === '403') &#123; // delCookie('account') // router.push('/') &#125; &#125;) &#125;) &#125;&#125;) 后续：本地环境测试没有问题，但是部署上线的时候，该功能出现了问题：返回的数据变成了一个HTML文档（具体原因未知），所以也就无法再解析出IP地址。最后，还是通过后端埋点监控，拿到IP实现了功能。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发中遇到的杂七杂八问题记录]]></title>
    <url>%2F2019%2F01%2F13%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[html跳转，js不执行问题单页面复杂应用做多了，突然遇到简单的切图问题反而懵逼了，O(∩_∩)O。123456789&lt;header&gt; &lt;div class="clearfix fixwidth"&gt; &lt;div class="logo left"&gt; &lt;a href=""&gt; &lt;img src="img/logo.png" id="logoImg"/&gt; &lt;/a&gt; &lt;/div&gt; &lt;ul class="right nav-top"&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/header&gt; 总共有三个类似的页面，通过a链接跳转，js是这样的： 12345678910111213141516171819202122232425262728293031323334var obj = [ &#123; title: "首页", url: "index.html" &#125;, &#123; title: "新闻中心", url: "./news.html" &#125;, &#123; title: "联系我们", url: "./aboutUs.html" &#125;];var _html = "";for (var i = 0; i &lt; obj.length; i++) &#123; var aaa = '&lt;li class="item"&gt;&lt;a href="' + obj[i].url +'"&gt;' +obj[i].title + "&lt;/a&gt; &lt;span&gt;&lt;/span&gt;&lt;/li&gt;"; &#125; _html = _html + aaa; &#125;; $("header .nav-top").append(_html); $("header .nav-top").on("click",".item",function() &#123; var _index = $(this).index(); console.log(_index); //打印_index一闪而过 $(this) .addClass("active") .siblings(".item") .removeClass("active"); &#125;); 问题来了：想点击各个导航的时候添加样式，却无法添加（样式一闪而过），问题出在哪呢？ 原来是点击a标签跳转的时候，因为一瞬间已经跳转到另一个页面，所以跳转之前的那个页面的js就起不了想要的作用了。 最简单的处理方式，就是把导航写死，在对应的页面添加active类获取样式。 123456789101112&lt;header&gt; &lt;div class="clearfix fixwidth"&gt; &lt;div class="logo left"&gt; &lt;a href=""&gt; &lt;img src="img/logo.png" id="logoImg"/&gt; &lt;/a&gt; &lt;/div&gt; &lt;ul class="right nav-top"&gt; &lt;li class="item active"&gt;&lt;a href="index.html"&gt;首页&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li class="item"&gt;&lt;a href="./news.html"&gt;新闻中心&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li class="item"&gt;&lt;a href="./aboutUs.html"&gt;联系我们&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/header&gt; 新闻中心、联系我们与首页一样，在对应页面添加active类即可。 SSO单点登录从a系统通过点击链接进入b系统，b系统本身是需要通过登录系统进入的，但是a系统的请求URL中带的参数保证了a系统能够自动登录b系统。同时，a系统的用户在进入b系统后有权限控制，无法查看b系统的某些内容，此即单点登录（SSO）。 12345678910111213141516171819202122232425export default &#123; created() &#123; // 请求的URL中带有唯一的标识sign，故拿这个做判断 if (this.$route.fullPath.indexOf('sign') !== -1) &#123; this.$http.get(process.env.BASE_URL + '/user/userLogin?app_id=' + this.$route.query.app_id + '&amp;nonce_string=' + this.$route.query.nonce_string + '&amp;timestamp=' + this.$route.query.timestamp + '&amp;userCode=' + this.$route.query.userCode + '&amp;sign=' + this.$route.query.sign).then((response) =&gt; &#123; console.log(response) if (response.body.code === '200') &#123; // 成功返回 this.userAccount = response.body.data[0].account // 设置cookie值account用以登录，设置cookie值roleId用以判断角色 setCookie('account', this.userAccount) setCookie('roleId', response.body.data[0].roleId) this.isLoginShow = false this.$message(&#123; message: '您已进入某某系统，我们将记录您在本系统内的所有操作！', type: 'warning' &#125;) &#125; else &#123; // alert(response.body.message) this.$message.error(response.body.message) &#125; &#125;) &#125; &#125;&#125; 免密SSH，拉取代码有时候拿到代码仓库地址，无法拉取代码，即使是管理员添加了权限也不行。 解决方法：打开C盘的.ssh文件夹里的id_rsa.pub文件，将其中的公钥复制到gitlab里的ssh keys里面，点击add key。然后关闭sourcetree，重新打开即可获取。 sourcetree撤销推送有时候提交代码后又不想提交了，可以右键点击自己想要退回的最新版本，选择“重置当前分支到此次提交”，使用模式选择软合并或者混合合并都是安全的。此时，推送通知自动取消。 cookie的妙用背景接手的项目，使用vue+element做企业库系统。该系统遗留了一个bug:数据列表翻页的时候丢失查询参数。 123456789101112131415161718api (path, status) &#123; sessionStorage.setItem('pageName', path) this.changeLable(path) // 如果切换了路径修改成第一页开始 if (path !== this.path) &#123; this.pageNum = 1 &#125; this.path = path this.$http.get(process.env.BASE_URL + '/interfaces/interfaceLimit?pageNum=' + this.pageNum + '&amp;pageSize=' + this.pageSize + '&amp;status=' + status).then((response) =&gt; &#123; this.totalNum = response.body.dataCount this.dataList = response.body.dataList &#125;)&#125;,handleCurrentChange (val) &#123; this.pageNum = val this.api(this.path) sessionStorage.setItem('pageNum', val)&#125; 分析问题出在：在handleCurrent方法里的api方法没有传入对应的status参数。查阅了element文档，发现handleCurrentChange函数只能传一个val参数（不知道当时为啥没传）。那么api函数如何才能拿到status参数呢。思来想去，解决的方法就是在获取数据后，将status存到cookie中，然后再去拿。 12345678910111213141516171819202122api (path, status) &#123; sessionStorage.setItem('pageName', path) this.changeLable(path) // 如果切换了路径修改成第一页开始 if (path !== this.path) &#123; this.pageNum = 1 &#125; this.path = path this.$http.get(process.env.BASE_URL + '/interfaces/interfaceLimit?pageNum=' + this.pageNum + '&amp;pageSize=' + this.pageSize + '&amp;status=' + status).then((response) =&gt; &#123; this.totalNum = response.body.dataCount this.dataList = response.body.dataList // 将status存入cookie，方便后面handleCurrentChange方法里面的api函数去拿。 setCookie('status', response.body.status) &#125;)&#125;,handleCurrentChange (val) &#123; this.pageNum = val // 获取status，并当做参数传入api方法。 let status = getCookie('status') this.api(this.path, status) sessionStorage.setItem('pageNum', val)&#125;, 双波浪号JavaScript字符的使用~是二进制的按位取反,~~可以理解为是取整的简写 1234567891011~~null; // =&gt; 0~~undefined; // =&gt; 0~~0; // =&gt; 0~~&#123;&#125;; // =&gt; 0~~[]; // =&gt; 0~~(1/0); // =&gt; 0~~false; // =&gt; 0~~true; // =&gt; 1~~1.2543; // =&gt; 1~~4.9; // =&gt; 4~~(-2.999); // =&gt; -2 对于非数字（包括0）, ~ ~的结果为0,布尔的true是1；对于大于0的数, ~ ~相当于是Math.floor；对于小于0的数,~~相当于是Math.ceil ~~在性能上来说更快. IE浏览器低版本添加console对象1234567/* 防止低版本ie或者国产浏览器兼容模式在没有删除console调试代码时报错的问题。如果在打包前确保删除所有console调试代码，可删除本段代码。 */window.console = window.console || (function () &#123; const c = &#123;&#125; c.log = c.warn = c.debug = c.info = c.error = c.time = c.dir = c.profile = c.clear = c.exception = c.trace = c.assert = function () &#123;&#125; return c&#125;()) 回到浏览器顶部功能12345&lt;div id="extraTools"&gt; &lt;div id="back"&gt; &lt;a href="javascript:;" id="btn" class="el-icon-arrow-up"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819#extraTools &#123; position: fixed; width: 60px; height: 60px; right: 2%; bottom: 10%; z-index: 99; border-radius: 5px; background: rgba(184,186,188,0.5)&#125;#back a &#123; display: block; width: 60px; height: 60px; color:#fff; font-size: 28px; line-height: 60px; text-align: center;&#125; 12345678910111213141516171819202122232425window.onload = function()&#123; var btn = document.getElementById("btn") var timer = null var isTop = true window.onscroll = function()&#123; if(!isTop)&#123; clearInterval(timer) &#125; isTop = false &#125; //回到顶部按钮点击事件 btn.onclick = function()&#123; timer = setInterval( function()&#123; //获取滚动条的滚动高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop //用于设置速度差，产生缓动的效果 var speed = Math.floor(-scrollTop / 6) document.documentElement.scrollTop = document.body.scrollTop = scrollTop + speed isTop =true; if(scrollTop === 0)&#123; clearInterval(timer) &#125; &#125;,50 ) &#125;&#125; 循环添加节点12345var html = "";for(var i = 0;i&lt;data.data.length;i++) &#123; html += '&lt;div class="swiper-slide"&gt;&lt;img style="" src="'+data.data[i].picUrl+'" /&gt;&lt;/div&gt;'&#125;$('.swiper-wrapper').append(html) 通过变量控制追加节点的次数123456789101112var a = 0;var html = "";for(var i = 0 ;i&lt;data.data.length;i++) &#123; html = '&lt;div class="col-md-6 col-xs-6"&gt;' + '&lt;div class="caseDiv"&gt;' + '&lt;p class="casePi"&gt;'+data.data[i].summary+'&lt;/p&gt;'+ '&lt;a class="btn btn-default caseBtn" href="javascript:;" role="button" onclick="toDetail(\''+ id +'\')"&gt;查看更多&lt;/a&gt;' +'&lt;div class="mask img-rounded"&gt;&lt;/div&gt;' +'&lt;a href=""&gt;&lt;img src="'+data.data[i].picUrl+'" class="img-responsive img-rounded caseList-imgRounded"/&gt;&lt;/a&gt;' +'&lt;/div&gt;' +'&lt;h5&gt;&lt;a href="javascript:;" class="caseList-five"&gt;'+data.data[i].title+'&lt;/a&gt;&lt;/h5&gt;' +'&lt;/div&gt;' if (a&lt;3) &#123; //右侧 $('.newRow .rightnews').append(html) // 只显示3项内容 a++; &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>开发实践</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map和forEach的区别]]></title>
    <url>%2F2019%2F01%2F04%2Fmap%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[定义forEach(): 针对每一个元素执行提供的函数； map(): 创建一个新的数组，其中每一个元素由调用数组中的每一个元素执行提供的函数得来 到底有什么区别呢？forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。 示例下方提供了一个数组，如果我们想将其中的每一个元素翻倍，我们可以使用map和forEach来达到目的。 1let arr = [1, 2, 3, 4, 5]; forEach()注意，forEach是不会返回有意义的值的。我们在回调函数中直接修改arr的值。 123arr.forEach((num, index) =&gt; &#123; return arr[index] = num * 2;&#125;); // arr = [2, 4, 6, 8, 10] map123let doubled = arr.map(num =&gt; &#123; return num * 2;&#125;); // doubled = [2, 4, 6, 8, 10] 执行速度经测试，forEach()的执行速度比map()慢。 函数式角度的理解如果你习惯使用函数是编程，那么肯定喜欢使用map()。因为forEach()会改变原始的数组的值，而map()会返回一个全新的数组，原本的数组不受到影响。 哪个更好呢？取决于你想要做什么。 forEach适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。 12345678let arr = ['a', 'b', 'c', 'd'];arr.forEach((letter) =&gt; &#123; console.log(letter);&#125;);// a// b// c// d map()适用于你要改变数据值的时候。不仅仅在于它更快，而且返回一个新的数组。这样的优点在于你可以使用复合(map(), filter(), reduce()等组合使用)来玩出更多的花样。 12let arr = [1, 2, 3, 4, 5];let arr2 = arr.map(num =&gt; num * 2).filter(num =&gt; num &gt; 5); // arr2 = [6, 8, 10] 我们首先使用map将每一个元素乘以2，然后紧接着筛选出那些大于5的元素。最终结果赋值给arr2。 核心要点 能用forEach()做到的，map()同样可以。反过来也是如此。 map()会分配内存空间存储新数组并返回，forEach()不会返回数据。 forEach()允许callback更改原始数组的元素。map()返回新的数组。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call、apply、bind函数的用法]]></title>
    <url>%2F2018%2F12%2F05%2Fcall%E3%80%81apply%E3%80%81bind%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[call(),apply(),bind() 函数大家可能都有所了解，但是在平时搬砖过程中很可能或者基本没用过，学过但都淡忘了。 但是在大量第三方的框架(库)，甚至js自己都在源码中大量使用call,apply 函数。所以今天和大家仔细讨论下它们在开发中的应用场景。 它们是啥意思作用 他们的作用都是改变函数内部的this。 这三个函数都是函数对象的方法，也就是说只有函数才可以直接调用这些方法。 ps：call,apply,bind属于this显式绑定，还有好几种其他的this绑定方式，感兴趣的可以点这里。 三者区别参数：三个函数的第一个参数都是需要绑定的 this。call： 可以有n个参数，从第二个参数开始的所有参数都是原函数的参数。apply：只有两个参数，并且第二个参数必须为数组，数组中的所有元素一一对应原函数的参数。bind： 只有一个参数，即要绑定的this。 call 语法： foo.call(this, arg1,arg2, … ,argn );apply 语法： foo.apply(this, [ arg1,arg2, … ,argn ] );bind 语法： foo.bind(this); 调用call,apply： 调用后立即执行原函数。bind： 调用后返回已经绑定好this的函数。 小例子一枚： 1234567function foo(a,b)&#123; console.log(a+b);&#125;foo.call(null,&apos;海洋&apos;,&apos;饼干&apos;); // 海洋饼干 这里this指向不重要就写null了foo.apply(null, [&apos;海洋&apos;,&apos;饼干&apos;] ); // 海洋饼干var fun = foo.bind(null);fun(&apos;海洋&apos;,&apos;饼干&apos;); // 海洋饼干 它们能干啥事这是我们今天讨论的主题，这三个函数如何应用？什么情况下使用？能改变this指向又能咋滴？ 处理伪数组 (最常用)先考虑一个问题，如果你使用var arr = document.getElementsByTagName(&#39;li&#39;)获取了5个li元素，你现在需要获取其中的第2,3,4三个元素，你会怎么做？ 这样arr.slice(1,4);？ 啊哦，TypeError -- arr.slice is not a function(slice不是函数)，数组操作在日常搬砖中非常常见，我见过最傻的解决这个问题的方式是使用循环，将需要的元素一个个添加到一个新数组里，下面我介绍的方法完全可以在实战中使用，可以给你的代码加分哦,非常方便简洁(中高级前端程序员中，算是基本操作了)。 先要介绍一个概念( 伪数组 )，这也是为什么我们刚刚slice切割数组时出错的原因： (对新手来说算是干货了，知道的可以跳过) 什么是伪数组？ 有length属性 能按索引存储数据 能像遍历数组一样来遍历 不能使用数组的push()、slice()等方法 简单来说就是可以像数组一样操作的对象，但是没有数组的方法。 js中存在大量伪数组，如 ： function的arguments对象;getElementsByName(),getElementsByTagName(),childNodes/children 等方法的返回值;还有比较常见的jquery,使用它获取的元素也是伪数组 回到原来的问题，如何截取伪数组中的元素：伪数组没有这些方法，我们’借用’Array的slice不就行了 1[].slice.call(arr,1,4); // 推荐写法 不想借用你可以直接给伪数组添加一个slice函数，如 12arr.slice = [].slice;arr.slice(1,4); 当然，’借用’ 更方便，直接添加会导致伪数组对象’污染’。 如果可以随意改变原对象，可以 直接将其转成真正的数组对象。 1[].slice.call(arr); 继承继承方式多种多样,我们现在讨论的这种是其中很重要的一种实现方式，用call实现 js 构造函数继承 。 单继承12345678910function person(name)&#123; this.name = name&#125;function man(name)&#123; this.age = &apos;男&apos;; person.call(this,name); // 继承 man&#125;var me = new man(&apos;海洋饼干&apos;);console.log(me.name,me.age); // &apos;海洋饼干&apos; &apos;男&apos; 多继承1234567891011121314function person(name)&#123; this.name = name&#125;function man(name)&#123; this.age = &apos;男&apos;;&#125;function manProgrammer(name)&#123; this.girlfriend = null; person.call(this,name); // 继承 person man.call(this,name); // 继承 man&#125;var me = new manProgrammer(&apos;海洋饼干&apos;);console.log(me.name,me.age,me.girlfriend); // &apos;海洋饼干&apos; &apos;男&apos; null this硬绑定 —bind将一个对象强制且永久性绑定到函数的this上，使用call,apply或者其他的绑定方式都无法改变(除了new绑定，当然，可以手动撸一个new都无法改变的硬绑定) 直接看例子： 1234567891011121314151617var fun ;var obj = &#123; a : 1, foo : function()&#123; var _this = this; //平时有没有过这种写法？ 为了防止this指向问题 //将this赋值给一个变量,间接维持了this的安全性 fun = function()&#123; console.log(_this.a); &#125; &#125;&#125;obj.foo();fun(); // 1var obj1 = &#123; a : 2&#125;obj.foo.call(obj1); // 直接修改_this所绑定的值,boom了fun(); // 2 但是这种方法感觉上是在逃避问题，直接不使用this了 ? 这真的不是什么好的解决问题的态度。下面使用我们的bind来优化一下： 1234567891011121314var fun ;var obj = &#123; a : 1, foo : function()&#123; // 不使用 _this， 避免无谓的变量声明 fun = function()&#123; console.log(this.a); &#125;.bind(this); // 代码很简洁,很漂亮（b格） &#125;&#125;var obj1 = &#123; a : 2&#125;obj.foo();fun(); // 1fun.call(obj1); // 1 call ,apply等绑定 无法修改 // 这里和上面call的位置不同是因为this所处于不同的位置 这样替代 _this 很规(zhuang)范(b)呢 ps：call,apply,bing属于this显示绑定，还有好几种其他的this绑定方式，感兴趣的可以点这里。 取数组最大最小值Math.max和min方法，接收多个参数，比较出极值，这里用到apply的一个默认功能：展开数组，传入一个数组参数就可以默认将这个数组转成一个个参数的形式赋给原函数 123var num = [6,9,-3,-5];console.log(Math.max.apply(Math,num)); // 9 等价 console.log(Math.max(6,9,-3,-5));console.log(Math.min.apply(Math,num)); // -5 等价 console.log(Math.min(6,9,-3,-5)); 合并数组合并数组常见有三种方式，1.循环 2.Array的concat() 3. 使用apply()合并 这里是使用最简便的apply: 1234var a = [1,2,3];var b = [4,5,6];[].push.apply(a,b); // 借用数组的push方法 等价 a.push(4,5,6);console.log(a); // [1, 2, 3, 4, 5, 6] 转自https://segmentfault.com/a/1190000011389726]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript完整手册]]></title>
    <url>%2F2018%2F12%2F03%2FJavaScript%E5%AE%8C%E6%95%B4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[注：本文为译文。其实网上关于该篇文章已经有了不少翻译版本，但大多都让人不太满意（有不少词不达意和不够精炼、通俗易懂的地方），所以试着自己翻译一遍，算是用来巩固和提高自己的JavaScript水平吧！ 文章会根据目录，形成一个JavaScript系列。 原文地址：freeCodeCamp（可能需要梯子） JavaScript 完整手册JavaScript 是世界上最流行的编程语言之一，现在也广泛用于浏览器之外的其他地方。近几年，Node.js 的崛起打破了长期以来Java, Ruby, Python, PHP 等传统服务端语言对后端开发领域的统治。 这本 JavaScript 完整手册遵循二八定律（the 80/20 rule）：在 20% 的时间里学习80% 的 JavaScript 知识。 快来学习你需要知道的有关JavaScript的所有知识吧！ 目录 ECMASCRIPT的发展史与现状 ES6带来的重大特性 ES2016(ES7)新增特性 ES2017(ES8)新增特性 ES2018(ES9)新增特性 编码风格 词法结构 变量 数据类型 表达式 原型继承 JavaScript中的Classes(类) 异常处理 在JavaScript中使用分号(;) 在JavaScript中使用引号(“”) ES6模板字面量 函数 ES6箭头函数 闭包 数组 循环 事件(Events) 事件循环(The Event Loop) 异步编程与回调 Promises Async和Await 循环和作用域(Loops and Scope) 定时器(Timers) JavaScript中的This 严格模式(Strict Mode) 立即执行的函数表达式(IIFE) 数学运算符 Math对象 ES模块 CommonJs介绍 JavaScript术语表 JavaScript介绍JavaScript是世界上最流行的编程语言之一，自20年前诞生以来，已经走过了很长的一段路。JavaScript被限定为第一个而且是唯一一个由web浏览器原生支持的脚本语言。 一开始，JavaScript并没有现在那么强大的功能，它主要用来制作花哨的动画和当时被广泛称奇的动态HTML(DHTML)。 随着web平台需求的不断增长，为了满足这个世界上使用最为广泛的生态系统之一的需求，JavaScript也在不断地发展。 web平台引入了很多东西，包括浏览器API,但JavaScript语言本身也得到了长足的发展。 现在，JavaScript也广泛应用于浏览器之外的场景。过去几年，Node.js 的崛起解锁了长期以来被 Java, Ruby, Python, PHP 等传统服务端语言统治的后端开发领域。 现代JavaScript也可以操作数据库和开发应用程序，甚至可以开发嵌入式程序、移动APP、电视应用程序等等。曾经只局限于web开发的小语言，现在已经成长为世界上最为流行的开发语言了。 JavaScript基本定义JavaScript是这样一种编程语言： 高级语言：它提供的抽象方法允许你忽略当前运行它的机器的详细信息。JavaScript 通过垃圾回收器自动管理内存，让你可以更专注代码而不是管理内存，它也提供了很多构造函数让你更好地处理变量和对象。 动态语言：与静态编程语言相反，动态语言在运行时执行许多静态语言在编译时执行的操作。 这有利有弊，它为我们提供了强大的功能，如动态类型，后期绑定，反射，函数式编程，对象运行时更改，闭包等等。 动态类型：变量不用定义类型。你可以为变量重新绑定任何类型，比如给一个已声明过的字符串变量绑定一个整型值。 弱类型：与强类型相反，弱(或松散)类型语言不强制要求设定对象的类型。这使得操作更加灵活的同时，也使得我们无法进行类型检查以确保类型安全（这也是TypeScript 和 Flow 旨在改善的问题）。 解释型：JavaScript 通常被认为是一种解释型语言，这意味着在程序运行前不需要先编译，这恰恰与 C 语言，Java 或者 Go 语言相反。事实上，出于性能考虑浏览器会在执行 JavaScript 之前进行编译，但是这一切都是自然而然发生的，不需要我们进行额外的操作。 多范型：JavaScript 不强制使用任何固定的编程范式，不像 Java 强制面向对象编程或者是 C 语言强制命令式编程。在 JavaScript 中，你可以使用原型和 ES6 中提供的 classes 语法面向对象编程，你也可以通过它的头等函数（first-class functions）编写函数式编程风格的代码，甚至可以像C语言那样进行命令式编程。 多说一句，JavaScript 和 Java的关系，正如雷锋和雷峰塔的关系，两者没有任何关系。这是一个不幸的命名选择，但是我们不得不接受这个现实。 JavaScript版本让我介绍一下 ECMAScript这个术语。我们有一个专门介绍 ECMAScript 的完整指南，你可以在那里深入了解它，但现在，你只需要知道 ECMAScript（也被称作 ES）是 JavaScript 标准的名字。JavaScript 是对 ECMAScript 标准的一种实现，这也是为什么你会听到 ES6, ES2015, ES2016, ES2017, ES2018 等等。 很长一段时间内，所有浏览器中运行的 JavaScript 版本都是ECMAScipt 3。版本 4 因为语言特征实现周期太长被取消了（他们试图一次性添加很多特性）。虽然 ES5 是 JavaScript 的一个巨大的改进版本，但是 ES2015（也被称作 ES6）同样也是 JavaScript 的重要更新。 从那时起，标准制定委员会决定每年更新一个版本，避免版本迭代间隔太久，同时也能加快反馈速度。 现在，最新批准的 JavaScript 版本是 ES2017（译注：最新版本已经是ES2019）。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript完整手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中for...in循环与for...of循环的执行效率和使用]]></title>
    <url>%2F2018%2F11%2F30%2Fjavascript%E4%B8%ADfor-in%E5%BE%AA%E7%8E%AF%E4%B8%8Efor-of%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[for…in性能这么慢,因为它要遍历自身的属性和原型链上的属性,这无疑就增加了所有不必要的额外开销. 对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名。 1234567891011121314151617let es6 = &#123; edition: 6, committee: "TC39", standard: "ECMA-262"&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// TypeError: es6[Symbol.iterator] is not a function 上面代码表示，对于普通的对象，for…in循环可以遍历键名，for…of循环会报错。 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125; 经验就是：鉴于for of 循环比for in循环要快，在有性能需要的情况下，可以考虑将for in 循环更改成for of 循环，前提是使用Object.keys()将对象循环转为对数组进行循环。 参考：http://es6.ruanyifeng.com/#docs/iterator]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改hosts文件的作用与方法]]></title>
    <url>%2F2018%2F11%2F30%2F%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是hosts文件？hosts是一个没有扩展名的系统文件，其基本作用就是将一些常用的网址域名与其对应的 IP 地址建立一个关联“ 数据库 ”。当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从hosts文件中寻找对应的 IP 地址，一旦找到，系统就会立即打开对应网页，如果没有找到，则系统会将网址提交 DNS 域名解析服务器进行 IP 地址的解析。 hosts文件的作用加快域名解析对于经常访问的网站，咱们可以通过在hosts文件中配置域名和 IP 的映射关系，提高域名的解析速度。由于有了映射关系，当咱们输入域名后，计算机就能够快速解析出 IP 地址，而不用请求网络上的 DNS 服务器。 构建映射关系在很多单位中，都会有自己局域网，而且还会有不同的服务器提供给公司的成员使用。但由于局域网中一般很少架设 DNS 服务器，因此在访问这些服务器时，就需要输入难记的 IP 地址，这对大家来说相当麻烦。因此，咱们可以分别给这些服务器取个容易记住的名字，然后在hosts文件中建立 IP 映射，这样在以后访问的时候，只要输入这个服务器的名字就 OK 啦！ 屏蔽垃圾网站现在有很多网站，在不经过咱们同意的时候，就将各种各样的插件安装到咱们的计算机中，其中不乏病毒和木马。对于这些网站，咱们就可以利用hosts文件把这些网站的域名映射到一个错误的 IP 或本地计算机的 IP 地址上，这样就可以达到禁止访问的目的啦！ 修改hosts文件的方法由于 hosts 文件属性系统文件，因此需要管理员权限才能对其进行修改。 第一种方法：先将权限修改成管理员权限，然后在对其进行修改。第二种方法：先将hosts文件复制到桌面，这时就不需要管理员权限了，因此可以对其进行修改了，等修改之后，在将其拖回原目录，替换就可以啦！在 iOS 系统中中，hosts文件的位置为：~/private/etc 在 Windows 系统中，hosts文件的位置为：C:\Windows\System32\drivers\etc hosts文件修改示例： 202.108.22.5 www.baidu.com 如上所示，咱们在本地的hosts文件中，将百度的 IP 地址与百度的域名建立了映射关系，也就起到了“加快域名解析”的作用，因为不需要再去请求 DNS 服务器啦！此外，如果咱们想要对其进行注释的话，直接在前面加#符号就可以，例如： #202.108.22.5 www.baidu.com]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>开发实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue开发小知识点整理]]></title>
    <url>%2F2018%2F11%2F30%2Fvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇用于总结vue日常开发中会用到，但是经常踩坑或闹不太清楚的知识点，持续更新。 vue中template标签嵌套的作用123456789&lt;template&gt; &lt;div class=&quot;mainedit&quot;&gt; &lt;template v-if=&quot;renderStatus&gt;=0 &amp;&amp; renderStatus&lt;8&quot;&gt; &lt;em&gt;&#123;&#123;renderMsg&#125;&#125;&lt;strong class=&quot;dotting&quot;&gt;&lt;/strong&gt;&lt;/em&gt; &lt;span&gt;&lt;ins :style=&quot;&#123;width:percent&#125;&quot;&gt;&lt;/ins&gt;&lt;/span&gt; &lt;b v-html=&quot;percent&quot;&gt;&lt;/b&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt; template不会渲染成元素，用div的话会被渲染成元素。把if,show,for等语句抽取出来放在template上面，把绑定的事件放在temlpate里面的元素上，可以使html结构更加清晰，还可以改善一个标签过长的情况。 一个具体的跨组件tab切换功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;rightpart&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a @click=&quot;changeTab(1)&quot; :class=&quot;tabIndex==1?&apos;on&apos;:&apos;&apos;&quot;&gt; &lt;i class=&quot;fa fa-picture-o&quot;&gt;&lt;/i&gt; &lt;span&gt;图片&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a @click=&quot;changeTab(2)&quot; :class=&quot;tabIndex==2?&apos;on&apos;:&apos;&apos;&quot;&gt; &lt;i class=&quot;fa fa-music&quot;&gt;&lt;/i&gt; &lt;span&gt;音乐&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;keep-alive&gt; &lt;div class=&quot;funcwrap&quot; :class=&quot;&#123;&apos;closed&apos;:!isShow&#125;&quot;&gt; &lt;picfunc v-if=&quot;tabIndex == 1&quot;&gt;&lt;/picfunc&gt; &lt;musicfunc v-if=&quot;tabIndex == 2&quot;&gt;&lt;/musicfunc&gt; &lt;/div&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import picfunc from &quot;./right/PicFunc&quot;; import musicfunc from &quot;./right/MusicFunc&quot;; import &#123;mapState&#125; from &quot;vuex&quot;; export default &#123; computed: &#123; ...mapState([&quot;tabIndex&quot;]) &#125;, components: &#123; picfunc, musicfunc &#125;, methods:&#123; //更新打开窗口 changeTab(tab) &#123; var params = &#123;&#125;; params.index = tab; this.$store.dispatch(&quot;changeTab&quot;, params); &#125;, &#125; &#125;&lt;/script&gt; vuex相关 1234567891011121314151617181920212223//index.jsconst state = &#123; tabIndex: -1&#125;//mutation-types.jsexport const CHANGETAB= 'CHANGETAB'//mutations.jsimport &#123;CHANGETAB&#125; from './mutation-types.js'export default &#123; [CHANGETAB](state, params) &#123; state.tabIndex = params.index; &#125;&#125;//actions.jsimport &#123;CHANGETAB&#125; from './mutation-types.js'export default &#123; changeTab(&#123;commit&#125;, params) &#123; commit(CHANGETAB, params) &#125;&#125; 如何在vue项目中刷新当前页面背景在最近接手的一个项目中，遗留了一个bug：系统登录后，在首页登录名无法渲染出来，但是跳转到其他页面的时候，登录名就能渲染出来了。查看代码之后，觉得应该是子组件传值不成功导致的。但是因为任务比较紧急，所以决定先采用刷新当前页面的方式来解决这个问题。 那么问题来了，vue项目如何刷新当前页面呢？ 通过provide/inject组合注入reload方法实现刷新通过查询资料，找到了一种比较靠谱的方式：通过provide / inject 组合，注入reload方法。 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view v-wechat-title=&quot;$route.meta.title&quot; v-if = &quot;isRouterAlive&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;App&apos;, provide () &#123; return &#123; reload: this.reload &#125; &#125;, data () &#123; return &#123; isRouterAlive: true &#125; &#125;, methods: &#123; reload () &#123; this.isRouterAlive = false this.$nextTick(function () &#123; this.isRouterAlive = true &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在app.vue中通过声明reload方法，控制router-view的显示与隐藏，从而控制页面的再次加载。 这里定义了一个isRouterAlive来控制显示与隐藏。 然后，在当前需要刷新的页面中注入app.vue中提供的reload依赖，然后直接调用this.reload就行。 123456789export default &#123; name: 'login', inject: ['reload'], methods: &#123; login () &#123; this.reload() &#125; &#125;&#125; 通过限制v-for循环次数，来达到只渲染一部分数据的目的背景用vue结合element做项目的时候，有一项需求是这样的：只显示表格的第一项，其余项加上第一项通过点击“更多”按钮，以弹窗的形式展示。 限制v-for循环次数那么，该如何初始化页面的时候只显示第一行数据呢。方法就是限制v-for循环的次数，只显示第一项数据。 限制v-for循环次数的两种方法： 1.截取循环的数据 123&gt; v-for="(item,index) in changeInfo.slice(0, 2)"&gt; //用这样的方法可以截取循环的数据长度，从而控制循环的次数&gt; 2.通过v-if来控制 123&gt; v-for="(item,index) in changeInfo" v-if="index&lt;3"&gt; //在标签下紧跟v-if来进行控制，这里是用索引来进行控制的，所以循环的时候记得把index这个参数加到v-for循环中。&gt; 1234567891011121314151617181920212223242526272829303132&lt;table class=&quot;table1&quot; v-if=&quot;!isQueryRegistChange&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;日期&lt;/td&gt; &lt;td&gt;变更项&lt;/td&gt; &lt;td&gt;变更前&lt;/td&gt; &lt;td&gt;变更后&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(item,index,key) in changeInfo&quot; :key=&quot;key&quot; v-if=&quot;index&lt;1&quot;&gt; &lt;td style=&quot;width:30px&quot;&gt;&#123;&#123;index+1&#125;&#125;&lt;/td&gt; &lt;td style=&quot;width:80px&quot;&gt;&#123;&#123;item.time&#125;&#125;&lt;/td&gt; &lt;td style=&quot;width:80px&quot;&gt;&#123;&#123;item.changeScope&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.beforeContent&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.afterContent&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;el-row style=&quot;position:absolute;right:50px&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogTableVisible = true&quot; &gt;更多&lt;/el-button&gt; &lt;/el-row&gt;&lt;/table&gt; &lt;el-dialog title=&quot;变更信息&quot; :visible.sync=&quot;dialogTableVisible&quot;&gt; &lt;el-table :data=&quot;changeInfo&quot;&gt; &lt;el-table-column type=&quot;index&quot; label=&quot;序号&quot; width=&quot;60&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column property=&quot;time&quot; label=&quot;日期&quot; width=&quot;100&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column property=&quot;changeScope&quot; label=&quot;变更项&quot; width=&quot;100&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column property=&quot;beforeContent&quot; label=&quot;变更前&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column property=&quot;afterContent&quot; label=&quot;变更后&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-dialog&gt; v-if=”index&lt;1” 只循环一次，此时页面只会显示第一条数据 index+1：用来从1开始显示表格序号 label=”序号”：用来将element的表格的序号表头由#变成汉字 vue相同路由跳转强制刷新该路由组件背景在开发过程中可能会遇到这种情况：在vue路由不改变的情况下，再次发请求刷新对应组件会失败，原因正是vue-router不支持这样做。那么，如何解决这个问题呢？ 解决方案第一步，在该路由跳转上绑定一个随机的query参数，例如时间戳或者随机数： 1this.$router.replace(&#123;name: 'customIndex', params: &#123;searchParam: this.searchParam&#125;, query: &#123;t: Date.now()&#125;&#125;) 该操作可以触发路由的改变，但是组件内的状态没有被初始化，因为组件并没有被创建 第二步，在路由容器上绑定key值： 1&lt;router-view :key="$route.query.t"/&gt; 通过key值的变化即可强制刷新该组件 vue键盘事件直接绑定失效背景最近项目里添加一个新功能：给登录按钮绑定键盘enter事件。本以为这是个非常容易的功能，但真正做的时候还是稍微花了点时间。 将@keyup.enter.native直接绑定在button上不行，因为必须先点击一次获取焦点后按enter才能触发键盘事件，但问题是此时已经登录成功了，再触发键盘事件已没有意义： 123&lt;el-input placeholder=&quot;请输入企业名称、人名，产品名等&quot;&gt; &lt;el-button slot=&quot;append&quot; type=&quot;primary&quot; @click=&quot;search()&quot; @keyup.enter.native=&quot;search&quot; icon=&quot;el-icon-search&quot; &gt;&lt;/el-button&gt;&lt;/el-input&gt; 解决方案1234567891011created () &#123; var that = this document.onkeydown = function () &#123; var key = window.event.keyCode if (key === 13) &#123; if (!getCookie('account')) &#123; that.login() &#125; &#125; &#125;&#125; 不能直接将事件添加写在button上，因为这样必须焦点在button上才能触发，所以可以直接绑定在document上即可。 对象嵌套过深，导致undefined问题代码如下： 1234567891011&lt;el-row :gutter=&quot;20&quot; v-if=&quot;basicInfo.tags.length === 0&quot;&gt; &lt;el-col :span=&quot;2&quot;&gt;标签：无&lt;/el-col&gt;&lt;/el-row&gt;&lt;el-row :gutter=&quot;20&quot; v-else&gt; &lt;el-col :span=&quot;2&quot;&gt;标签：&lt;/el-col&gt; &lt;el-col :span=&quot;18&quot;&gt; &lt;span :title=&quot;item.tagName&quot; v-for=&quot;(item,index,key) in basicInfo.tags&quot; :key=&quot;key&quot;&gt; &#123;&#123;item.tagName | filterTags&#125;&#125; &lt;/span&gt; &lt;/el-col&gt; &lt;/el-row&gt; 1234567891011121314151617181920 data () &#123; return &#123; basicInfo: &#123;&#125; &#125;, methods: &#123;fullBasicInfo: function () &#123; this.$http .post( process.env.BASE_URL + '/company/companySearchDetail', qs.stringify(&#123;key: localStorage.getItem('creditCode')&#125;) ) .then(response =&gt; &#123; if (response.data.data == null) &#123; this.isCompanySearchDetail = true &#125; else &#123; this.basicInfo = response.data.data &#125; &#125;)&#125; &#125; 显示标签功能本身没有问题，但是会报错： Cannot read property ‘length’ of undefined. 经过检查，发现像tagsLength.length这样的只有两层的属性可以正常渲染而不报错，也就是说，因为basicInfo对象没有定义tags属性，所以找不到length。 故修改如下： 1234567891011&lt;el-row :gutter=&quot;20&quot; v-if=&quot;tagsLength.length === 0&quot;&gt; &lt;el-col :span=&quot;2&quot;&gt;标签：无&lt;/el-col&gt;&lt;/el-row&gt;&lt;el-row :gutter=&quot;20&quot; v-else&gt; &lt;el-col :span=&quot;2&quot;&gt;标签：&lt;/el-col&gt; &lt;el-col :span=&quot;18&quot;&gt; &lt;span :title=&quot;item.tagName&quot; v-for=&quot;(item,index,key) in basicInfo.tags&quot; :key=&quot;key&quot;&gt; &#123;&#123;item.tagName | filterTags&#125;&#125; &lt;/span&gt; &lt;/el-col&gt; &lt;/el-row&gt; 12345678910111213141516171819202122 data () &#123; return &#123; basicInfo: &#123;&#125;， tagsLength: 0 &#125;, methods: &#123;fullBasicInfo: function () &#123; this.$http .post( process.env.BASE_URL + '/company/companySearchDetail', qs.stringify(&#123;key: localStorage.getItem('creditCode')&#125;) ) .then(response =&gt; &#123; if (response.data.data == null) &#123; this.isCompanySearchDetail = true &#125; else &#123; this.basicInfo = response.data.data this.tagsLength = this.basicInfo.tags &#125; &#125;)&#125; &#125; Vue显示时间123&lt;div&gt; &#123;&#123;time&#125;&#125;&lt;/div&gt; 12345678910111213141516171819202122import dayjs from 'dayjs'export default &#123; data()&#123; return &#123; timeInterval:null, time:dayjs().format('HH:mm:ss') &#125; &#125;, mounted()&#123; this.timeInterval = setInterval(()=&gt;&#123; this.refreshTime() &#125;,1000) &#125;, beforeDestory()&#123; clearInterval(this.timeInterval) &#125;, methods:&#123; refreshTime()&#123; this.time = dayjs().format('HH:mm:ss') &#125; &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview组件库实现自定义modal]]></title>
    <url>%2F2018%2F11%2F24%2Fiview%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89modal%2F</url>
    <content type="text"><![CDATA[最近业务中有这样一项需求：使用iview组件库实现一个自定义的modal。查了下iview官方文档，并没有这方面的详细说明，举的例子也不能够满足需要，于是就开始自己试着去实现。 实现效果 Modal.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;Row&gt; &lt;Form :rules=&quot;ruleValidate&quot; :model=&quot;formValidate&quot;&gt; &lt;FormItem label=&quot;标题：&quot; prop=&quot;tit&quot;&gt; &lt;Input v-model=&quot;formValidate.tit&quot; placeholder=&quot;请输入标题&quot; @on-change=&quot;titChange&quot;&gt;&lt;/Input&gt; &lt;/FormItem&gt; &lt;FormItem label=&quot;描述：&quot; prop=&quot;des&quot;&gt; &lt;Input v-model=&quot;formValidate.des&quot; placeholder=&quot;请输入描述&quot; type=&quot;textarea&quot; :autosize=&quot;&#123;minRows: 2,maxRows: 5&#125;&quot; @on-change=&quot;desChange&quot;&gt;&lt;/Input&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;/Row&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;Modal&apos;, data() &#123; return &#123; formValidate:&#123; tit:&apos;&apos;, des:&apos;&apos; &#125;, ruleValidate:&#123; tit:[ &#123;required: true, message: &apos;标题不能为空&apos;, trigger: &apos;blur&apos;&#125;, &#123;type: &apos;string&apos;, max: 3, message: &apos;最多可填三个字&apos;,trigger: &apos;blur&apos;&#125; ], des:[ &#123; required: true, message: &apos;描述不能为空&apos;, trigger: &apos;blur&apos; &#125;, &#123; type: &apos;string&apos;, min: 10, message: &apos;请填入至少十个字&apos;, trigger: &apos;blur&apos; &#125; ] &#125; &#125; &#125;, methods:&#123; // 将表单填入的数据传给RightPart.vue titChange:function() &#123; this.$emit(&apos;tit&apos;, this.formValidate.tit) &#125;, desChange:function() &#123; this.$emit(&apos;des&apos;, this.formValidate.des) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; RightPart.vue 点击a标签，弹出modal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;template&gt; &lt;div class=&quot;rightpart&quot;&gt; &lt;div class=&quot;temp&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in storyList&quot;&gt; &lt;p&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;a class=&quot;deleteitem&quot;&gt; &lt;Icon type=&quot;ios-close-circle-outline&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a @click=&quot;addStory()&quot;&gt;+&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import modal from &apos;./Modal&apos;; export default &#123; name: &quot;rightpart&quot;, components: &#123; modal &#125;, data() &#123; return &#123; title:&apos;&apos;, description:&apos;&apos;, storyList:[] &#125;; &#125;, methods: &#123; addStory() &#123; this.$Modal.confirm(&#123; title:&apos;创建故事&apos;, render: (h) =&gt; &#123; return h(modal, &#123; props: &#123; //若父组件有需要传递给内容组件的参数，需要在props中填入 &#125;, on: &#123; tit: (tit) =&gt; &#123; this.title = tit &#125;, des: (des) =&gt; &#123; this.description = des &#125; &#125; &#125;) &#125;, onOk: () =&gt; &#123; // 获取组件Modal传过来的值 var modalInfo = &#123; title: this.title, description:this.description &#125; this.storyList.push(modalInfo); &#125; &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>iview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuejs数据绑定更新视图与传统dom操作比较]]></title>
    <url>%2F2018%2F11%2F24%2Fvuejs%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE%E4%B8%8E%E4%BC%A0%E7%BB%9Fdom%E6%93%8D%E4%BD%9C%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[前几天写代码的时候突发奇想，想试试同一个功能先用vue来实现一次，再使用传统dom操作来实现一次。功能很简单，但实际操作一次，也能让我对MVVM思想和传统dom操作思想有一个感官的比较和认识。 SubComp.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div @click=&quot;transforData(subtemplate)&quot;&gt; &lt;img :src=&quot;ALIOSS_DOMAIN + &apos;template/&apos; + subtemplate.path + &apos;/&apos; + subtemplate.thumb&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &quot;../bus/eventBus.js&quot;;export default &#123; methods: &#123; transforData(obj) &#123; eventBus.$emit(&apos;transforData&apos;,&#123; title:obj.title, path:obj.path, thumb:obj.thumb &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Story.vue 传统dom操作 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;tabcont&quot;&gt; &lt;ul ref=&quot;storyItem&quot;&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &quot;../bus/eventBus.js&quot;;export default &#123; created() &#123; //获取subcomp传过来的数据并进行处理 eventBus.$on(&quot;transforData&quot;,function(obj)&#123; var li = document.createElement(&quot;li&quot;); li.innerHtml = &quot;&lt;img src=&quot;ALIOSS_DOMAIN + &apos;template/&apos; + obj.path + &apos;/&apos; + obj.thumb+&quot;&gt;&quot;+&quot;&lt;span&gt;&quot; + obj.title+&quot;&lt;span&gt;&quot;+&quot;&lt;a class=&apos;deletepic&apos;&gt;&lt;/a&gt;&quot;; this.$refs.storyItem.appendChid(li); //追加的节点绑定事件是无效的 &#125;) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Story.vue vue操作 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;ul class=&quot;tabcont&quot;&gt; &lt;li v-for=&quot;item in myMaterial&quot;&gt; &lt;img :src=&quot;ALIOSS_DOMAIN + &apos;template/&apos; + item.path + &apos;/&apos; + item.thumb&quot;&gt; &lt;span&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;a class=&quot;deletepic&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &quot;../bus/eventBus.js&quot;;export default &#123; data() &#123; return &#123; myMaterial:[] &#125; &#125;, created() &#123; //获取subcomp传过来的数据并进行处理 eventBus.$on(&apos;transforData&apos;,function (obj) &#123; this.myMaterial.push(obj) &#125;.bind(this)) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 可以看得出来，即使撇开性能不论，传统dom操作的写法也是让人抓狂的，拼接字符串既增加了写代码的难度也增加了读代码的难度，Vue操作中虽然模板增加了不少内容，但摒弃了拼接字符串的弊端，简单清晰许多。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2018%2F11%2F24%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件通信是vue项目中几乎必须做的事情，vue中实现组件通信的场景，包括父子组件通信，非父子组件通信两种；而通信手段，则包括： （1）props down,events up(父子组件通信) （2）bus事件总线 （3）vuex通信 下面根据本人项目中的实践，具体来说说如何进行组件通信。 props down,events up（一）父组件向子组件传值 1.创建子组件，在src/components/文件夹下新建一个子组件2.在子组件中创建props，然后创建一个名为message的属性 Child.vue 1234567891011121314&lt;template&gt;&lt;div&gt;&lt;h2&gt;Child子组件&lt;/h2&gt;&lt;!--此时message即显示为“我是要传给子组件的数据”--&gt;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; props:[&quot;message&quot;]&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3、创建父组件，在src/components/文件夹下再创建一个父组件 4、在父组件中注册子组件，并在template中加入child标签，标签中添加message属性并赋值 Parent.vue 12345678910111213141516&lt;template&gt;&lt;div&gt;&lt;child message=&quot;我是要传给子组件的数据&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &apos;./Child&apos;;export default&#123; name:&quot;parent&quot;, components:&#123; child &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 父组件向子组件传值总结： 子组件在props中创建一个属性，用以接收父组件传过来的值； 父组件中注册子组件； 在子组件标签中添加子组件props中创建的属性； 把需要传给子组件的值赋给该属性； (二)子组件向父组件传值 1.在子组件中创建一个按钮，给按钮绑定一个点击事件 2.在响应该点击事件的函数中使用$emit来触发一个自定义事件，并传递一个参数 Child.vue 12345678910111213141516171819&lt;template&gt;&lt;div&gt;&lt;h2&gt;Child子组件&lt;/h2&gt;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;button @click=&quot;sendMessageToParent()&quot;&gt;&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; props:[&quot;message&quot;], methods:&#123; sendMessageToParent()&#123; this.$emit(&quot;listenToChildEvent&quot;,&quot;我是子组件传过来的数据&quot;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.在父组件中的子标签中监听该自定义事件并添加一个响应该事件的处理方法 Parent.vue 123456789101112131415161718192021&lt;template&gt;&lt;div&gt;&lt;child message=&quot;我是要传给子组件的数据&quot; @listenToChildEvent=&quot;showMessageFromChild()&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &quot;./Child&quot;;export default&#123; name:&quot;parent&quot;, components:&#123; child &#125;, methods:&#123; showMessageFromChild(data)&#123; console.log(data); // data即为子组件传过来的数据 &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件向父组件传值总结： 子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件； 将需要传的值作为$emit的第二个参数，该值将作为实参传给响应自定义事件的方法； 在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听； bus事件总线(非父子组件通信)如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，之后通过分别调用Bus事件触发和监听来实现组件之间的通信和参数传递。 1.添加一个bus.js 123456789├── node_modules├── src ├── assets ├── components ├── data ├── bus ├── bus.js └── store ├── actions.js bus.js 12import Vue from "vue"export default new Vue; 2.在需要通信的组件都引入bus.js compoment1.vue 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;bus()&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;import Bus from &apos;./bus/bus.js&apos; ;export default &#123; data() &#123; return &#123; message: &quot;&quot; &#125; &#125;, methods: &#123; bus () &#123; Bus.$emit(&apos;msg&apos;, &apos;我是要传给你的信息&apos;); //$emit函数的第二个参数即为要传递的数据 &#125; &#125;&#125;&lt;/script&gt; component2.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;!--此时message即显示为“我是要传给你的信息”--&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bus from &quot;./bus/bus.js&quot;;export default &#123; data() &#123; return &#123; message: &quot;&quot; &#125; &#125;, mounted() &#123; let self = this; Bus.$on(&apos;msg&apos;, (e) =&gt; &#123; self.message = e console.log(`传来的数据是：$&#123;e&#125;`) //$on事件的回调函数的参数即为接收到的数据； &#125;) &#125; &#125;&lt;/script&gt; 非父子组件数据传递总结： 创建一个事件总线，用它作为通信桥梁; 在需要传值的组件中用bus.$emit触发一个自定义事件，并传递参数; 在需要接收数据的组件中用bus.$on监听自定义事件，并在回调函数中处理传递过来的参数; Vuex传值如果说bus事件总线是为了处理简单场景下的数据传递，那么vuex则是为了复杂场景下的数据传递而设计。 关于Vuex，建议参阅https://www.jianshu.com/p/054486340a9b 以后有时间的话，我会单开一篇来说说vuex。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[querySelector*和getElementBy*方法的区别]]></title>
    <url>%2F2018%2F11%2F19%2FquerySelector%E5%92%8CgetElementById%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[区别（1）querySelector属于 W3C 中的 Selectors API 规范，而getElementsBy 系列则属于 W3C 的 DOM 规范。 （2）querySelector*方法接收的参数是一个 CSS 选择符,其中querySelector()是用于接收一个CSS选择符，返回与该模式匹配的第一个元素；querySelectorAll()用于选择匹配到的所有元素；而 getElementsBy 系列接收的参数只能是单一的className、tagName 和 name等。 （3）querySelector选择符选出来的元素及元素数组是静态的，而getElementsBy 方法选出的元素是动态的。 说明querySelector list 是一个静态的 Node List，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。 12345678910111213141516&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var ul=document.querySelector('ul');var list=ul.querySelectorAll('li');for(var i=0;i&lt;list.length;i++)&#123; ul.appendChild(document.createElement('li'));&#125;//这个时候就创建了3个新的li，添加在ul列表上。console.log(list.length);// 输出的结果仍然是3，不是此时li的数量6&lt;/script&gt; getElementById list 是一个动态的 Node List， 每一次调用 lis 都会重新对文档进行查询，导致无限循环的问题。 12345678910111213&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var ul=document.getElementsByTagName('ul')[0];var list=ul.getElementsByTagName('li');for(var i=0;i&lt;5;i++)&#123; ul.appendChild(document.createElement('li'));&#125;console.log(list.length)//此时输出的结果就是3+5=8&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将异步请求callback转换为同步请求promise]]></title>
    <url>%2F2018%2F11%2F16%2F%E5%A6%82%E4%BD%95%E5%B0%86%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82callback%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82promise%2F</url>
    <content type="text"><![CDATA[promise的出现，解决了回调函数因为层层嵌套导致的可读性差问题。那么，对于老项目大量存在的异步回调，如何使用promise进行改造呢？ 每个promise都有三个状态。pending、Fulfilled、Rejected。最初为pending，状态一但改变为Fulfilled、Rejected中的一种，即成永远，不再改变。 pending: 等待状态。 Fulfilled: 表示成功完成。 Rejected: 表示被拒绝，失败。 原生ajax请求及promise改造12345678910111213141516171819202122232425262728293031323334353637// 原生ajax请求function nativeRequest(url) &#123;var xhr = new XMLHttpRequest()// 这里我建议的书写顺序是： onreadystatechange -&gt; open -&gt; send// 这样，onreadystatechange 可以获取 readyState 的状态 1 2 3 4xhr.onreadystatechange = function () &#123;if (xhr.readyState === 4) &#123; // 请求已完成，且响应已就绪if (xhr.status === 200) &#123;// TODO: 处理返回正常的数据 xhr.responseText&#125; else &#123;// TODO: 处理返回非正常的数据&#125;&#125;&#125;xhr.open('GET', url, true)xhr.send(null)&#125;// promise请求function promiseRequest(url) &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; resolve(xhr.responseText) &#125; else &#123; reject(xhr.responseText) &#125; &#125; &#125; xhr.open('GET', xhr, true) xhr.send(null) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125; jquery中的ajax请求及promise改造1234567891011121314151617181920212223242526272829//jQuery的ajax请求function ajaxResponse(url) &#123;$.ajax(&#123;url: url,type: 'GET',success: res =&gt; &#123;console.log(res)&#125;,error: err =&gt; &#123;console.log(err)&#125;&#125;)&#125;//promise改造function promiseAjaxResponse(url, &#123;type = 'GET',&#125; = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url, type, success: res =&gt; &#123; resolve(res) &#125;, error: err =&gt; &#123; reject(err) &#125; &#125;) &#125;)&#125; node风格的callback请求及promise改造1234567891011nodeGet(param, function (err, data) &#123; &#125;)//promise改造function nodeGetAysnc(param) &#123; return new Promise((resolve, reject) =&gt; &#123; nodeGet(param, function (err, data) &#123; if (err !== null) return reject(err) resolve(data) &#125;) &#125;)&#125; DOM load事件或者其他一次性事件请求及promise改造12345678910111213function load() &#123;console.log('onload - end')&#125;window.onload = load// promise改造function promiseLoad() &#123; return new Promise(function (resolve, reject) &#123; window.onload = resolve &#125;)&#125;promiseLoad().then(load) 转自https://www.cnblogs.com/weiqinl/p/9651515.html]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hasOwnProperty方法的使用]]></title>
    <url>%2F2018%2F11%2F16%2FhasOwnProperty%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。 判断自身属性是否存在123456789var o = new Object();o.prop = 'exists';function changeO() &#123;o.newprop = o.prop;delete o.prop;&#125;o.hasOwnProperty('prop'); // truechangeO();o.hasOwnProperty('prop'); // false 判断自身属性与继承属性1234567891011121314151617function foo() &#123;this.name = 'foo'this.sayHi = function () &#123;console.log('Say Hi') &#125;&#125;foo.prototype.sayGoodBy = function () &#123;console.log('Say Good By')&#125;let myPro = new foo()console.log(myPro.name) // fooconsole.log(myPro.hasOwnProperty('name')) // trueconsole.log(myPro.hasOwnProperty('toString')) // falseconsole.log(myPro.hasOwnProperty('hasOwnProperty')) // fasleconsole.log(myPro.hasOwnProperty('sayHi')) // trueconsole.log(myPro.hasOwnProperty('sayGoodBy')) // falseconsole.log('sayGoodBy' in myPro) // true 遍历一个对象的所有自身属性使用for…in循环对象的所有枚举属性，然后再使用hasOwnProperty()方法来忽略继承属性。 12345678910var buz = &#123;fog: 'stack'&#125;;for (var name in buz) &#123;if (buz.hasOwnProperty(name)) &#123; alert("this is fog (" + name + ") for sure. Value: " + buz[name]); &#125; else &#123; alert(name); // toString or something else &#125;&#125; 使用 hasOwnProperty 作为属性名JavaScript 并没有保护 hasOwnProperty 属性名，因此某个对象是有可能存在使用这个属性名的属性的。 1234567891011121314var foo = &#123; hasOwnProperty: function() &#123; return false; &#125;, bar: 'Here be dragons'&#125;;foo.hasOwnProperty('bar'); // 始终返回 false// 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法(&#123;&#125;).hasOwnProperty.call(foo, 'bar'); // true// 也可以使用 Object 原型上的 hasOwnProperty 属性Object.prototype.hasOwnProperty.call(foo, 'bar'); // true]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JavaScript中的this]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[ES6中新增了箭头函数这种语法,箭头函数以其简洁性和方便获取this的特性,俘获了大批粉丝儿。 它也可能是面试中的宠儿, 我们关键要搞清楚箭头函数和普通函数中的this。 普通函数中的this 1.this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj。 2.在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成)。 3.在严格模式下,没有直接调用者的函数中的this是 undefined。 4.使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象。 箭头函数中的this 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中使用this。 下面通过一些例子来研究一下 this的一些使用场景。 要整明白这些, 我们需要首先了解一下作用域链: 当在函数中使用一个变量的时候,首先在本函数内部查找该变量,如果找不到则找其父级函数,最后直到window,全局变量默认挂载在window对象下。 全局变量默认挂载在window对象下123456var aa = 2;console.log(window.aa); //2(function () &#123; aa = 3;&#125;)();console.log(window.aa); //3 我们仅仅声明了一个全局变量aa,但是打印出window.aa却和aa保持一致,为什么呢? 我们可以看到在window属性中,看到 aa 属性了;此外,函数也适用于此情况,全局函数也会挂在window对象下 我们常见的window的属性和方法有: alert, location,document,parseInt,setTimeout,setInterval等,window的属性默认可以省略window前缀! 普通函数中的this普通函数中的this指向它的直接调用者;如果找不到直接调用者,则是window。 我们来看一些例子。 示例1: 1234function test() &#123; console.log(this);&#125;test(); 结果是: window 。 原因: test()是一个全局函数,也就是说是挂在window对象下的,所以test()等价于 window.test() ,所以此时的this是window。 示例2: 12345678var obj = &#123; say: function () &#123; setTimeout(function () &#123; console.log(this) &#125;); &#125;&#125;obj.say(); 结果是: window。 匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window。 问题: 如果想要在setTimeout/setInterval中使用这个对象的this引用呢? 用一个变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针! 1234567891011var obj = &#123; func: function() &#123;&#125;, say: function () &#123; var that = this; //此时的this就是obj对象 setTimeout(function () &#123; console.log(this) that.func() &#125;); &#125;&#125;obj.say(); 我们也可以使用 func.bind(this) 给回调函数直接绑定宿主对象, bind绑定宿主对象后依然返回这个函数, 这是更优雅的做法： 1234567891011var obj = &#123; func: function() &#123;&#125;, say: function () &#123; // 此时的this就是obj对象 setTimeout(function () &#123; console.log(this) this.func() &#125;.bind(this)); &#125; &#125; obj.say(); // obj 示例3： 1234567891011121314window.val = 1;var obj = &#123; val: 2, dbl: function () &#123; this.val *= 2; val *= 2; console.log(val); console.log(this.val); &#125;&#125;;// 说出下面的输出结果obj.dbl();var func = obj.dbl;func(); 结果是: 2 4 8 8 val变量在没有指定对象前缀,默认从函数中找,找不到则从window中找全局变量。 即 val =2 就是 window.val = 2。this.val默认指的是 obj.val ;因为 dbl()第一次被obj直接调用func() 没有任何前缀,类似于全局函数,即 window.func调用,所以第二次调用的时候, this指的是window, val指的是window.val，第二次的结果受第一次的影响。 在严格模式下的this12345function test() &#123; 'use strict'; console.log(this);&#125;test(); 结果是: undefined。 箭头函数中的 this12345678var obj = &#123; say: function () &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;); &#125;&#125;obj.say(); // obj 此时的 this继承自obj, 指的是定义它的对象obj, 而不是 window! 示例(多层嵌套的箭头函数): 123456789101112var obj = &#123;say: function () &#123; var f1 = () =&gt; &#123; console.log(this); // obj setTimeout(() =&gt; &#123; console.log(this); // obj &#125;) &#125; f1(); &#125;&#125;obj.say() 因为f1定义时所处的函数中的this是指的obj, setTimeout中的箭头函数this继承自f1, 所以不管有多层嵌套,都是 obj。 示例(复杂情况: 普通函数和箭头函数混杂嵌套) 123456789101112var obj = &#123;say: function () &#123; var f1 = function () &#123; console.log(this); // window, f1调用时,没有宿主对象,默认是window setTimeout(() =&gt; &#123; console.log(this); // window &#125;) &#125;; f1(); &#125;&#125;obj.say() 结果: 都是 window,因为箭头函数在定义的时候它所处的环境相当于是window, 所以在箭头函数内部的this函数window。 示例(严格模式下的混杂嵌套) 12345678910111213var obj = &#123;say: function () &#123; 'use strict'; var f1 = function () &#123; console.log(this); // undefined setTimeout(() =&gt; &#123; console.log(this); // undefined &#125;) &#125;; f1(); &#125;&#125;obj.say() 结果都是undefined。 说明: 严格模式下,没有宿主调用的函数中的this是undefined!!!所以箭头函数中的也是undefined! 总结使用箭头函数,可以让我们解决一些在匿名函数中 this指向不正确的问题; 但是要注意在和普通函数混合的时候,this的指向可能是window !]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解闭包]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包，是 Javascript 比较重要的一个概念，对于初学者来讲，闭包是一个特别抽象的概念，特别是ECMAScript 规范给的定义，如果没有实战经验，很难从定义去理解它。因此，本文不会对闭包的概念进行大篇幅描述，直接上干货，让你分分钟理解闭包！ 闭包，一睹为快在接触一个新技术的时候，我首先会做的一件事就是找它的 demo。对于我们来说，看代码比自然语言更能理解一个事物的本质。其实，闭包无处不在，比如：jQuery、zepto的核心代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包，以便让你在大脑里产生闭包的画面： 12345678function A()&#123; function B()&#123; console.log("Hello Closure!"); &#125; return B;&#125;var C = A();C();//Hello Closure! 这是最简单的闭包。 有了初步认识后，我们简单分析一下它和普通函数有什么不同，上面代码翻译成自然语言如下： （1）定义普通函数 A （2）在 A 中定义普通函数 B （3）在 A 中返回 B （4）执行 A, 并把 A 的返回结果赋值给变量 C （5）执行 C 把这5步操作总结成一句话就是： 函数A的内部函数B被函数A外的一个变量 c 引用。 把这句话再加工一下就变成了闭包的定义： 当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 因此，当你执行上述5步操作时，就已经定义了一个闭包！ 这就是闭包。 闭包的用途在了解闭包的作用之前，我们先了解一下 Javascript 中的GC机制: 在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收，否则这个对象一直会保存在内存中。 在上述例子中，B 定义在 A 中，因此 B 依赖于 A ,而外部变量 C 又引用了 B , 所以A间接的被 C 引用。 也就是说，A 不会被 GC 回收，会一直保存在内存中。为了证明我们的推理，上面的例子稍作改进： 123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;&#125;var C = A();C();// 1C();// 2C();// 3 count 是函数A 中的一个变量，它的值在函数B 中被改变，函数B 每执行一次，count 的值就在原来的基础上累加 1 。因此，函数A中的 count 变量会一直保存在内存中。 count 是函数A 中的一个变量，它的值在函数B 中被改变，函数B 每执行一次，count 的值就在原来的基础上累加 1 。因此，函数A中的 count 变量会一直保存在内存中。 当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会“污染”全局的变量时，就可以用闭包来定义这个模块。 闭包的高级写法上面的写法其实是最原始的写法，而在实际应用中，会将闭包和匿名函数联系在一起使用。下面就是一个闭包常用的写法： 123456789101112131415(function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector("#"+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;)(document); 这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。 功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行，需要重点理解的是这种写法是如何实现闭包功能的。 可以将上面的代码拆分成两部分：(function(){}) 和 () , 第1个() 是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加 () 就表示执行这个匿名函数。 因此这段代码执行执行过程可以分解如下： 12345678910111213141516var f = function(document)&#123; var viewport; var obj = &#123; init:function(id)&#123; viewport = document.querySelector("#"+id); &#125;, addChild:function(child)&#123; viewport.appendChild(child); &#125;, removeChild:function(child)&#123; viewport.removeChild(child); &#125; &#125; window.jView = obj;&#125;;f(document); 在这段代码中似乎看到了闭包的影子，但 f 中没有任何返回值，似乎不具备闭包的条件，注意这句代码： 1window.jView = obj; obj 是在函数 f 中定义的一个对象，这个对象中定义了一系列方法， 执行window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj . 而 obj 对象中的函数又引用了函数 f 中的变量 viewport ,因此函数 f 中的 viewport 不会被 GC 回收，viewport 会一直保存到内存中，所以这种写法满足了闭包的条件。 总结这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解JS的执行环境(execution context)、活动对象(activation object)以及作用域(scope)和作用域链(scope chain)的运行机制。但作为初学者，暂时不必了解这些，有了简单的理解之后，一定要在实际项目中用起来，等你用的多了，对于闭包，你自然会有更深层次的理解！ 转自https://www.cnblogs.com/onepixel/p/5062456.html]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流与函数防抖]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，onmousemove,resize,onscroll等等，有些时候，我们并不能或者不想频繁触发事件，咋办呢？这时候就该用到函数防抖和函数节流了！ 函数防抖防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行。 12345678910111213141516171819/** * 防抖函数 * @param method 事件触发的操作 * @param delay 多少毫秒内连续触发事件，不会执行 * @returns &#123;Function&#125; */ function debounce(method, delay) &#123; let timer = null return function () &#123; let self = this let args = arguments timer &amp;&amp; clearTimeout(timer) timer = setTimeout(function () &#123; method.apply(self, args) &#125;, delay) &#125;&#125;,// 触发onmouseover事件xcd.onmousemove = debounce(method,1000); 函数节流什么是节流？节流是如果你持续触发事件，每隔一段时间，只执行一次事件。 1234567891011121314151617181920212223242526272829303132333435363738 /** * 节流函数 * @param method 事件触发的操作 * @param mustRunDelay 间隔多少毫秒需要触发一次事件 * @returns &#123;Function&#125; *///节流时间戳版 function throttle(method,mustRunDelay)&#123; var self,args,initTime = 0; return function()&#123; var now = +new Date();//将new date()转化为时间戳 self = this; args = arguments; if(now - initTime&gt;mustRunDelay)&#123; method.apply(self,args); initTime = now; &#125; &#125; &#125; //触发onmousemove事件 xcd.onmousemove = throttle(method,1000); //节流定时器版 function throttle(method,mustRunDelay)&#123; var timeout; return function()&#123; var self = this;args = arguments; if(!timeout)&#123; timeout = setTimeout(function()&#123; timeout = null; method.apply(self,args); &#125;,mustRunDelay); &#125;; &#125; &#125; //触发onmousemove事件 xcd.onmousemove = throttle(method,1000);]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript去重与排序方法总结]]></title>
    <url>%2F2018%2F11%2F15%2FJavaScript%E5%8E%BB%E9%87%8D%E4%B8%8E%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[去重还排序是程序设计中最为基本的算法以及面试中的基本考点，本文对去重和排序方法进行总结。 去重 123456789101112131415161718192021222324252627282930313233// 方法一var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0]function test()&#123; for (var i = 0; i &lt; arr.length; i++)&#123; for(var j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] === arr[j]) arr.splice(j,1);//如果前一个值与后一个值相等，那么就去掉后一个值，splice()可以修改原数组 &#125; &#125; return arr;&#125;test();// 方法二var arr = [1, 1, 4, 50, 50, 6, 2, 2];function test()&#123; return arr.filter(function(item,index,array)&#123; return array.indexOf(item) === index; //或者这样写return array.indexOf(item, index+1) === -1; 如果没有重复项，返回true //用filter方法，返回ietm对应的indexOf索引值与本身index索引值相等的值，也就是去掉重复的值，filter本身不修改数组，只是会自动遍历数组， // 去掉重复值后，那么arr就剩下不重复的了 &#125;);&#125;test();//输出Array [ 1, 4, 50, 6, 2 ]// 方法三（es6）var arr = [1, 1, 4, 50, 50, 6, 2, 2];function unique(arr)&#123; return Array.from(new Set(arr));&#125;unique(arr); 排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//冒泡排序 从数组中随便拿一个数与后一位比较，如果前者比后者大，那么两者交换位置，从而遍历数组可以得到排序的效果var arr = [1, 9, 4, 50, 49, 6, 3, 2];function test(arr)&#123; for (var i = 0; i &lt; arr.length - 1; i++)&#123; for (var j = i + 1; j &lt; arr.length; j++)&#123; var tempi = arr[i]; //获取第一个值，并与后一个值比较 var tempj = arr[j]; if (tempi &gt; tempj)&#123; arr[i] = tempj; arr[j] = tempi;//如果前一个值比后一个值大，那么相互交换 &#125; &#125; &#125; console.log(arr); //return arr；&#125;test(arr);// 快速排序 在数组中间那一个值，然后用这个值跟数组里面的值相比较，大于此值的放在一边，小于的也放在一边，然后用concat()合并，// 再进行比较，如此反复var arr = [1, 9, 4, 50, 49, 6, 3, 2];function test(arr)&#123; if (arr.length &lt;= 1) return arr;//如果数组只有一位，就没有必要比较了 var index = Math.floor(arr.length / 2);//获取中间值的索引 var cur = arr.splice(index, 1);//截取中间值，如果此处使用cur=arr[index]; 那么将会出现无限递归的错误 var left = [], right = [];//小于中间值的放在left数组里，大于的放在right数组 for (var i = 0; i &lt; arr.length; i++)&#123; if (cur &gt; arr[i])&#123; left.push(arr[i]); &#125; else&#123; right.push(arr[i]); &#125; &#125; return test(left).concat(cur, test(right));//通过递归，上一轮比较好的数组合并，并且再次进行比较&#125;test(arr);// sort方法var arr = [1, 9, 4, 50, 49, 6, 3, 2];function test(arr)&#123; return arr.sort(sortNumber);&#125;function sortNumber(a, b)&#123; return a - b;&#125;test(arr);]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常用工具函数]]></title>
    <url>%2F2018%2F11%2F15%2FJavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[平时在工作中都会积累一些常用方法，持续更新。 判断数据类型1234567function getType(params)&#123; return Object.prototype.toString.call(params);&#125;//examplegetType([]) //"[object Array]"getType(function()&#123;&#125;) //"[object Function]"getType(&#123;&#125;) //"[object Object]" 1234567function toType(obj) &#123; return &#123;&#125;.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();&#125;//exampletoType([]) //"array"toType(function()&#123;&#125;) //"function"toType(&#123;&#125;) //"object" 参数过滤123456789101112131415161718192021//结合类型判断函数，对传入的对象参数进行过滤function filterNull (o) &#123; for (var key in o) &#123; if (o[key] === null) &#123; delete o[key] &#125; if (toType(o[key]) === 'string') &#123; o[key] = o[key].trim() &#125; else if (toType(o[key]) === 'object') &#123; o[key] = filterNull(o[key]) &#125; else if (toType(o[key]) === 'array') &#123; o[key] = filterNull(o[key]) &#125; &#125; return o&#125;function foo (params) &#123; if(params) &#123; params = filterNull(params) &#125;&#125; 将arguments对象转成数组123var argArray = Array.prototype.slice.call(arguments);//或者ES6：var argArray = Array.from(arguments) 评分方法12345function getRate(rate)&#123; return '★★★★★☆☆☆☆☆'.slice(5 - rate, 10 - rate);&#125;//examplegetRate(2) //★★☆☆☆ 范围内生成随机数12345function randNum(min, max) &#123; return Math.floor(min + Math.random() * ((max+1) - min));&#125;//examplerandNum(0 ,100) //生成0-100的随机数 生成随机字符串12345678//生成一个指定位数的随机字符串function randomAlphaNum(len) &#123; var rdmString = ''; for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len).toUpperCase();&#125;//examplerandomAlphaNum(16) //"017W8K1EQ63IW0T4" 对象深拷贝 深度拷贝通用函数。 深拷贝就是指创建一个数据内容和结构一模一样的新对象，新对象内的所有值的指针地址都是新的地址，即复制出一个全新的对象实例，新对象跟原对象不共享内存，两者操作互不影响。 12345678910111213141516171819202122232425262728function deepClone(values) &#123; var copy; if (null == values || "object" != typeof values) return values; if (values instanceof Date) &#123; copy = new Date(); copy.setTime(values.getTime()); return copy; &#125; if (values instanceof Array) &#123; copy = []; for (var i = 0, len = values.length; i &lt; len; i++) &#123; copy[i] = deepClone(values[i]); &#125; return copy; &#125; if (values instanceof Object) &#123; copy = &#123;&#125;; for (var attr in values) &#123; if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]); &#125; return copy; &#125; throw new Error("Unable to copy values! Its type isn't supported.");&#125; json对象的parse和stringify。 JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。该方法的不足之处是能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深拷贝。 123var source = &#123; name:"source", child:&#123; name:"child" &#125; &#125; var target = JSON.parse(JSON.stringify(source));console.log(target) 对象浅拷贝 浅拷贝ShallowCopy，是一个对象的逐位副本。创建一个新对象，该对象具有原始对象中的精确副本。如果对象的任何字段是对其他对象的引用，则只复制引用地址，即只复制内存地址，而不复制对象本身，新旧对象还是共享同一块堆内存。改变其中一个对象，另一个也会受影响。如果有修改，会失去原始数据。 简单的引用复制。 1234567891011121314function shallowClone(copyObj) &#123; var obj = &#123;&#125;; for ( var i in copyObj) &#123; obj[i] = copyObj[i]; &#125; return obj;&#125;var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = shallowClone(x);console.log(y.b.f === x.b.f); // true Object.assign()方法。 Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 1234567var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = Object.assign(&#123;&#125;, x);console.log(y.b.f === x.b.f); // true 求数组的最大值、最小值、和、平均数1234567891011121314151617var arr = [23,45,23,890]取最大值：max = Math.max.apply(null, arr)取最小值：min = Math.min.apply(null,arr)取和：function arrAdd() &#123; var sum = 0for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; return sum &#125;add = arrAdd() //取和average = arrAdd()/arr.length //取平均数 获取数组某个元素的下标123456789101112131415/** * 获取数组某个元素下标 * @param arrays 传入的数组 * @param item 需要获取下标的元素 */function contains(arrays, item) &#123; var i = arrays.length; while (i--) &#123; if (arrays[i] === item) &#123; return i; &#125; &#125;&#125;//结合数组的splice方法，用来删除数组的当前项myArray.splice(contains(myArray,item),1) 存储localStorage12345678910/** * 存储localStorage */function setStore(name, content) &#123; if (!name) return; if (typeof content !== 'string') &#123; content = JSON.stringify(content); &#125; window.localStorage.setItem(name, content);&#125; 获取localStorage1234567/** * 获取localStorage */function getStore(name) &#123; if (!name) return; return window.localStorage.getItem(name);&#125; 删除localStorage1234567/** * 删除localStorage */function removeStore（name）&#123; if (!name) return; window.localStorage.removeItem(name);&#125; 获取cookie12345678910111213141516171819202122232425/** * 将document.cookie属性的值解析出来 */function getCookie(key)&#123; var arr1 = document.cookie.split("; "); for(var i = 0; i &lt; arr1.length; i++)&#123; var arr2 = arr1[i].split("="); if(arr2[0] == key)&#123; return decodeURIComponent(arr2[1]); &#125; &#125;&#125;// orfunction getCookie (cName) &#123; if (document.cookie.length &gt; 0) &#123; let cStart = document.cookie.indexOf(cName + '=') if (cStart !== -1) &#123; cStart = cStart + cName.length + 1 let cEnd = document.cookie.indexOf(';', cStart) if (cEnd === -1) cEnd = document.cookie.length return unescape(document.cookie.substring(cStart, cEnd)) &#125; &#125; return ''&#125; 设置cookie1234567891011121314151617181920212223242526272829303132333435363738/** * 设置一个cookie的值，同时提供一个可选的max-age属性 * @param key 要设置的属性 * @param value 要设置的属性的值 * @param d 设置的max-age */function setCookie(key,value,d)&#123; if(d === undefined)&#123; document.cookie = encodeURIComponent(key) + "=" + encodeURIComponent(value); &#125;else&#123; document.cookie = encodeURIComponent(key) + "=" + encodeURIComponent(value) + ";max-age=" + (d*60*60*24); &#125;&#125;// 另一个版本的setCookie/** * 设置一个cookie的值，同时提供一个可选的max-age属性 * @param cName 要设置的属性 * @param value 要设置的属性的值 * @param expire 设置的expire */function setCookie (cName, value, expire) &#123; var date = new Date() date.setSeconds(date.getSeconds() + expire) document.cookie = cName + '=' + encodeURI(value) + '; expires=' + date.toGMTString()&#125;//要改变cookie的值，需要使用相同的名字、路径和域，但是新的值重新设置cookie的值。同样地，设置新max-age属性就可以改变原来的cookie的有效期setCookie('name','金赫思');console.log(getCookie('name'));//'金赫思'setCookie('name','康健');console.log(getCookie('name'));//'康健'//要删除一个cookie，需要使用相同的名字、路径和域，然后指定一个任意(非空)的值，并且将max-age属性指定为0，再次设置cookiesetCookie('name','金赫思');console.log(getCookie('name'));//'金赫思'setCookie('name','金赫思',0);console.log(getCookie('name'));//undefined 删除cookie1234567/** * 删除cookie * @param cName 要删除的cookie属性 */function delCookie (cName) &#123; setCookie(cName, '', -1)&#125; 获取URL参数123456789101112131415161718 /** * 获取URL请求参数 */function getQueryStrings () &#123; var url = request.url console.log(url) var theRequest = &#123;&#125; if (url.indexOf('') !== -1) &#123; var str = url.substr(1) var strs = str.split('&amp;') for (var i = 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split('=')[0]] = unescape(strs[i].split('=')[1]) &#125; &#125; return theRequest &#125; var params = getQueryStrings() var app_id = params['app_id'] // 获取app_id IE浏览器版本检测12345678910111213141516// 判断浏览器类型，如果浏览器是ie且版本低于ie10，提示更换浏览器function ieVersion () &#123; var userAgent = navigator.userAgent var isOpera = userAgent.indexOf('Opera') &gt; -1 var isIE = userAgent.indexOf('compatible') &gt; -1 &amp;&amp; userAgent.indexOf('MSIE') &gt; -1 &amp;&amp; !isOpera if (isIE) &#123; var reIE = new RegExp('MSIE (\\d+\\.\\d+);') reIE.test(userAgent) var fIEVersion = parseFloat(RegExp['$1']) if (fIEVersion &lt; 10) &#123; this.$alert('系统检测到您的IE浏览器版本过低，部分功能无法正常使用，推荐您升级浏览器或更换其他浏览器以获取最佳体验！', '温馨提示', &#123; dangerouslyUseHTMLString: true &#125;) &#125; &#125;&#125;, 将时间戳转换为时间格式12345678910/** * @param t 时间戳 */function formatDate(t) &#123; var date = new Date(t); var Y = date.getFullYear() + '-'; var M = (date.getMonth()+1 &lt; 10 ? '0'+(date.getMonth()+1) : date.getMonth()+1) + '-'; var D = date.getDate()&lt;10 ? '0'+date.getDate() : date.getDate(); return Y + M + D;&#125; 获取URL中”?”符后的字符串123456789101112function GetRequest() &#123; var url = location.search; //获取url中"?"符后的字串 var theRequest = new Object(); if (url.indexOf("?") != -1) &#123; var str = url.substr(1); strs = str.split("&amp;"); for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split("=")[0]]=unescape(strs[i].split("=")[1]); &#125; &#125; return theRequest; &#125; 对数运算1234function getBaseLog(base,x) &#123; return Math.log(x)/Math.log(base)&#125;console.log(getBaseLog(2,1024)) // 10]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目的过滤器配置]]></title>
    <url>%2F2018%2F11%2F12%2Fvue%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一个项目中，可能要用到很多过滤器来处理数据，多个组件公用的，可以注册全局过滤器。单个组件使用的，就挂载到实例filters中。项目做的多了以后，可以整理一套常用的filters，不用反复的写。比如：时间等各种操作，数据格式转化，单位换算，部分数据的md5加密等… 创建一个filters文件夹，专门放过滤器 123456789├── node_modules├── src ├── assets ├── components ├── data ├── filters ├── filters.js └── store ├── actions.js filter.js 1234567891011121314151617181920212223//将秒转换为时分秒export function formatSeconds(value) &#123; var secondTime = parseInt(value);// 秒 var minuteTime = 0;// 分 var hourTime = 0;// 小时 if(secondTime &gt; 60) &#123; minuteTime = parseInt(secondTime / 60); secondTime = parseInt(secondTime % 60); if(minuteTime &gt; 60) &#123; hourTime = parseInt(minuteTime / 60); minuteTime = parseInt(minuteTime % 60); &#125; &#125; var result = "" + parseInt(secondTime) + "秒"; if(minuteTime &gt; 0) &#123; result = "" + parseInt(minuteTime) + "分" + result; &#125; if(hourTime &gt; 0) &#123; result = "" + parseInt(hourTime) + "小时" + result; &#125; return result; &#125; main.js 123456789101112import Vue from 'vue'import App from './App'import router from './router'import Vuex from 'vuex'import store from './store/index'import axios from 'axios'import * as filters from './filters/filter.js' //引入过滤器Vue.prototype.$http = axios//使用过滤器Object.keys(filters).forEach(key=&gt;&#123; Vue.filter(key,filters[key])&#125;) 页面中直接使用过滤器即可 1&lt;div class="videolength fl"&gt;视频总时长：&lt;em&gt;&#123;&#123;worksInfo.duration|formatSeconds&#125;&#125;&lt;/em&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vue中使用websocket]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8websocket%2F</url>
    <content type="text"><![CDATA[之前在一个大数据治理项目中，因为需要页面主动更新数据，就用到了websocket，现将核心代码贴出，以备查阅。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859data()&#123; return &#123; logCountTotalDataSocket:&#123;&#125; websock:null &#125;&#125;,methods:&#123; threadPoxi() &#123; //与后端约定要发送的数据 const agentString = '&#123;"event": "subscribe", "topic": "logStatistic", "serviceId": "all"&#125;' // 若是ws开启状态 if (this.websock.readyState === this.websock.OPEN) &#123; this.websocketsend(agentString) &#125; else if (this.websock.readyState === this.websock.CONNECTING) &#123; const that = this setTimeout(function() &#123; that.websocketsend(agentString) &#125;, 300) &#125; else &#123; this.initWebSocket() const that = this setTimeout(function() &#123; that.websocketsend(agentString) &#125;, 500) &#125; &#125;, initWebSocket() &#123; // 服务器地址必须是ws地址，创建websocket对象 const wsuri = 'ws://121.40.165.18:8800' this.websock = new WebSocket(wsuri) this.websock.onmessage = this.websocketonmessage this.websock.onerror = this.websocketerror this.websock.onclose = this.websocketclose &#125;, // 数据接收 websocketonmessage(e) &#123; console.log(e) console.log('websocketonmessage', typeof e.data) this.logCountTotalDataSocket = JSON.parse(e.data) || &#123;&#125; &#125;, // 数据发送 websocketsend(data) &#123; console.log('websocketsend', data) this.websock.send(data) console.log(data) &#125;, // 连接发送错误 websocketerror(e) &#123; console.log(e.code) &#125;, // 关闭 websocketclose(e) &#123; console.log(e.code) &#125; &#125;,mounted()&#123; this.initWebSocket() this.threadPoxi()&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue调试工具Devtools不出现的解决方式]]></title>
    <url>%2F2018%2F10%2F25%2Fvue%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7Devtools%E4%B8%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在使用vuex时，想直观的查看数据state的变动，用Devtools可实现，但是在Google浏览器中开发调试的时候，右上角出现vue的图标，但是在开发者工具中没有出现vue调试（已在扩展程序中安装 Vue Devtools） 没显示调试工具的原因是用了生产环境的版本或是压缩的vue版本，或是扩展程序没有勾选：允许访问文件网址。 如果勾选了还是没有显示，说明采用了压缩版/生产版的Vuejs，则继续采用如下方案： 在main.js中添加代码： 123456// 若是没有开启Devtools工具，在开发环境中开启，在生产环境中关闭if (process.env.NODE_ENV == 'development') &#123; Vue.config.devtools = true;&#125; else &#123; Vue.config.devtools = false;&#125;]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用webstorm时提示please specify eslint package的解决方法]]></title>
    <url>%2F2018%2F10%2F25%2F%E4%BD%BF%E7%94%A8webstorm%E6%97%B6%E6%8F%90%E7%A4%BAplease-specify-eslint-package%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[webstorm的file –&gt; settings –&gt; Language &amp; Frameworrks –&gt; Javascript –&gt; Code Quality Tools –&gt; 打开ESLint，把他们的 Enable 属性都取消，点击右下角‘Apply’，‘OK’ 即可。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个loading模板]]></title>
    <url>%2F2018%2F10%2F25%2F%E4%B8%80%E4%B8%AAloading%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[12345678910111213var _LoadingTitle="努力加载中...";var _LoadingHtml = '&lt;div id="loadingDiv" style="position:absolute;left:0;width:100%;height:100%;top:0;opacity:1;filter:alpha(opacity=80);z-index:10000;"&gt;&lt;div style="position: absolute; cursor1: wait; left: 50%; top:50%; width: 448px; height: 118px; line-height: 118px; border: 2px solid #4dd3c5; color: #4dd3c5; margin-left:-225px;margin-top: -60px;font-size:24px;text-align: center;"&gt;'+_LoadingTitle+'&lt;/div&gt;&lt;/div&gt;';document.write(_LoadingHtml);//监听加载状态改变document.onreadystatechange = completeLoading;//加载状态为complete时移除loading效果function completeLoading() &#123; if (document.readyState == "complete") &#123; var loadingMask = document.getElementById('loadingDiv'); loadingMask.parentNode.removeChild(loadingMask);&#125;&#125; //在index.html中引入该文件]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css用border设置hover是出现div抖动和走位问题解决]]></title>
    <url>%2F2018%2F10%2F24%2FCss%E7%94%A8border%E8%AE%BE%E7%BD%AEhover%E6%98%AF%E5%87%BA%E7%8E%B0div%E6%8A%96%E5%8A%A8%E5%92%8C%E8%B5%B0%E4%BD%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[样式设置 ：div:hover { border:1px solid red;} 当鼠标移动到div时，产生抖动和偏移。 产生的原因：是因为设置border时设置了1px边框，多出的这1px，与其它元素产生了挤压， 导致div偏移。 解决方法：第一种方法：先将这个div设置一个跟背景颜色一样的边框，比如背景颜色为#aaa；那么你先设置这个div的样式：div {border:1px solid #aaa;}，然后再设置hover动作，div:hover { border:1px solid red;} 。 第二种方法：将这个div的border颜色设置为透明 ，div {border:1px solid transparent;},然后再引入hover动作div:hover { border:1px solid red;} 。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目实现图片的横向滚动]]></title>
    <url>%2F2018%2F10%2F23%2Fvue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[源起最近公司的AE编辑器项目有一项需求，就是滚动鼠标滚轮的时候实现图片列表的横向滚动。那么，如何在vue中实现这个功能呢？话不多说，上代码。 创建Firefox全局变量创建Firefox全局变量是为了达到浏览器兼容的效果。 创建global文件夹，并新建index.js。 index.js 12const Firefox = navigator.userAgent.indexOf('Firefox') != -1;export default &#123; Firefox &#125; vue文件引入global变量，并使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;div class=&quot;scenelist&quot;&gt; &lt;div class=&quot;listwrap&quot; id=&quot;listwrap&quot;&gt; &lt;draggable :options=&quot;&#123;chosenClass:&apos;chosen&apos;, animation: 500&#125;&quot; element=&quot;ul&quot; v-model=&quot;list&quot; :move=&quot;allow&quot;&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot; @click=&quot;cur_index = index&quot; :class=&quot;&#123;active: cur_index === index&#125;&quot;&gt; &lt;img :src=&quot;item.src&quot;&gt; &lt;div class=&quot;btns&quot;&gt; &lt;Tooltip content=&quot;复制场景&quot; placement=&quot;top&quot; class=&quot;btnitem&quot;&gt; &lt;a class=&quot;copybtn&quot; @click=&quot;copyPage(index)&quot;&gt; &lt;i class=&quot;iconfont icon-fuzhi&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/Tooltip&gt; &lt;Tooltip content=&quot;删除场景&quot; placement=&quot;top&quot; class=&quot;btnitem&quot;&gt; &lt;a class=&quot;deletebtn&quot; @click=&quot;showDelMessage(index)&quot;&gt; &lt;i class=&quot;iconfont icon-shanchu&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/Tooltip&gt; &lt;/div&gt; &lt;div class=&quot;itemcount pa&quot;&gt;&#123;&#123;index+1&#125;&#125;&lt;/div&gt; &lt;div class=&quot;checkall&quot;&gt;&lt;/div&gt; &lt;/li&gt; &lt;/draggable&gt; &lt;/div&gt; &lt;a class=&quot;addscene&quot; @click=&quot;addScene()&quot;&gt; &lt;Icon type=&quot;md-add&quot; /&gt; &lt;/a&gt; &lt;Modal v-model=&quot;showModal&quot; title=&quot;提示&quot; @on-ok=&quot;delPage&quot; width=&quot;300&quot;&gt; &lt;p&gt;删除后不可恢复, 是否继续?&lt;/p&gt; &lt;/Modal&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import global_ from &apos;../../global/index&apos; export default &#123; methods:&#123; MouseWheel(e) &#123; e = e || window.event; if (e.stopPropagation) &#123; e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; &#125; if (e.preventDefault) &#123; e.preventDefault(); &#125; else &#123; e.returnValue = false; &#125; if (global_.Firefox) &#123; if (e.detail &gt; 0) &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() + 60); &#125; else &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() - 60); &#125; &#125; else &#123; if (e.wheelDelta &lt; 0) &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() + 60); &#125; else &#123; $(&apos;#listwrap&apos;).scrollLeft($(&apos;#listwrap&apos;).scrollLeft() - 60); &#125; &#125; &#125; &#125;, mounted() &#123; let scrollDiv = document.getElementById(&quot;listwrap&quot;); global_.Firefox ? scrollDiv.addEventListener(&apos;DOMMouseScroll&apos;, this.MouseWheel, false) : (scrollDiv.onmousewheel = this.MouseWheel); &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
